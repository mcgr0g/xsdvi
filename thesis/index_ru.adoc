= Визуализация XML схемы
Václav Slavětínský <https://sourceforge.net/u/vaclaforge/profile/>;
květen 2008
:doctype: book
:sectnums:
:toc: left
:icons: font
:experimental:

== Введение

XML позволяет разработчикам создавать собственные форматы для хранения и обмена данными, следуя правилам синтаксиса.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное объявление и документация,
то есть описание, которое позволит им обмениваться, определяться и использоваться. Для этого было разработано несколько языков.
К ним относятся W3C _XML schema_, DTD (_Document Type Definition_) и Oasis _Relax NG_.

Благодаря интеграция с другими стандартами на основе XML, а также широким возможностям и поддержке крупных компаний-разработчиков программного обеспечения - часто используют схему XML.
Однако его спецификация (см. <<XSD1>>, <<XSD2>>) довольно сложна, и схемы могут стать запутанными для пользователя.
Причиной этого являются различные возможности написания, вытекающие из объектных элементов этого языка.
Схема XML позволяет использовать, расширять и ограничивать типы данных;
создание ссылок на элементы, атрибуты и группы элементов или атрибутов;
элементы могут быть заменены механизмом групп замещения;
также можно импортировать, вставлять и переопределять внешние схемы или их части.

Тема данной работы - визуализация XML-схем.
Цель состоит в том, чтобы спроектировать и реализовать приложение, которое на входе получит экземпляр XML-схемы W3C, а на выходе бы
сохранила свое интерактивное графическое представление в формате SVG (_Scalable Vector Graphics_) <<SVG>>.
Это графическое представление или диаграмма могут использоваться как часть документации, соответствующей схеме XML.
На диаграмме будут показаны структуры используемых элементов и атрибутов, их имена, пространства имен,
типы данных и дополнительная информация - количество элементов, обязательное / необязательное использование атрибутов, определенные уникальные, первичные и внешние ключи и т. д.
Это также позволит просматривать структуры, открывать и скрывать подгруппы элементов и атрибутов, используя _ECMAScript_.
Важными требованиями являются то, чтобы графика была интерактивной, интуитивно понятной и понятной,
потому что целью работы является главным образом облегчить ориентацию и понимание XML-схем их пользователями - создателями XML-документов.

Файлы SVG можно открывать в современных веб-браузерах (для некоторых необходимо установить плагин SVG)
или в приложениях, предназначенных для просмотра или редактирования векторной графики.
Многие из них находятся в свободном доступе. Векторная графика использует геометрические объекты для представления изображений, что облегчает программное редактирование.
Однако некоторые ограничения возникают из-за сложности обработки и медленной реализации ECMAScript в браузерах.
Это становится очевидным в больших схемах, точнее в больших структурах описанных документов.
(большие структуры могут быть определены даже с относительно короткой схемой).
Ограничение отражается в более медленной реакции на события и, как правило, в более медленном построении диаграммы.
В этой области мы можем только надеяться, что в будущем появиться более лучшая поддержка (support).

Само приложение будет написано на языке программирования Java и будет использовать пакеты синтаксического анализатора _Xerces_,
которая является реализацией интерфейса с открытым исходным кодом, определенного в <<XSD1>> и <<XSD2>>.
Для запуска вам необходимо установить среду исполнения _Java Runtime Environment_.
Сегодня, однако, JRE является общей частью большинства компьютеров.
С помощью Java приложение может быть легко перенесено на разные платформы.

Позвольте мне кратко упомянуть структуру работы.
Цель второй главы - познакомить читателя с технологиями, используемыми в приложении, и способами их использования.
К ним относятся XML-схема W3C, масштабируемая векторная графика, ECMAScript и объектная модель документа, каскадные таблицы стилей, язык Java.

Специальная глава (третья) посвящена возможностям загрузки и интерпретации модели XML-схемы.
Существует описание нескольких реализаций с открытым исходным кодом абстрактной модели данных XML-схемы и их оценка.
Я наконец выбрал процессор Xerces2-J из этих реализаций.
Он создает основу программы, предоставляя легкий доступ к компонентам схемы и их свойствам.

Четвертая глава посвящена разработке графической модели.
Сначала выбирается соответствующий тип, логическая модель; она четко отображает структуру определенных документов XML.
Ниже приведен анализ отдельных элементов - графических символов компонентов схемы - и их структуры.
Для каждого символа вы найдете изображения, значения и описания параметров, относящиеся к свойствам компонентов схемы.
Описан механизм интерактивности модели и возможность дополнительной модификации внешнего вида с помощью внешнего стиля.

Цель пятой главы - разработать алгоритм обработки схемы.
Вам нужно пройтись по некоторым компонентам и извлечь данные визуализации из их свойств.
Обработка компонентов, значение которых также описано здесь, обеспечивается отдельными методами.
Они вызывают друг друга, обмениваются параметрами и создают графические символы для последующего сохранения в файл SVG.

В заключение постараюсь подвести итоги работы и указать, где можно скачать приложение.

== Используемые технологии

=== XML-схема

XML, _Extensible Markup Language_, расширяемый язык разметки, позволяет разработчикам создавать свои собственные форматы
для хранения и обмена данными. Это создает новые словари пунктов - элементов и их свойств(качеств) - атрибутов.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное информация и документация,
то есть описание, которое позволяет совместно использовать, определять и использовать словари.

_XML схема_
    footnote:[Второе издание датировано 28 октября 2004 г., первое было утверждено 2 мая 2001 г.]
является спецификацией, выпущенной консорциумом W3C.
    footnote:[Консорциум World Wide Web, официальный сайт. http://www.w3.org/]
Определяет объектно-ориентированный язык, который можно использовать для формального описания документов XML;
он предоставляет средства для определения их структуры, содержания и семантики.
В частности, мы можем использовать схему для определения элементов и атрибутов, применимых к документу, включая их
структуру - взаимное погружение и совмещение; мы также можем указать тип данных для содержимого элемента или атрибута,
значений по умолчанию и других ограничений целостности. К ним относятся уникальные ключи (_unique_),
первичные ключи (_key_) и внешние ключи (_keyref_), ссылающиеся на них.

Схему XML часто сравнивают с другим распространенным языком схемы - DTD, _Document Type Definition_.
Это уже было включено в спецификацию XML 1.0 W3C <<XML>>.
Наиболее важные различия заключаются в том, что DTD использует свой собственный синтаксис, а схема XML является приложением XML, то есть использует его синтаксис.
Другой причиной выбора схемы XML является возможность назначения типов данных для атрибутов и содержимого элементов.
У DTD не было этого базового свойства, поэтому все значения обрабатывались как текстовые строки.
Также не было возможности работать с пространствами имен.
Однако DTD все еще широко используются, главным образом для простоты.

Спецификация схемы XML и ее нотация XML являются сложными, а в некоторых местах довольно сложными для понимания и использования.
Поэтому были разработаны и другие языки: _Relax NG_ с общим (XML) и компактным синтаксисом и _Schematron_ с другим подходом - для проверки правил.
Однако схема XML имеет самое широкое применение, в том числе и потому, что она поддерживается крупными компаниями-разработчиками программного обеспечения (Microsoft, IBM, Oracle, Sun).

Схема XML формализует ограничения, выраженные в виде правил или структурных моделей, которым соответствует определенный класс документа XML.
Схемы часто служат инструментами проектирования, устанавливая структуру, на которой могут быть построены конкретные реализации.
Существует несколько типичных областей применения схем.
В основном это валидация, документирование, запросы, биндинг данных и редактирование данных <<XSD-VLIST>>:

* _Валидация_ означает проверку XML-документа на соответствие схеме.
    Он часто используется для управления доступом XML к приложению.
    Он действует как фильтр; документы, соответствующие схеме, будут переданы, другие не будут использоваться.
    Это внешнее управление значительно упрощает приложения, которые в противном случае должны были бы обрабатывать многие исключения, встречающиеся в
    обработка неудовлетворительных входных данных XML.

* _Документирование_ означает описание в виде XML-документа.
    Это формально и машиночитаемо. Поскольку схема XML является документом XML,
    формальная документация может быть легко преобразована в удобочитаемую,
    например, используя преобразования XSLT или другие преобразования.
    Также приложение, которое является результатом этой дипломной работы бакалавра, выполняет такое преобразование в изображение

* Схемы обеспечивают поддержку _query_, поиск содержимого в документах XML.
    Это можно сделать без них, кроме дополнительной информации о структуре и типах данных
    поможет ускорить и упростить поиск и сортировку и сопоставление.
    Использование можно найти на языках _XPath 2.0_, _XSLT 2.0_, _XQuery 1.0_.

* XML-схемы используются с самого начала для _биндинга данных_.
    Это означает преобразование данных, содержащихся в документах XML, в структуры конкретных приложений,
    такие как объекты в объектно-ориентированных системах и реляционные таблицы систем реляционных баз данных.
    Схемы предоставляют дополнительную информацию о типах данных, которые преобразуются в типы данных приложения.

* Как правило, схемы обычно используют для _редактирования_ XML-документов. Например, эта работа взята из _DocBook_,
    который также является применением XML. Редактор, который я использую, дает мне выбор элементов,
    которые допустимы на месте согласно схеме. Это значительно облегчает работу.
    Редактор использует DTD DocBook, предоставляя информацию о структуре,
    Кроме того, схемы XML предоставляют информацию о типах данных.


[float]
==== Компоненты схемы

Процессор схемы XML, соответствующие спецификации W3C <<XSD1>>,
должен работать с информацией, содержащейся в диаграмме, как описано в спецификации.
Схема XML рассматривается здесь как абстрактная модель данных концептуального уровня, независимая от реализации.
Модель данных состоит из отдельных, точно определенных компонентов – _komponent_.
Каждый из них включает в себя описание представления  XML, свойства и ограничения, описание правил проверки,
обращения к PSVI (_Post Schema Validation Infoset_),
    footnote:[Это XML infoset (набор информации), дополнен дополнительной информацией о типе отдельных пунктов – элементов,
        атрибутов, обычных узлов.]
и любые встроенные экземпляры этих компонентов.

Определение следующее:
    "`_Компонент схемы_ - это общий термин, который представляет строительные элементы
      составляющие модель данных абстрактной схемы... _XML Схема_ - это набор компонентов схемы.`"
    footnote:[XML Schema Abstract Data Model. http://www.w3.org/TR/xmlschema-1/#concepts-data-model]

Существует 13 видов компонентов, которые можно разделить на 3 группы.
_Приложение будет работать с ними, как описано в главе <<XSD-PROCESSING>>._
Чтобы быстро понять отношения между компонентами, используйте диаграмму <<DIAGRAM_KOMPONENT>>.
    footnote:[там же.]

[[DIAGRAM_KOMPONENT]]
.Диаграмма компонент XML схемы
image::images/components.gif[]

Первичные компоненты могут или должны быть названы:

* определение простых типов (_Simple type definitions_),
* определение сложных типов (_Complex type definitions_),
* декларирование атрибута (_Attribute declarations_),
* декларирование элемента (_Element declarations_).

Вторичные компоненты должны именоваться:

* определение групп атрибутов (_Attribute group definitions_),
* определение ограничений идентичности (_Identity-constraint definitions_),
* определение группы моделей (_Model group definitions_),
* декларирование нотации (_Notation declarations_).

Вспомогательные компоненты обеспечивают доступ к другим компонентам. Они зависят от контекста:

* аннотирование (_Annotations_),
* модельные группы (_Model groups_),
* гранулы (_Particles_),
* символы подстановки (_Wildcards_),
* использование атрибутов (_Attribute Uses_).


=== SVG

_Scalable Vector Graphics_, škálovatelná vektorová grafika vznikla také na půdě konsorcia W3C.
Základ vývoje tvoří specifikace SVG 1.1 <<SVG>>.
Kolem ní však existuje a vzniká řada dalších:
_SVG Tiny 1.2_,
_SVG Mobile 1.1_,
_SVG Print_,
_SVG Filters_,
_SVG Requirements_.
Jejich předmětem je jazyk pro popis dvourozměrné grafiky a grafických aplikací pomocí XML.
Jedná se přitom o vektorovou grafiku, která používá k reprezentaci obrázků geometrické objekty.
To přináší možnost škálování – zmenšování a zvětšování – bez ztráty kvality; objekty, z nichž se obraz skládá,
jsou odlišeny a vzniklé soubory zabírají obvykle méně místa než soubory bitmapové.
Je samozřejmé, že se vektorová grafika hodí pouze na některé druhy obrázků, jako jsou třeba symboly, diagramy nebo grafy.
_Výstup aplikace, jež je předmětem této práce, bude diagram XML schématu v SVG._

Formát SVG byl navržen hlavně pro použití na webu, díky tomu je ho dnes možné přímo otevřít v prohlížečích
Mozilla Firefox, Opera; v MS Internet Explorer bohužel až po nainstalování příslušného zásuvného modulu (Adobe SVG Viewer).
Stejně tak je formát podporován i v komerčních (Adobe Illustrator, CorelDraw) či open source (Inkscape, Sodipodi) editorech.

SVG poskytuje tři typy grafických objektů.
Jsou to tvary vektorové grafiky, například cesty složené z úseček a křivek, obrázky a text.
Tyto objekty mohou být seskupovány, lze je transformovat, předrenderovat a přiřadit jim styly.
K dalším funkcím patří vnořené transformace, ořezávání objektů podle cest, alpha masking, filtrování obrazu a objekty sloužící jako šablony.

Výsledné obrázky mohou být interaktivní a dynamické.
Animace lze definovat a spouštět deklarativně pomocí speciálních SVG elementů nebo skriptováním.
Skriptovacím jazykům jsou zpřístupněny všechny elementy, atributy a vlastnosti přes SVG _Document Object Model_ (DOM).
K libovolným grafickým objektům lze přiřadit různé ovladače událostí, jako onmouseover, onclick.footnote:[Při najetí myši, při kliknutí myši.]

Dále je možné SVG vkládat do jiných XML formátů, k tomu se využívá technologie jmenných prostorů (_namespace_).
Zajištěna je i kompatibilita v tom smyslu, že skriptování lze provádět zároveň například na XHTML
(_Extensible HyperText Markup Language_) webové stránce, do které byly vloženy elementy SVG.
Podobně snadné je využití kaskádových stylů (_Cascading Style Sheets_, CSS) pro popis vzhledu jednotlivých objektů.

[float]
==== Elementy použité ve výstupu aplikace

Následuje stručná charakteristika SVG elementů, které využívá aplikace pro grafickou prezentaci schématu.
U elementů jsou dále uvedeny i některé důležité atributy.
Vedle nich jsou ještě potřeba běžné atributy: [.property]``id`` pro jednoznačnou identifikaci elementu v rámci dokumentu a [.property]``class`` pro zařazení elementu do určité skupiny, které pak lze například přiřadit styl.
Ukázku konkrétního použití naleznete v příloze <<EXAMPLES-SVG-XML>>.

==== <svg>
footnote:[http://www.w3.org/TR/SVG11/struct.html#NewDocument]

Fragment SVG dokumentu se skládá z libovolného počtu SVG elementů obalených tagem `<svg>`
V našem případě nepůjde o fragment, ale o samostatný dokument, jehož kořenovým elementem bude `<svg>`
Krom obvyklých atributů ([.property]``id``, [.property]``class``) zde budou:

* [.property]``xmlns`` – deklarace jmenných prostorů,
* [.property]``onload`` – spustí skript při nahrání tohoto elementu.


==== <title>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DescriptionAndTitleElements]

Titulek, krátký popisek může být přidán každému kontejneru nebo grafickému elementu.
Nebude přímo renderován, může být ale zobrazen jako _tooltip_.
Titulek přidaný `<svg>` elementu zobrazí prohlížeč v záhlaví okna.

==== <script>
footnote:[http://www.w3.org/TR/SVG11/script.html#ScriptElement]

Slouží pro vložení skriptu, bude zařazen jako dítě `<svg>` elementu.
Samotný skript je třeba obalit sekcí 
`<![CDATA[ skript ]]>`
, aby interpret chápal obsah pouze jako text a nehledal v něm značky.

* Atribut [.property]``type`` – určuje skriptovací jazyk, hodnotou je MIME typ, v případě ECMAScriptu ``text/ecmascript``.


==== <defs>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DefsElement]

Obsahuje elementy, na které je v dokumentu odkazováno.
Obsah může být stejný jako u kontejneru `<g>` , rozdíl spočívá v tom, že grafické objekty zde uvedené nebudou přímo renderovány.
Do definic ve výstupu aplikace zahrneme styl `<style>` a často využívané symboly `<symbol>`

==== <style>
footnote:[http://www.w3.org/TR/SVG11/styling.html#StyleElement]

Slouží pro vložení stylu, popisujícího grafickou úpravu objektů a jejich skupin.
Opět bude vhodné styl obalit sekcí `<![CDATA[ styl ]]>`

* Atribut [.property]``type`` – určuje jazyk stylu, hodnotou je MIME typ,
    footnote:[RFC specifikace 2045: Multipurpose Internet Mail Extensions. http://www.ietf.org/rfc/rfc2045.txt]
    v případě kaskádového stylu ``text/css``.


==== <symbol>
footnote:[http://www.w3.org/TR/SVG11/struct.html#SymbolElement]

Symbol definuje grafický vzor, který se nerenderuje, dokud není použit v SVG dokumentu elementem `<use>`
Definovat symboly má smysl u často používaných objektů.
V této aplikaci to budou zatím dva – _plus_ a _minus_ pro rozevírání a skrývání podstromu grafických symbolů (boxů).
Využijeme pouze běžné atributy.

==== <use>
footnote:[http://www.w3.org/TR/SVG11/struct.html#UseElement]

Odkazuje na jiný element a signalizuje, že jeho grafický obsah má být zahrnut a vykreslen v místě, kde je element `<use>`
uveden. Může se jednat o grafické elementy, `<g>`, `<svg>`, `<use>` a (v našem případě pouze) `<symbol>`
Kromě obvyklých atributů zde využijeme:

* [.property]``x`` – určuje souřadnici na ose X, kde bude umístěn odkazovaný objekt,
* [.property]``y`` – určuje souřadnici na ose Y, kde bude umístěn odkazovaný objekt,
* [.property]``xlink:href`` – URI odkaz na objekt, realizováno pomocí identifikátoru,
* [.property]``onclick`` – spouští skript při kliknutí na grafický objekt, tím bude symbol _plus_ nebo _minus_. Skript provede rozbalení nebo skrytí podstromu grafických symbolů (boxů).


==== <g>
footnote:[http://www.w3.org/TR/SVG11/struct.html#Groups]

Představuje kontejner pro seskupení souvisejících grafických elementů.
Použijeme ho pro sdružení SVG elementů tvořících konkrétní grafický symbol komponenty schématu (box).

* Atribut [.property]``transform`` – pro určení grafické transformace obsahu.
Grafiku lze posouvat, škálovat, otáčet a zešikmit.
My budeme pouze posouvat boxy o _x_ jednotek po ose X a o _y_ jednotek po ose Y pomocí
[.property]``transform``
 = ``translate``(
    [.parameter]``x``
    ,
    [.parameter]``y``
    ).


==== <text>
footnote:[http://www.w3.org/TR/SVG11/text.html#TextElement]

Definuje textový grafický element. Ten je renderován stejnými metodami jako ostatní grafické elementy.
Bude sloužit ke zobrazení různých názvů, vlastností a popisků v boxech. Budeme potřebovat atributy:

* [.property]``x`` – reprezentuje absolutní pozici textu, počítanou od prvního znaku, na ose X.
    Také je možné uvést více (_n_) hodnot, které pak reprezentují pozice prvních _n_ znaků.

* [.property]``y`` – reprezentuje absolutní pozici textu, počítanou od prvního znaku, na ose Y.
    I zde můžete uvést více hodnot, oddělených mezerou nebo čárkou, s významem jako u atributu [.property]``x``.

* [.property]``visibility`` – určuje, jestli bude text viditelný, skrýtý, nebo zdědí viditelnost po svém rodiči.
    Tento atribut bude třeba pro skrývání a odkrývání některých popisků symbolů komponent schématu.


==== <line>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#LineElement]

Definuje úsečku.
Pomocí úseček a křivek budou propojeny jednotlivé grafické symboly (boxy),
Z úseček budou složeny i další prvky.
Použijeme atributy:

* [.property]``x1`` – souřadnice začátku úsečky na ose X,
* [.property]``y1`` – souřadnice začátku úsečky na ose Y,
* [.property]``x2`` – souřadnice konce úsečky na ose X,
* [.property]``y2`` – souřadnice konce úsečky na ose Y.


==== <polyline>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolylineElement]

Definuje množinu propojených úseček, typicky tvoří neuzavřené tvary.
Element `<polyline>` použijeme pouze v některých grafických symbolech komponent schématu.

* Atribut [.property]``points`` – seznam párů souřadnic podle os X a Y, začátky a konce úseček, z nichž se skládá tento útvar.


==== <polygon>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolygonElement]

Definuje uzavřený tvar, skládající se z množiny propojených úseček.
Element `polygon` použijeme pouze v některých grafických symbolech komponent schématu.

* Atribut [.property]``points`` – seznam párů souřadnic podle os X a Y, tvořících polygon.


==== <rect>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#RectElement]

Definuje obdélník. Ten poslouží k vykreslení boxů, jejich stínů a dalších grafických prvků.
Pro klasifikaci použijeme atribut [.property]``class``, dále:

* [.property]``x`` – souřadnice strany obdélníku podle osy X, té strany,
    jejíž souřadnice má nižší hodnotu v uživatelském souřadnicovém systému (většinou jde o levou stranu).
* [.property]``y`` – souřadnice strany obdélníku podle osy Y,
    strana je určena analogicky jako u atributu [.property]``x``, většinou jde o horní stranu.
* [.property]``width`` – šířka obdélníku,
* [.property]``height`` – výška obdélníku,
* [.property]``rx`` – poloměr elipsy, jež tvoří zaoblené rohy obdélníku, podle osy X.
* [.property]``onclick`` – stejný význam jako u elementu `<use>`, atribut bude nastaven u obdélníkových ovládacích tlačítek.


==== <circle>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#CircleElement]

Definuje kružnici, kruh. Ty ve výstupu aplikace poslouží pouze jako dodatečné grafické prvky. Použijeme atributy:

* [.property]``cx`` – souřadnice středu kruhu na ose X,
* [.property]``cy`` – souřadnice středu kruhu na ose Y,
* [.property]``r`` – poloměr.


==== <path>
footnote:[http://www.w3.org/TR/SVG11/paths.html#PathElement]

Reprezentuje obrys tvaru. Může být vyplněn, obtažen nebo sloužit jako cesta, podle které budou ořezávány jiné objekty.
V této aplikaci bude sloužit jako koncová část propojení boxů.

* Atribut [.property]``d`` – definice obrysu tvaru.
    Obecně je tvořená příkazy _moveto_, _lineto_, _curveto_, _arc_ a _closepath_, buď absolutními, nebo relativními.
        footnote:[Přesun kurzoru na zadanou pozici bez kreslení čáry; s vykreslením úsečky;
        s vykreslením podrobněji stanovené křivky; s vykreslením oblouku; s vykreslením úsečky vedoucí k počátečnímu
        bodu tak, aby vznikl uzavřený tvar.]
    K příkazům se dále zadávají páry souřadnic podle os X a Y.


=== ECMAScript

ECMAScript je skriptovací jazyk, standardizovaný organizací _Ecma International_ ve specifikaci _ECMA-262_.
    footnote:[Ecma International: Standard ECMA-262. ECMAScript Language Specification 3rd edition (December 1999).
    http://www.ecma-international.org/publications/standards/Ecma-262.htm]
Je široce používán na webu a bývá často označován jako _JavaScript_ nebo _JScript_, podle hlavních dialektů tohoto jazyka.
Syntaxe se záměrně podobá syntaxi _Javy_, ale je uvolněnější, aby se docílilo snazšího použití, například není třeba deklarovat typ proměnných.
Zároveň však tento přístup zvyšuje pravděpodobnost výskytu chyby.

ECMAScript je objektově orientovaný programovací jazyk pro provádění výpočtů a manipulaci s objekty _v hostitelském prostředí_.
Nefunguje tedy samostatně, vstup a výstup dat a zpracovávané objekty poskytuje jiný, existující systém, jehož možnosti jsou rozšiřovány skriptováním.
To je podstatou skriptovacích jazyků. _V této aplikaci bude skript sloužit k zajištění interaktivity SVG modelu schématu v prostředí prohlížeče._
Konkrétnější informace jsou v oddílu <<INTERACTIVITY>>.

ECMAScript byl původně vyvíjen pro web za účelem oživení webových stránek a přenesení části výkonu na klienta – prohlížeč – v klient-server architektuře.
Pokud se jedná o HTML (_HyperText Markup Language_) stránku, poskytne prohlížeč objekty reprezentující okna, menu, dialogové boxy, textové oblasti, odkazy, rámy a další.
Dále poskytne způsoby, jak spustit skriptovací kód při událostech, například nahrávání stránky, změna velikosti okna, pohyb myši, kliknutí.

My však nepotřebujeme speciální prvky jazyka HTML, ale rozhraní k SVG nebo obecně XML objektům.
Obecné rozhraní je standardizováno v další specifikaci konsorcia W3C, nazývá se DOM (_Document Object Model_).
    footnote:[W3C: Document Object Model (DOM). http://www.w3.org/DOM/] DOM existuje v několika úrovních – level 1 až 3.
V této aplikaci by stačila úroveň druhá.
Pro programovou manipulaci s objekty škálovatelné grafiky vznikl speciální SVG DOM.
Ten je součástí specifikace SVG
    footnote:[Appendix B: SVG Document Object Model (DOM). http://www.w3.org/TR/SVG/svgdom.html]
a dále rozšiřuje DOM Level 2.
SVG DOM bychom mohli dobře využít, ale museli bychom se pak potýkat s nekompatibilitou některých prohlížečů.
Nakonec proto zůstaneme u základního DOM úrovně 2, který je více rozšířen.
Budeme potřebovat metody a atributy blíže popsané v <<DOM1>> a <<DOM2>>, jejich konkrétní uplatnění je ukázáno na příkladu <<EXAMPLES-SVG-XML>>:

* [.interface]#Document#
    :
        [.interface]#Element#
        [.method]``getElementById``
    (in
        [.interface]#DOMString#
        [.parameter]``elementId``
    ); pro získání elementu podle jeho identifikátoru, který je uveden v atributu
        [.property]``id``
    .

* [.interface]#Document#
    :
        [.interface]#NodeList#
        [.method]``getElementsByTagName``
    (in
        [.interface]#DOMString#
        [.parameter]``tagname``
    ); pro získání seznamu uzlů se zadaným jménem tagu.

* [.interface]#Node#
    :
        `readonly attribute`
        [.interface]#NodeList#
        [.property]`childNodes`
    ; obsahuje seznam všech dětí daného uzlu.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]``getAttribute``
    (in
        [.interface]#DOMString#
        [.parameter]``name``
    ); pro získání hodnoty atributu se zadaným názvem.

* [.interface]#Element#
    :
        `void` [.method]``setAttribute``
    (in
        [.interface]#DOMString#
        [.parameter]``name``
    , in
        [.interface]#DOMString#
        [.parameter]``value``
    );
    slouží k nastavení hodnoty atributu s daným názvem nebo k vytvoření nového atributu tohoto uzlu se
    zadaným názvem a hodnotou.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]``getAttributeNS``
    (in
        [.interface]#DOMString#
        [.parameter]``namespaceURI``
    , in
        [.interface]#DOMString#
        [.parameter]``localName``
    );slouží k získání hodnoty atributu s daným lokálním jménem a jmenným prostorem.

* [.interface]#Element#
    :
        `void`[.method]``setAttributeNS``
    (in
        [.interface]#DOMString#
        [.parameter]``namespaceURI``
    , in
        [.interface]#DOMString#
        [.parameter]``qualifiedName``
    , in
        [.interface]#DOMString#
        [.parameter]``value``
    );
    slouží k nastavení hodnoty atributu s daným názvem a v daném jmenném prostoru nebo k vytvoření
    nového atributu tohoto uzlu se zadaným názvem a hodnotou, v daném jmenném prostoru.


=== CSS

CSS, _Cascading Style Sheets_, kaskádové styly jsou opět výsledkem aktivity organizace W3C.
    footnote:[W3C: Cascading Style Sheets. Home page. http://www.w3.org/Style/CSS/]
Specifikace definuje jazyk pro popis stylů, který umožňuje tvůrcům i uživatelům připojit styl
(například fonty a odsazení) strukturovaným dokumentům, jako jsou HTML dokumenty a aplikace XML.
Lze tak docílit oddělení definice vzhledu dokumentu od jeho obsahu a zjednodušit tvorbu webu i jeho správu.

Jazyk CSS je navržen tak, aby byl snadno čitelný pro člověka, stylový předpis je vyjádřen v terminologii, jež je běžná v DTP.
Jednou ze základních vlastností je, že styl je _kaskádový_.
To znamená, že se na sebe může vrstvit více definic stylu, ale platí pouze ta poslední.
Tvůrce připojí k dokumentu preferovaný styl, ale uživatel ho může překrýt svým vlastním,
přizpůsobeným lidskému nebo technologickému handicapu <<CSS>>.

Předpis se skládá z jednotlivých _pravidel_.
Každé pravidlo pak určuje vzhled jednoho nebo více elementů – těch elementů, které jsou vybrány _selektorem_, první částí pravidla.
Za selektorem následuje seznam deklarací uzavřených složenými závorkami, jednotlivé deklarace jsou odděleny středníkem.
Každá deklarace je tvořena _vlastností_ (následuje dvojtečka) a _hodnotou_ vlastnosti.
Selektor může vybrat všechny elementy s určitým názvem nebo elementy obsahující zadané atributy,
může je označovat podle toho, kde jsou umístěny vzhledem k jiným elementům a vybírat podle
_pseudotříd_ (``:hover``) a _pseudoelementů_ (``:first-line``).
Pokud lze aplikovat na určitý element více pravidel, použije se to s větší prioritou.
Zjednodušeně se jedná o pravidlo s konkrétnějším selektorem.

_Kaskádový styl, který použijeme pro SVG výstup této aplikace, umožní snadnou dodatečnou manipulaci se vzhledem jednotlivých
tříd grafických prvků_, blíže v oddílu <<STYLE>>.

=== Java

Java je objektově orientovaný programovací jazyk pro všeobecné použití.
Byl vyvinut společností _Sun Microsystems_ a po svém představení v roce 1995 se stal jedním z nejpoužívanějších programovacích jazyků.
Od května roku 2007 je Java vyvíjena jako open source.

Charakteristickou vlastností je přenositelnost na různé platformy.
Jednou napsaný program lze spustit na libovolném podporovaném operačním systému a hardwaru.
Napsaný zdrojový kód se předkompiluje do takzvaného _bytecode_, který je pro všechny platformy stejný;
odlišují se pouze virtuální stroje (_Virtual Machine_). Ty bytecode interpretují, případně za běhu přeloží do nativního kódu.
Program je možné spustit všude, kde je odpovídající běhové prostředí (_Java Runtime Environment_).

Záměrem tvůrců Javy podle <<M254>> bylo vytvořit jazyk, který by byl:

* _Jednoduchý_: Java staví na několika základních konceptech, které se vývojáři snadno naučí.

* _Podobný zavedeným technologiím_: syntaxe je založena na syntaxi populárního jazyka C++, je však snížena jeho složitost.

* _Objektově orientovaný_: programy pracují s objekty. Definují se třídy objektů, které mohou dědit od jiných tříd,
    mohou implementovat připravená rozhraní. Objekty nebo celé třídy poskytují vlastnosti (atributy) a metody.
    Metody je možné překrývat a přetěžovat. Implementace je ukrytá;
    objekty poskytují veřejné rozhraní umožňující manipulaci s nimi, jinak jsou zapouzdřené. Jazyk je silně typový.

* _Robustní_: javové programy jsou před spuštěním striktně kontrolovány,
    jazyk vynechává různé možnosti C a C++, jež bývají náchylné k chybám.

* _Bezpečný_: Java obsahuje speciální nástroje zajištění bezpečnosti,
    programy běžící přes síť nemohou poškodit soubory v počítači nebo obsahovat viry.

* _Přenositelný_: programy mohou být snadno přesunuty z jedné platformy na jinou, a to s minimálními změnami nebo beze změn.

* _Vysoce výkonný_: javové programy běží dostatečně rychle vzhledem k požadovaným účelům.

* _Interpretovaný_: souvicí s přenositelností, viz výše.

* _Užívající programová vlákna_: to umožňuje programu vykonávat několik úkolů naráz a zvětšit tak výkon.

* _Dynamický_: programy se mohou přizpůsobovat změnám prostředí i za jejich běhu.

_Javu jsem pro tuto aplikaci zvolil hlavně kvůli přenositelnosti a velkému rozšíření, tento jazyk je mi blízký také díky
kurzům absolvovaným na VŠE._

== Možnosti načtení a interpretace modelu XML schématu

V předchozí kapitole jsem stručně popsal technologie užité v aplikaci pro interaktivní vizualizaci schémat.
Teď bude třeba rozhodnout se, jak schéma otevřít, načíst ho do paměti, interpretovat a zpracovat.
Na XML schéma lze nahlížet z několika úrovní:

[float]
=== Obyčejný textový soubor

Pokud bychom schéma chápali pouze jako textový soubor, museli bychom naprogramovat kompletní způsob interpretace značkování,
aby pak šlo s výsledkem pracovat jako s XML dokumentem. Toto naštěstí už dávno řeší standardizovaná rozhraní
jako SAX (_Simple API for XML_) a DOM (_Document Object Model_).

[float]
=== XML dokument

Dokument by stačilo načítat pomocí SAXu a přitom vyhledávat typické struktury tvořené převážně názvy elementů a
hodnotami atributů, důležité pro interpretaci schématu.
Tyto struktury by byly reprezentovány jako objekty a jejich vlastnosti, a to buď tak aby tyto objekty vyhovovaly
svému účelu – chceme pouze vizualizovat schéma –, nebo aby odpovídaly specifikaci.
Shoda se specifikací zajišťuje kompatibilitu, funkčnost a ulehčuje práci v případě změn.
Po přečtení souboru je však ještě třeba řešit další úlohy, mezi které patří:

* Načtení importovaných, vložených a předefinovávaných schémat a zajištění, aby přitom nedošlo k zacyklení.
* Vložení typů, které jsou podle specifikace zabudované jako součást schématu.
* Musí se řešit redefinice datových typů, skupin elementů a skupin atributů.
* Je třeba poskládat reference na globálně definované typy, primární a unikátní klíče, globálně deklarované elementy a atributy,
    globálně definované skupiny elementů a atributů.

I v této oblasti však existují hotové implementace, kterým stačí zadat vstupní soubor, nastavit je několika parametry a nechat načíst schéma.
Některou z nich určitě využijeme (viz <<XSD-API>>), ušetří to hodně práce.
Nakonec tedy budeme pracovat s nejvyšší úrovní, s abstraktním datovým modelem.

[float]
=== Abstraktní datový model

S interpretací schématu podle <<XSD1>> získáme jednoduchý přístup ke všem komponentám a vlastnostem.
Bližší popis zpracování je v kapitole <<XSD-PROCESSING>>.

[[XSD-API]]
=== Výběr vhodné implementace XML schématu

Nejlepší variantou bude vyhledat přijatelnou open source implementaci vyhovující specifikaci a naučit se s ní zacházet.
Následuje popis čtyř známých otevřených aplikací, které se schématem pracují, a výběr jedné z nich.

==== Eclipse: Model Development Tools – XSD
footnote:[Eclipse Modeling: Model Development Tools(MDT). http://www.eclipse.org/modeling/mdt/?project=xsd#xsd]

_Model Development Tools_ (MDT) tvoří součást projektu organizace _Eclipse_,
který je zaměřen na rozvoj a propagaci technologií pro vývoj založený na modelech – Eclipse Modeling Project.
Eclipse poskytuje řadu frameworků, nástrojů a implementací technologických standardů.
MDT konkrétně má nabídnout implementaci standardních metamodelů a ukázkové nástroje pro vývoj modelů, postavených na těchto metamodelech.
Součástmi MDT jsou:

* Business Process Model and Notation (BPMN2),
* Ontology Definition Metamodel (EODM),
* Information Management Metamodel (IMM),
* Object Constraint Language (OCL),
* Semantics of Business Vocabulary and Business Rules (SBVR),
* Unified Modeling Language (UML2),
* UML2 Tools,
* XML Schema Infoset Model (XSD).

_XML Schema Infoset Model_ je knihovna, která poskytuje rozhraní pro aplikace, jež prohledávají, 
tvoří nebo modifikují W3C XML schémata. Pro manipulaci s komponentami je možné využít rozhraní popsáné ve specifikaci, 
ale stejně tak lze pracovat s DOM reprezentací schématu. Při modifikacích se mění obě reprezentace odpovídajícím způsobem.
Knihovna zahrnuje i služby pro serializaci a deserializaci schémat. _Cílem projektu je zcela obsáhnout funkcionalitu 
reprezentace XML schématu_, není ale nutné poskytnout validační služby, obvyklé u validujících parserů (Xerces-J).

==== Apache: Xerces2 Java Parser – XML Schema
footnote:[The Apache XML Project: Xerces2 Java ParserReadme. http://xerces.apache.org/xerces2-j/]

_Xerces2_ je open source XML parser vyvinutý organizací _Apache_, jeho výhodou je vysoký výkon a shoda se standardy.
Krom jiného zahrnuje Xerces Native Interface, framework pro stavbu komponent a konfigurací parserů.

Xerces dokáže parsovat dokumenty napsané podle doporučení XML 1.1 a správně pracuje také se jmennými prostory
podle specifikace XML Namespaces 1.1. Dále poskytuje kompletní implementaci DOM Level 3 Core,
Load and Save, implementuje XML Inclusions (jsou to doporučení W3C) a poskytuje podporu pro OASIS XML Catalogs v1.1.

_Xerces2 je také XML schéma procesor, který až na pár drobných výjimek plně vyhovuje specifikaci <<XSD1>> a <<XSD2>>_.

==== Saxonica: Saxon
footnote:[Saxon, The XSLT andXQuery Processor.http://saxon.sourceforge.net]

_Saxon_ je kompletní implementace XSLT 2.0, XQuery 1.0 a XPath 2.0 doporučení konsorcia W3C.
Je zveřejňován společností _Saxonica_, a to zároveň pro platformu Java a .NET.
Vydává se ve dvou verzích: Saxon-B je open source produkt, implementuje XSLT 2.0 a XQuery tak,
že vyhovuje specifikacím pouze v základní úrovni požadavků.
Saxon-SA je produkt komerční, umožňuje však aplikovat XSLT a XQuery s využitím schémat.
Lze tedy importovat schéma a validovat oproti němu vstup nebo výstup a vybírat položky podle jejich typu.
Saxon-SA obsahuje také samostatný XML schéma validátor a další rozšíření oproti produktu Saxon-B.

_Bohužel v open source verzi není rozhraní pro přístup ke komponentám XML schématu a proto Saxon nemůžeme použít._

==== ExoLab: Castor – Source Generator XML Schema Support
footnote:[The Castor Project.http://www.castor.org/xmlschema.html]

_Castor_ je open source framework pro Javu, slouží pro data binding, převod dat mezi objekty Javy, XML dokumenty a relačními tabulkami.

Součástí je mimo jiné i XML Source Code Generator.
Ten vytváří javové třídy, reprezentující objektový model podle vstupního XML schématu.
Castor proto podporuje specifikaci W3C XML Schema <<XSD1>>, <<XSD2>>.
Objektový model reprezentuje XML schéma v paměti počítače, zatímco generátor zdrojového kódu převádí datové
typy a struktury schématu do odpovídajících typů a struktur Javy.
_Objektový model schématu dokáže číst i zapisovat dokumenty a manipulovat s nimi.
Vyhovuje specifikaci bez omezení._ Generátor kódu zatím nenabízí mapování pro všechny komponenty.

==== Volba Xerces2

Z popsaných implementací nemůžeme použít Saxon, ostatní se zdají rovnocenné a plně vyhovují specifikaci.
Nakonec jsem vybral XML schéma procesor, který je součástí parseru _Xerces2-J_.
Je jednoduchý a poskytuje přesně ty možnosti, které budeme potřebovat.
Třídy reprezentující jednotlivé komponenty obsahují metody pro přístup k vlastnostem, jak jsou definovány ve specifikaci.
Modifikace vlastností není podporována a my bychom ji stejně nevyužili.
Snadné je také ovládání procesoru, načtení schématu a jeho zpracování, použití je dobře dokumentováno.
Krom toho je Xerces využíván pro účely vizualizace schématu ve známém XML editoru oXygen.
Eclipse MDT a Castor by posloužili stejně dobře, jejich funkcionalita je však zbytečně široká (práce s DOM stromem, tvorba a modifikace schémat).

== Návrh grafického modelu

Předtím, než začnu programovat aplikaci, která bude generovat grafickou reprezentaci XML schémat,
musím navrhnout, jak by tato reprezentace měla vypadat.
Budu se muset rozhodnout pro správný typ modelu, navrhnout symboly – prvky modelu – a jejich propojení,
budu se zabývat interaktivitou výsledného modelu. To vše je předmětem této kapitoly.

=== Dva typy modelů

Existují dva základní způsoby, jak zobrazit XML schéma.
Oba samozřejmě vycházejí ze stromové struktury XML dokumentů, liší se ale svou podrobností a zamýšleným účelem použití.
Rozdíl ukážu na výstupech aplikace _oXygen_,
    footnote:[Oxygen XML editor, oficiální stránky. http://www.oxygenxml.com]
která nabízí vykreslení obou typů.

Jako příklad poslouží toto jednoduché XML schéma:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="contact" type="ContactType"/>
    
    <xs:complexType name="ContactType">
        <xs:sequence>
            <xs:element name="phone" type="xs:string"/>
            <xs:element name="address" type="AddressType"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="AddressType">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="street" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
----

==== Úplný model

Úplný grafický model kopíruje XML reprezentaci schématu. Pro každý element je vykreslen vlastní symbol.
Krom toho je možné rozevírat strom symbolů dál a podívat se, co se skrývá za odkazy na globálně definované komponenty
schématu, jako jsou definice typů, globální deklarace elementů, jejich skupin, atd.

Například viz obrázek <<FULL-MODEL>>.
Za symbolem elementu `contact` jsem rozbalil větev s definicí jeho typu ``ContactType``.
Jedná se o sekvenci elementů `phone` a ``address``.
Dalším rozevíráním stromu bych se dostal na definice typů těchto elementů.
Stejně tak je ale mohu vidět níže jako potomky definice ContactType.

Úplný model je velmi podrobný.
Nabízí komponenty, jež je možno použít při rozšiřování schématu, ale zatím nejsou aplikovatelné v popisovaném dokumentu;
ukazuje detailně všechna nastavení a hodnoty, globální definice typů, deklarace skupin; uvádí importované a vložené soubory.
Je tedy určen spíše tvůrcům XML schémat a ne uživatelům.

[[FULL-MODEL]]
.Znázornění schématu úplným modelem
image::images/model_full.png[]


==== Logický model

Logický grafický model oproti tomu zobrazuje pouze základní informace, důležité pro tvůrce XML dokumentů, vyhovujících schématu.
Symbolů je podstatně méně než v případě úplného modelu.
Jde o to, ukázat uživateli možnou strukturu elementů a atributů.
Reference na globální komponenty musí být poskládány stejně jako u úplného modelu,
při procházení stromu ale není na první pohled patrné, ve které části schématu je prvek definován.

Například viz obrázek <<LOGICAL-MODEL>>.
Kořenovým elementem validních XML dokumentů je ``contact``.
Uvnitř něj se musí objevit sekvence elementů `phone` a ``address``.
Zatímco `phone` obsahuje textový řetězec (_string_), je uvnitř elementu `address` další posloupnost,
a to elementy ``name``, `street` a ``city``.
Každý z nich je typu textový řetězec.

Logický model je tedy vhodný pro uživatele XML schémat, usnadňuje jim pochopení definovaných struktur;
ale i tvůrcům umožní rychlejší kontrolu jejich práce.
Právě logický model bude výstupem mé aplikace, neboť cílem je vytvořit dokumentaci schématu,
která bude intuitivní a každý se v ní rychle vyzná.
Dokumentace nebude popisovat XML schéma, ale XML dokumenty schématu vyhovující;
konkrétně strukturu (kombinování, zanořování) elementů, jejich atributy a datové typy.
Elementy schématu, které nejsou nezbytné pro pochopení účelu, budou z modelu vypuštěny, stejně tak komponenty, jež nejsou přímo využity.

[[LOGICAL-MODEL]]
.Znázornění schématu logickým modelem
image::images/model_logical.png[]


=== Model jako stromová struktura abstraktních symbolů

Z uvedených ukázek a z podstaty XML dokumentů plyne, že lze symboly, tvořící grafický model,
chápat jako uzly stromové struktury.
Na základní úrovni proto bude existovat abstraktní symbol ([.class]``AbstractSymbol``)
s odkazem na svého rodiče a řazeným seznamem odkazů na své děti.
[.class]``AbstractSymbol`` bude poskytovat metody pro získávání a nastavování těchto odkazů a dotazování na další informace.

Dále je pro vykreslení každého symbolu třeba znát horizontální ([.parameter]``xPosition``)
a vertikální pozici ([.parameter]``yPosition``), každý symbol má šířku a výšku.
[.class]``AbstractSymbol`` definuje také metody pro nastavení správné šířky a výšky a pro vykreslení symbolu.
Ty musí být přepsány konkrétním symbolem.

[[ABSTRACT-MODEL]]
.Model abstraktních symbolů
image::images/abstract_symbols.png[]


=== Symboly jednotlivých komponent schématu

Konkrétní symbol rozšiřuje vlastnosti abstraktního symbolu ([.class]``AbstractSymbol``).
Povinně přepisuje metody pro nastavení správné šířky a výšky a pro vykreslení symbolu.
Šířka musí být nastavena s ohledem na délku textových řetězců, které se mají vejít do symbolu.
Při použití proporcionálních písem se toto dá řešit pouze přibližně.

Symbol také poskytuje metody pro získávání a nastavování dále popsaných parametrů.
Pokud nebude některý z parametrů uveden (například proto, že zastupuje volitelnou vlastnost), nebude jeho hodnota vypsána nebo jinak zpracována.

Následuje přehled konkrétních symbolů a jejich vztahů k XML schématu.
V popisech parametrů vycházím z vlastností a hodnot definovaných ve specifikaci <<XSD1>>.

[[SYMBOL-SCHEMA]]
==== `schema`

[.class]``SymbolSchema`` znázorňuje kořenový element schématu.

Pro vykreslení není třeba uvádět žádné parametry.

.Symbol `schema`
image::symbols/schema.svg[]


[[SYMBOL-ELEMENT]]
==== `element`

[.class]``SymbolElement`` zobrazuje jméno informačních položek element, jejich typ a zařazení ke
jmennému prostoru a další vlastnosti dostupné z komponenty deklarace elementu (_Element declaration_).

* Parametr [.parameter]``name`` je textový řetězec, obsahující lokální část jmen informačních položek element,
    jež jsou validovány. Hodnotu poskytne deklarace elementu ve vlastnosti [.property]``name``.

* Parametr [.parameter]``namespace`` je řetězec se jmenným prostorem. Ten kvalifikuje informační položky element.
    Cílový jmenný prostor udává deklarace elementu ve vlastnosti [.property]``namespace``.

* Parametr [.parameter]``type`` je řetězec, který obsahuje jméno typu informačních položek element,
    pokud je tento typ pojmenovaný; nebo, pokud je typ anonymní a zároveň jednoduchý, obsahuje jméno základního typu,
    ze kterého je typ informačních položek element odvozen.
    Základem je vlastnost [.property]``name`` definice typu (_Type definition_).

* Parametr [.parameter]``cardinality`` je řetězec, který udává minimální a maximální počet výskytů informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
    Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto deklaraci elementu.
    Jejich názvy jsou [.property]``min occurs`` a [.property]``max occurs``.

* Parametr [.parameter]``nillable`` booleovského typu říká, zda mohou mít informační položky element
    prázdný obsah (hodnota ``true``), nebo ne (``false``).
    Hodnotu udává deklarace elementu ve vlastnosti [.property]``nillable``.

* Parametr [.parameter]``abstr`` je booleovského typu.
    Pokud je hodnota nastavena na ``true``, není tato deklarace sama o sobě použita k validování obsahu elementů.
    Hodnotu udává deklarace elementu ve vlastnosti [.property]``abstract``.

* Parametr [.parameter]``substitution`` je řetězec s názvem substituční skupiny, do které tato deklarace patří.
    Skutečnou hodnotu poskytuje deklarace elementu ve vlastnosti [.property]``substitution group affiliation``.

Do symbolu bude nutné vtěsnat hodně informací a přitom nezaplnit velkou plochu.
Proto budou poslední tři vlastnosti zobrazeny teprve při najetí myši místo vlastností [.property]``namespace`` a [.property]``type``.

.Symbol `element` (normální režim; při najetímyši)
image::symbols/element.svg[]


[[SYMBOL-ATTRIBUTE]]
==== `attribute`

[.class]``SymbolAttribute`` zobrazuje jméno informační položky atribut,
její typ a zařazení ke jmennému prostoru a další vlastnosti dostupné z komponent užití atributu (_Attribute use_)
a deklarace atributu (_Attribute declaration_).

* Parametr [.parameter]``name`` je textový řetězec, obsahující lokální část jména informační položky atribut,
    jež je validována. Hodnotu poskytne deklarace atributu ve vlastnosti [.property]``name``.

* Parametr [.parameter]``namespace`` je řetězec se jmenným prostorem.
    Ten kvalifikuje informační položky atribut. Cílový jmenný prostor udává deklarace atributu svou vlastností [.property]``namespace``.

* Parametr [.parameter]``type`` je řetězec, který obsahuje jméno typu informační položky atribut,
    pokud je tento typ pojmenovaný; nebo, pokud je typ anonymní, obsahuje jméno základního typu,
    ze kterého je typ informační položky atribut odvozen. Základem je vlastnost [.property]``name`` definice jednoduchého typu (_Simple type definition_).

* Parametr [.parameter]``required`` booleovského typu říká, zda musí být přítomna odpovídající
    informační položka atribut (hodnota ``true``), nebo zda je volitelná (``false``).
    Kromě vypsání odpovídajícího řetězce bude volitelný atribut ohraničen přerušovanou čárou,
    zatímco povinný atribut plnou. Parametr má stejnou hodnotu jako vlastnost užití atributu s názvem [.property]``required``.

* Parametr [.parameter]``constraint`` je textový řetězec, který specifikuje omezení pro hodnotu informační položky
    atribut (fixní nebo defaultní hodnota). Řetězec je vytvořen z vlastnosti [.property]``value constraint``.
    Tu poskytuje komponenta užití atributu nebo deklarace atributu.

Hodnoty posledních dvou parametrů se zobrazí teprve po najetí myši na symbol ``attribute``.

.Symbol `attribute` (volitelný atribut vnormálním režimu; a po najetí myši; povinný atribut v normálnímrežimu)
image::symbols/attribute_optional.svg[]


[[SYMBOL-ANY]]
==== `any`

[.class]``SymbolAny`` představuje divokou kartu (_Wildcard_) pro elementy.
Na jejím místě mohou být informační položky element s libovolným lokálním jménem, které ale musí vyhovět omezením kladeným na jejich jmenný prostor.

* Parametr [.parameter]``namespace`` je textový řetězec, představující omezení kladené na jmenný prostor informačních položek element.
    Řetězec je utvořen z vlastnosti [.property]``namespace constraint`` komponenty divoká karta.

* Parametr [.parameter]``processContents`` je celé číslo, které slouží k rozlišení způsobů zpracování informačních položek element.
    Hodnota vychází z vlastnosti [.property]``process contents`` divoké karty a závisí na ní vyobrazení symbolu. Parametr nabývá hodnot:

** [.constant]``3`` – způsob zpracování ``lax``. Pokud existuje unikátní deklarace položky, musí položka této deklaraci vyhovovat.
** [.constant]``2`` – odpovídá způsobu zpracování ``skip``. Nevzniká žádné omezení, položka musí být pouze dobře strukturované XML.
** [.constant]``1`` (a ostatní přípustné hodnoty) – způsob zpracování ``strict``.
    Informační položka musí mít přiřazen xsi:type, nebo musí být k dispozici její deklarace, oproti které je prováděna validace.

* Parametr [.parameter]``cardinality`` je řetězec, který udává minimální a maximální počet výskytů informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1),
    a řetězec nebude vykreslen. Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_)
    obsahující tuto divokou kartu. Jejich názvy jsou [.property]``min occurs`` a [.property]``max occurs``.


.Symbol `any` (způsob zpracování ``strict``; způsob zpracování ``skip``; způsob zpracování ``lax``)
image::symbols/any_strict.svg[]


[[SYMBOL-ANY-ATTRIBUTE]]
==== `anyAttribute`

[.class]``SymbolAnyAttribute`` představuje divokou kartu (_Wildcard_) pro atributy.
Na jejím místě mohou být informační položky atribut s libovolným lokálním jménem, které ale musí vyhovět omezením kladeným na jejich jmenný prostor.

* Parametr [.parameter]``namespace`` je textový řetězec, představující omezení kladené na jmenný prostor informačních položek atribut.
    Řetězec je utvořen z vlastnosti [.property]``namespace constraint`` komponenty divoká karta.

* Parametr [.parameter]``processContents`` je celé číslo, které slouží k rozlišení způsobů zpracování informačních položek atribut.
    Hodnota vychází z vlastnosti [.property]``process contents`` divoké karty a závisí na ní vyobrazení symbolu. Parametr nabývá hodnot:

** [.constant]``3`` – způsob zpracování ``lax``. Pokud existuje unikátní deklarace položky, musí položka této deklaraci odpovídat.
** [.constant]``2`` – odpovídá způsobu zpracování ``skip``. Nevzniká žádné omezení, položka musí být pouze dobře strukturované XML.
** [.constant]``1`` (a ostatní přípustné hodnoty) – způsob zpracování ``strict``.
    Informační položka musí mít přiřazen xsi:type, nebo musí být k dispozici její deklarace, oproti které je prováděna validace.


.Symbol `anyAttribute` (způsob zpracování ``strict``; způsob zpracování ``skip``; způsob zpracování ``lax``)
image::symbols/any_attribute_strict.svg[]


[[SYMBOL-ALL]]
==== `all`

[.class]``SymbolAll`` znázorňuje kompozitor `all` modelové skupiny (_Model group_).
Ten říká, že se děti informační položky element, definované v modelové skupině jako [.property]``particles``, mohou vyskytovat v libovolném pořadí.

* Parametr [.parameter]``cardinality`` je řetězec, který udává minimální a maximální počet výskytů dětí informační položky element.
Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto modelovou skupinu.
Jejich názvy jsou [.property]``min occurs`` a [.property]``max occurs``.


.Symbol `all`
image::symbols/all.svg[]


[[SYMBOL-CHOICE]]
==== `choice`

[.class]``SymbolChoice`` znázorňuje kompozitor `choice` modelové skupiny (_Model group_).
Pouze jedna z částic (_Particle_), definovaných v modelové skupině jako [.property]``particles``,
se může v XML dokumentu objevit jako dítě informační položky element.

* Parametr [.parameter]``cardinality`` je řetězec, který udává minimální a maximální počet výskytů dětí informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
    Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto modelovou skupinu.
    Jejich názvy jsou [.property]``min occurs`` a [.property]``max occurs``.


.Symbol `choice`
image::symbols/choice.svg[]


[[SYMBOL-SEQUENCE]]
==== `sequence`

[.class]``SymbolSequence`` znázorňuje kompozitor `sequence` modelové skupiny (_Model group_).
Každá z částic (_Particle_), definovaných v modelové skupině jako [.property]``particles``,
se může objevit v XML dokumentu jako dítě informační položky element, a to ve specifikovaném pořadí.

* Parametr [.parameter]``cardinality`` je řetězec, který udává minimální a maximální počet výskytů dětí informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
    Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto modelovou skupinu.
    Jejich názvy jsou [.property]``min occurs`` a [.property]``max occurs``.


.Symbol `sequence`
image::symbols/sequence.svg[]


[[SYMBOL-UNIQUE]]
==== `unique`

[.class]``SymbolUnique`` znázorňuje část definice identitního omezení (_Identity-constraint definition_),
konkrétně jméno a jmenný prostor kategorie ``unique``.
Ta zajišťuje jedinečnost hodnot v rámci obsahu vymezeného selektorem <<SYMBOL-SELECTOR>>,
které jsou výsledkem vyhodnocení XPath výrazů uvedených v polích <<SYMBOL-FIELD>>.

* Parametr [.parameter]``name`` je textový řetězec, obsahující jméno definice identitního omezení.
    Hodnotu poskytne tato definice ve vlastnosti [.property]``name``.
* Parametr [.parameter]``namespace`` je řetězec se jmenným prostorem.
    Ten kvalifikuje definici identitního omezení. Jmenný prostor udává definice svou vlastností [.property]``namespace``.
    Dvojice jméno a jmenný prostor identifikuje definici identitního omezení, a proto musí být v rámci XML schématu unikátní.


.Symbol `unique`
image::symbols/unique.svg[]


[[SYMBOL-KEY]]
==== `key`

[.class]``SymbolKey`` znázorňuje část definice identitního omezení (_Identity-constraint definition_),
konkrétně jméno a jmenný prostor kategorie ``key``.
Ta zajišťuje jedinečnost a přítomnost hodnot v rámci obsahu vymezeného selektorem <<SYMBOL-SELECTOR>>,
které jsou výsledkem vyhodnocení XPath výrazů uvedených v polích <<SYMBOL-FIELD>>.

* Parametr [.parameter]``name`` je textový řetězec, obsahující jméno definice identitního omezení.
    Hodnotu poskytne tato definice ve vlastnosti [.property]``name``.
* Parametr [.parameter]``namespace`` je řetězec se jmenným prostorem.
    Ten kvalifikuje definici identitního omezení. Jmenný prostor udává definice svou vlastností [.property]``namespace``.
    Dvojice jméno a jmenný prostor identifikuje definici identitního omezení, a proto musí být v rámci XML schématu unikátní.


.Symbol `key`
image::symbols/key.svg[]


[[SYMBOL-KEYREF]]
==== `keyref`

[.class]``SymbolKeyref`` znázorňuje část definice identitního omezení (_Identity-constraint definition_),
konkrétně jméno a jmenný prostor kategorie ``keyref``.
Ta zajišťuje, že hodnoty, které jsou výsledkem vyhodnocení XPath výrazů uvedených v polích <<SYMBOL-FIELD>>,
budou odpovídat hodnotám, jež specifikuje vlastnost [.property]``referenced key`` definice identitního omezení.
Tato podmínka se vyhodnocuje v rámci obsahu určeného selektorem <<SYMBOL-SELECTOR>>.

* Parametr [.parameter]``name`` je textový řetězec, obsahující jméno definice identitního omezení.
    Hodnotu poskytne tato definice ve vlastnosti [.property]``name``.
* Parametr [.parameter]``namespace`` je řetězec se jmenným prostorem. Ten kvalifikuje definici identitního omezení.
    Jmenný prostor udává definice svou vlastností [.property]``namespace``. Dvojice jméno a jmenný prostor identifikuje definici identitního omezení, a proto musí být v rámci XML schématu unikátní.
* Parametr [.parameter]``refer`` je řetězec, který slouží jako odkaz na jinou definici identitního omezení
    kategorie `key` nebo ``unique``. Hodnotu poskytne tato definice ve vlastnosti [.property]``referenced key``.


.Symbol `keyref`
image::symbols/keyref.svg[]


[[SYMBOL-SELECTOR]]
==== `selector`

[.class]``SymbolSelector`` slouží ke zobrazení vlastnosti [.property]``selector`` definice identitního omezení (_Identity-constraint definition_).

* Parametr [.parameter]``xpath`` je textový řetězec. Specifikuje omezený XPath výraz, relativní k instanci deklarovaného elementu.
    Výraz musí identifikovat množinu uzlů – podřízených elementů, na které se vztahuje omezení.
    Hodnota parametru se získá z vlastnosti [.property]``selector`` definice identitního omezení.


.Symbol `selector`
image::symbols/selector.svg[]


[[SYMBOL-FIELD]]
==== `field`

[.class]``SymbolField`` slouží ke zobrazení jednoho prvku ze seznamu – vlastnosti [.property]``fields``
definice identitního omezení (_Identity-constraint definition_).

* Parametr [.parameter]``xpath`` je textový řetězec. Specifikuje omezený XPath výraz, relativní ke každému elementu,
    který je vybrán selektorem <<SYMBOL-SELECTOR>>. Výraz musí identifikovat konkrétní uzel (element nebo atribut),
    jehož obsah nebo hodnota musí být jednoduchého typu a je použita v omezení. Hodnota parametru se získá z
    vlastnosti [.property]``fields`` definice identitního omezení.


.Symbol `field`
image::symbols/field.svg[]


[[SYMBOL-LOOP]]
==== smyčka

[.class]``SymbolLoop`` je pomocný symbol, který nepatří do XML schématu. Vykreslí se, pokud by mělo dojít k zacyklení.
Deklarace elementu totiž může nepřímo obsahovat samu sebe, a to za splnění těchto podmínek:

. Deklarace elementu je komplexního typu.
. Komplexní typ (1) obsahuje částici (_Particle_).
. Termínem ([.property]``term``) částice (2) je modelová skupina (_ModelGroup_) – vždy složená z dalších částic.
. Termínem alespoň jedné z částic (3) je deklarace elementu totožná s deklarací uvedenou v bodě (1);
    nebo je termínem alespoň jedné z částic (3) modelová skupina a v tom případě se postupuje rekurzivně od bodu (3),
    dokud nebude nalezena deklarace elementu totožná s deklarací uvedenou v bodě (1).

Nemá parametry.

.Symbol smyčky
image::symbols/_loop.svg[]


[[INTERACTIVITY]]
=== Interaktivita modelu

Jedním z požadavků kladených na grafický model je jeho interaktivita.
SVG se dá rozpohybovat pomocí ECMAScriptu (JavaScriptu). Jednoduše půjde zajistit změnu zobrazovaných informací při najetí kurzoru myši na symboly <<SYMBOL-ELEMENT>> a <<SYMBOL-ATTRIBUTE>>.
Složitější je implementovat rozbalování a skrývání podstromů jednotlivých symbolů.
Aby to bylo možné, musí SVG dokument znát umístění symbolů v rámci jejich stromu.
K vysvětlení použiji následující příklad:

[source, xml]
----
<g id='_1_1_1_2' class='box' transform='translate(395,121)'>
    <rect class='shadow' x='3' y='3' width='117' height='46'/>
    <rect class='boxelement' x='0' y='0' width='117' height='46'
        onmouseover='makeVisible("_1_1_1_2")' onmouseout='makeHidden("_1_1_1_2")'/>
    <text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
    <text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
    <text class='strong' x='5' y='27'>address</text>
    <text class='visible' x='5' y='41'>type: AddressType</text>
    <line class='connection' id='p_1_1_1_2' x1='-35' y1='-48' x2='-35' y2='-40'/>
    <path class='connection' d='M-35,-40 Q-35,15 0,23'/>
    <use x='116' y='17' xlink:href='#plus' id='s_1_1_1_2' onclick='show("_1_1_1_2")'/>
</g>
----

Jedná se o XML reprezentaci symbolu ``address``.
Ten se skládá z několika SVG elementů a je zobrazen jako <<ADDRESS-SYMBOL>>.

* Symbol je tvořen dvěma obdélníky. První je mírně posunutý a tvoří lehký stín.
    Druhý z nich tvoří hlavní box a je citlivý na najetí myši.
* Dále symbol obsahuje čtyři textové položky. První dvě s obsahem „nillable: 0"` a „abstract: 0"`
    jsou teď skryty. Řetězce „address"` a „type: AddressType"` jsou naopak viditelné.
* Následuje úsečka a na ní navazující křivka, která zleva připojuje symbol ke svému rodiči.
* Nakonec je použit předem definovaný symbol „plus"`, což je malý čtverec se znakem plus.
    Je citlivý na kliknutí myši.

Navíc, aby se se symbolem dalo pracovat jako s jedním celkem,
jsou všechny popsané položky obaleny jako skupina  elementem `<g>`
Ten dále umožňuje transformaci pozice symbolu a jeho jednoznačnou identifikaci v rámci stromu.

[[ADDRESS-SYMBOL]]
.Symbol elementu address (v normálním režimu; při najetímyši)
image::images/address.svg[]

Pro změnu zobrazovaných položek při najetí myši stačí, aby měl každý symbol jednoznačný identifikátor.
Ten je předáván ECMAScriptovým metodám [.method]``makeVisible``([.parameter]``id``)
a [.method]``makeHidden``([.parameter]``id``) při najetí kurzoru myši na hlavní box symbolu, respektive při jeho sjetí z boxu.
Změna spočívá v tom, že položky, které měly nastavenou třídu ([.property]``class``) na hidden, budou nyní viditelné.
Jedná se o textové řetězce „nillable: 0"` a „abstract: 0"`. Naopak položky ve třídě visible budou dočasně skryty.
Sem patří pouze řetězec „type: AddressType"`. Viz obrázek <<ADDRESS-SYMBOL>>.

Zde použitý identifikátor symbolu je poměrně složitý, jedná se o řetězec ``_1_1_1_2``.
Jeho použití je však opodstatněné.
Už jsem napsal, že pro práci s podstromy symbolů, musí být v SVG dokumentu patrné, do které části stromu symbol spadá.
To lze jednoznačně určit pomocí takovýchto identifikátorů, uvedením cesty od kořene stromu až ke konkrétnímu symbolu.
Podívejte se na obrázek <<INTERACTIVITY_MODEL>>.

[[INTERACTIVITY_MODEL]]
.Model s kódy symbolů
image::images/model_interactivity.png[]

Kořenový symbol má identifikátor ``_1``.
Potržítko je nutné kvůli přípustným hodnotám attributu ``id``, je tedy zvoleno i jako oddělovač.
Kořenový symbol má dále dvě děti.
Jejich identifikátory jsou tvořeny identifikátorem rodiče a přidanou vlastní částí, která udává jejich pozici.
Dostáváme řetězce `_1_1` a ``_1_2``.
Analogicky symbol `_1_1` má dítě ``_1_1_1``.
Symbol s identifikátorem `_1_1_1` má dvě děti a druhé z nich (``_1_1_1_2``) je popisovaný prvek, symbol elementu ``address``.

Při kliknutí na symbol minus za boxem `address` se zavolá ECMAScriptová metoda [.method]``show``([.parameter]``"_1_1_1_2"``).
Ta provede následující:

* Změní tu symbol minus na plus, přepsáním atributu `xlink:href` elementu `<use>`
    tak, aby odkazoval na předem definovaný grafický objekt ``plus``.
* Schová celý podstrom symbolů připojený zprava k boxu. Patří do něj všechny symboly,
    jejichž identifikátor začíná také na ``_1_1_1_2``. U elementů `<g>`
    obalujících objekty, z nichž se symbol skládá, se nastaví atribut `visibility` na hodnotu [.property]``hidden``.
* Vzniklý prostor se zaplní vedlejšími větvemi. Ty se posunou směrem nahoru, přenastavením hodnoty atributu `transform`
    u seskupujícícho elementu `<g>`.
    Výpočet vzdálenosti, o kterou se mohou symboly posunout, je nutné provést pouze pro jeden symbol, pro ostatní je vzdálenost stejná.
    Zde poslouží také systém identifikace.
    Navíc je třeba zkrátit úsečku propojující rodičovské symboly s posouvanou větví.

Výsledek je možné vidět na obrázku <<INTERACTIVITY-MODEL-2>>.
Pokud teď klikneme na symbol plus, zavolá se opět metoda [.method]``show``([.parameter]``"_1_1_1_2"``).
Ta teď ale bude pracovat přesně naopak, než bylo popsáno.

Kromě výše uvedené funkčnosti budou poskytnuta tlačítka pro zobrazení a skrytí všech symbolů, až na kořenový.
Časem přibudou i škálovací tlačítka _zoom in_ a _zoom out_, zatím se lze obejít bez nich a využít funkce prohlížeče.

[[INTERACTIVITY-MODEL-2]]
.Model po skrytí podstromu elementu address
image::images/model_interactivity2.png[]


=== Výsledná SVG reprezentace schématu

Když splním všechny podmínky, získám z aplikace výstup ve formátu SVG, 
jehož grafickou reprezentaci si můžete prohlédnout na obrázku <<MY-MODEL>>.
V příloze <<EXAMPLES>> je pro přehlednost znovu uvedeno jak vstupní XML schéma, 
tak i SVG výstup v XML i grafické reprezentaci.

[float]
[[STYLE]]
==== Styl

Výsledný diagram se ale dá ještě dodatečně upravovat, jeho vzhled je totiž nastaven v CSS stylu.
Aplikace dokáže styl generovat jako součást SVG dokumentu nebo zvlášť, nebo pouze připojit existující externí styl.
Kaskádové styly využívají selektory pro výběr určitých elementů, kterým pak nastaví vzhled.
Výběr může být určen názvem tagu, pokud však chceme jednotně upravit určité logické celky, lze využít jejich zařazení do tříd ([.property]``class``). V SVG výstupu vznikly tyto třídy:

* [.property]``strong`` pro důležité nápisy jako jsou názvy elementů a atributů. Písmo je větší a tučné.
* [.property]``small`` pro text, jenž je součástí grafiky, psaný menším písmem.
* [.property]``big`` pro text, jenž je součástí grafiky, psaný větším písmem.
* [.property]``button`` pro tlačítka; podstatou je, že má v parametru [.property]``pointer-events``
    zapnutou citlivost na určité události, především nám jde o kliknutí myši.
* [.property]``shadow`` je třída pro stín zobrazovaný za některými boxy.
* [.property]``connection`` zahrnuje úsečky a křivky propojující jednotlivé grafické symboly (boxy).
* [.property]``empty`` pro tvary obtažené, bez výplně.
* [.property]``filled`` pro tvary vyplněné, bez obtažení.
* [.property]``boxelement`` pro box symbolu <<SYMBOL-ELEMENT>>.
* [.property]``boxattribute1`` pro box symbolu <<SYMBOL-ATTRIBUTE>>, pokud je použití atributu povinné.
* [.property]``boxattribute2`` pro box symbolu <<3>>, pokud je použití atributu volitelné.
* [.property]``boxany`` pro box symbolu <<SYMBOL-ANY>>.
* [.property]``boxanyattribute`` pro box symbolu <<SYMBOL-ANY-ATTRIBUTE>>.
* [.property]``boxschema`` pro box symbolu <<SYMBOL-SCHEMA>>.
* [.property]``boxcompositor`` pro boxy symbolů <<SYMBOL-ALL>>, <<SYMBOL-CHOICE>>, <<SYMBOL-SEQUENCE>>.
* [.property]``boxloop`` pro box symbolu <<SYMBOL-LOOP>>.
* [.property]``boxidc`` pro boxy symbolů <<SYMBOL-UNIQUE>>, <<SYMBOL-KEY>>, <<SYMBOL-KEYREF>>.
* [.property]``boxselector`` pro box symbolu <<SYMBOL-SELECTOR>>.
* [.property]``boxfield`` pro box symbolu <<SYMBOL-FIELD>>.
* [.property]``lax`` slouží k dalšímu nastavení vzhledu u boxů <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    pokud je u nich způsob zpracování nastaven na _lax_.
* [.property]``skip`` slouží k dalšímu nastavení vzhledu u boxů <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    pokud je u nich způsob zpracování nastaven na _skip_.
* [.property]``strict`` slouží k dalšímu nastavení vzhledu u boxů <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    pokud je u nich způsob zpracování nastaven na _strict_.


[float]
==== Původní styl generovaný aplikací

[source, css]
----
svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}
----

[[MY-MODEL]]
.Výstup aplikace pro výše uvedený příklad XML schématu
image::images/model_my.svg[]


[[XSD-PROCESSING]]
== Zpracování XML schématu

V této kapitole ukážu způsob procházení mezi komponentami schématu a vytvořím tak koncept jádra aplikace.
Jednotlivé oddíly se věnují zpracování konkrétních komponent a vedle algoritmu zpracování obsahují také popis převzatý ze specifikace <<XSD1>>.
Odkaz na konkrétní část specifikace uvádím u každého oddílu v poznámce pod čarou.

Jako základní knihovnu, na které postavím aplikaci, jsem po předchozím uvážení zvolil open-source parser Xerces.
Ten poskytuje plnou podporu XML schémat podle <<XSD0>>, <<XSD1>> a <<XSD2>>, až na několik omezení,
které v naprosté většině případů nebudou tvořit překážku.
    footnote:[The Apache XML Project: Xerces2 Java Parser Readme. XML Schema. http://xerces.apache.org/xerces2-j/xml-schema.html]
Implementace Xerces tak bude pracovat v souladu se specifikací W3C a bude užívat její termíny.

Obrázek <<DIAGRAM_KOMPONENT>> nám umožní udělat si snadno představu o vazbách a základních vlastnostech jednotlivých
komponent XML schématu, jež jsou definovány v třetí části specifikace.
    footnote:[Schema Component Details. http://www.w3.org/TR/xmlschema-1/#components]

[[PROCESS-MODEL]]
=== Zpracování samotného schématu
footnote:[http://www.w3.org/TR/xmlschema-1/#Schemas]

Schéma (_Schema_, v Xercesu třída [.class]``XSModel``) slouží na abstraktní úrovni jako kontejner pro jednotlivé komponenty.
Jedná se o komponenty globální, tedy pojmenované a anotace.

Metoda [.method]``processModel``([.class]``XSModel``[.parameter]``model``) bude mít na starost zpracování schématu.

. Vytvoří se symbol <<SYMBOL-SCHEMA>> a bude vložen jako kořen do stromové struktury symbolů.
. Bude volána pomocná metoda [.method]``processElementDeclarations``([.parameter]``elementDeclarations``)
    [<<PROCESS-ELEMENT-DECLARATIONS>>], parametrem jsou všechny globálně deklarované elementy.

Ostatní vlastnosti schématu ([.property]``attribute declarations``, [.property]``model group definitions``,
    [.property]``attribute group definitions``, [.property]``type definitions``, [.property]``notation declarations``,
    [.property]``annotations``) pro tvorbu logického modelu grafické reprezentace takto přímo nevyužijeme;
    Xerces nám některé z nich poskytne později skrze reference jako globálně definované typy, atributy, elementy a jejich skupiny.
Při vykreslování tedy vůbec nebudeme muset pracovat s komponentami definice skupiny atributů
    (_Attribute group definition_), definice modelové skupiny (_Model group definition_) a deklarace notace
    (_Notation declaration_), které jsou dostupné pouze ze schématu, a nebudeme potřebovat ani anotace (_Annotation_).

[[PROCESS-ELEMENT-DECLARATIONS]]
=== Zpracování kolekce deklarací elementů

Kolekce deklarací elementů (v Xercesu obalené obecnou třídou [.class]``XSNamedMap``).

Metoda [.method]``processElementDeclarations``([.class]``XSNamedMap``[.parameter]``map``) provádí zpracování globálních
deklarací elementů.Metoda obsahuje cyklus.

. Prochází se kolekcí deklarací elementů:

.. Pro každý prvek kolekce se volá [.method]``processElementDeclaration``([.parameter]``elementDeclaration``, ``null``)
    [<<PROCESS-ELEMENT-DECLARATION>>]. První parametr je konkrétní deklarace elementu (_Element declaration_), druhý je řetězec vyjadřující kardinalitu elementu. V případě globální deklarace má vždy hodnotu ``null``.

[[PROCESS-ELEMENT-DECLARATION]]
=== Zpracování deklarace elementu
footnote:[http://www.w3.org/TR/xmlschema-1/#cElement_Declarations]

Deklarace elementu (_Element declaration_, v Xercesu třída [.class]``XSElementDeclaration``) umožňuje:

* lokální validaci hodnot informační položky element za použití definice typu;
* specifikování defaultních nebo fixních hodnot pro informační položku element;
* zajištění jedinečnosti hodnot a nastavení referenčních omezení v rámci hodnot příbuzných elementů a atributů;
* kontrolování vzájemné nahraditelnosti elementů pomocí mechanismu substitučních skupin (_element substitution groups_).

Metoda [.method]``processElementDeclaration``([.class]``XSElementDeclaration``[.parameter]``elementDeclaration``,
    [.class]``String``[.parameter]``cardinality``) zpracuje deklaraci elementu:

. Dojde k vytvoření symbolu <<SYMBOL-ELEMENT>> a jeho připojení na odpovídající místo stromové struktury.
    U symbolu je třeba nastavit základní informace, poskytované přímo objektem [.parameter]``elementDeclaration``,
    ale také některé dodatečné informace, například řetězec s typem elementu, získaný voláním pomocné metody
    [.method]``getTypeString``([.parameter]``typeDefinition``) [<<PROCESS-SIMPLE-TYPE>>], a řetězec uvádějící
    minimální a maximální počet výskytů, získaný z parametru [.parameter]``cardinality``.
    Popis jednotlivých položek naleznete u grafického návrhu symbolu ``element``.

. Zjišťuje se, zda se stejná deklarace nevyskytuje mezi předky této deklarace.
    Došlo by k zacyklení a vykreslování modelu by se nikdy řádně neukončilo. Kontrolu provádí metoda
    [.method]``processLoop``([.class]``XSElementDeclaration``[.parameter]``elementDeclaration``),
    která má za úkol v případě objevení cyklu připojit symbol <<SYMBOL-LOOP>> a zastavit zpracování následníků.

. Pokud má element komplexní datový typ, proběhne na tomto místě zpracování jeho definice.
    To obstarává metoda [.method]``processComplexTypeDefinition``([.parameter]``complexTypeDefinition``) [<<PROCESS-COMPLEX-TYPE>>]

. Bude volána pomocná metoda [.method]``processIdentityConstraints``([.parameter]``IdentityConstraints``) 
    [<<PROCESS-IDENTITY-CONSTRAINTS>>], parametrem jsou všechna identitní omezení definovaná v rámci této deklarace.


[[PROCESS-ATTRIBUTE-USES]]
=== Zpracování kolekce užití atributů

Kolekce užití atributů (v Xercesu obalené obecnou třídou [.class]``XSObjectList``).

Metoda [.method]``processAttributeUses``([.class]``XSObjectList``[.parameter]``attributeUses``) provádí zpracování kolekce užití atributů.
Metoda obsahuje cyklus.

. Prochází se kolekcí:

.. Pro každý prvek kolekce se volá metoda [.method]``processAttributeUse``([.parameter]``attributeUse``) 
    [<<PROCESS-ATTRIBUTE-USE>>]. Parametr je konkrétní užití atributu (_Attribute use_).

[[PROCESS-ATTRIBUTE-USE]]
=== Zpracování užití atributu{blank}footnote:[http://www.w3.org/TR/xmlschema-1/#cAttributeUse]

Užití atributu (_Attribute use_, v Xercesu třída [.class]``XSAttributeUse``) je pomocná komponenta, 
která kontroluje výskyt a defaultní chování deklarace atributu.
Pro deklaraci atributu plní v rámci komplexního typu podobnou úlohu jako částice (_Particle_) pro deklaraci elementu.

Metoda [.method]``processAttributeUse``([.class]``XSAttributeUse``[.parameter]``attributeUse``) 
slouží ke zpracování užití atributu a zároveň i samotné deklarace atributu:

. Na tomto místě proběhne zpracování deklarace atributu [<<PROCESS-ATTRIBUTE-DECLARATION>>].


[[PROCESS-ATTRIBUTE-DECLARATION]]
=== Zpracování deklarace atributu  
footnote:[http://www.w3.org/TR/xmlschema-1/#cAttribute_Declarations]

Deklarace atributu (_Attribute declaration_, v Xercesu třída [.class]``XSAttributeDeclaration``) umožňuje:

* lokální validaci hodnot informační položky atribut za použití definice jednoduchého typu;
* specifikování defaultních nebo fixních hodnot pro informační položku atribut.

Pro jednoduchost je deklarace atributu zpracována uvnitř metody 
[.method]``processAttributeUse``([.class]``XSAttributeUse``[.parameter]``attributeUse``) [<<PROCESS-ATTRIBUTE-USE>>].

. Dojde k vytvoření symbolu <<SYMBOL-ATTRIBUTE>> a jeho připojení do stromové struktury. 
    Předtím se musí zjistit základní informace, poskytované přímo deklarací atributu, 
    a také dodatečná informace o typu atributu, získaná voláním pomocné metody
    [.method]``getTypeString``([.parameter]``typeDefinition``) [<<PROCESS-SIMPLE-TYPE>>].
    Popis jednotlivých položek naleznete u grafického návrhu symbolu ``attribute``.


[[PROCESS-WILDCARD]]
=== Zpracování divoké karty
footnote:[http://www.w3.org/TR/xmlschema-1/#Wildcards]

Divoká karta (_Wildcard_, v Xercesu třída [.class]``XSWildcard``)
umožňuje validaci informačních položek element a atribut, závisející na jmenném prostoru, ale nezávislou na lokálním jméně.

Metoda [.method]``processElementWildcard``([.class]``XSWildcard``[.parameter]``wildcard``, 
[.class]``String``[.parameter]``cardinality``) slouží ke zpracování divoké karty pro element:

. Vytvoří symbol <<SYMBOL-ANY>> a připojí ho na odpovídající pozici ve stromové struktuře. 
    Pomocná metoda [.method]``getNamespaceString``([.class]``XSWildcard``[.parameter]``wildcard``) 
    umožní sestavit řetězec, uvádějící omezení jmenných prostorů, 
    parametr `cardinality` dodá informaci o minimálním a maximálním počtu výskytů.

Metoda [.method]``processAttributeWildcard``([.class]``XSWildcard``[.parameter]``wildcard``) 
slouží ke zpracování divoké karty pro atribut:

. Vytvoří symbol <<SYMBOL-ANY-ATTRIBUTE>> a připojí ho na odpovídající pozici ve stromové struktuře. 
    Pomocná metoda [.method]``getNamespaceString``([.class]``XSWildcard``[.parameter]``wildcard``) 
    umožní sestavit řetězec, uvádějící omezení jmenných prostorů.


[[PROCESS-SIMPLE-TYPE]]
=== Zpracování definice jednoduchého typu
footnote:[http://www.w3.org/TR/xmlschema-1/#Simple_Type_Definitions]

Definice jednoduchého typu (_Simple type definition_, v Xercesu třída [.class]``XSSimpleTypeDefinition``) 
umožňuje omezení znakových informačních položek – dětí informačních položek element a atribut.

Pomocná metoda [.method]``getTypeString``([.class]``XSTypeDefinition``[.parameter]``typeDefinition``) 
je volána při zpracování deklarací elementů a atributů.
U jednoduchého typu je pouze třeba zjistit název, nebo název základního typu a ten zobrazit jako typ elementu / atributu.

. Pokud je typ pojmenovaný (může být i komplexní), vrátí jméno typu.
. Pokud je typ anonymní a zároveň je jednoduchý, vrátí jméno základního typu, ze kterého je tento typ odvozen.
. Jinak vrátí ``null``.


[[PROCESS-COMPLEX-TYPE]]
=== Zpracování definice komplexního typu
footnote:[http://www.w3.org/TR/xmlschema-1/#Complex_Type_Definitions]

Definice komplexního typu (_Complex type definition_, v Xercesu třída [.class]``XSComplexTypeDefinition``) umožňuje:

* omezení informačních položek element, přidáním deklarací atributů, určujících výskyt a obsah atributů;
* omezení informačních položek element tak, že musí mít buď prázdný obsah, nebo musí vyhovět specifikovanému 
    obsahu smíšenému, nebo tvořenému pouze elementy; nebo omezuje znakové informační položky tak, 
    aby vyhověly specifikované definici jednoduchého typu;
* využití mechanismu hierarchie definic typů (_Type definition hierarchy_) 
    k odvození komplexního typu z jiného jednoduchého či komplexního typu;
* specifikování příspěvků k post-schema-validation infosetu elementů;
* omezení možnosti odvozovat další typy z tohoto komplexního typu;
* kontrolovat nahrazování elementů odvozeného typu za elementy deklarované v modelu obsahu, 
    který je tohoto komplexního typu.

Definice komplexního typu je zpracována metodou [.method]``processComplexTypeDefinition``
    ([.class]``XSComplexTypeDefinition``[.parameter]``complexTypeDefinition``).

. Zjistí se, zda definice obsahuje částici (_Particle_), pokud ano, volá se metoda 
    [.method]``processParticle``([.parameter]``particle``) [<<PROCESS-PARTICLE>>]. 
    Parametrem je částice získaná z definice komplexního typu.
. Volá se pomocná metoda [.method]``processAttributeUses``([.parameter]``attributeUses``) [<<PROCESS-ATTRIBUTE-USES>>], 
    parametrem je kolekce užití atributů.
. Pokud je definována divoká karta (_Wildcard_) pro atributy, zavolá se metoda [.method]``processAttributeWildcard``
    ([.parameter]``wildcard``) [<<PROCESS-WILDCARD>>]. Parametrem je divoká karta získaná z definice komplexního typu.


[[PROCESS-IDENTITY-CONSTRAINTS]]
=== Zpracování kolekce identitních omezení

Kolekce deklarací identitních omezení (v Xercesu obalené obecnou třídou [.class]``XSNamedMap``).

Metoda [.method]``processIdentityConstraints``([.class]``XSNamedMap``[.parameter]``identityConstraints``) 
provádí zpracování deklarací identitních omezení. Metoda obsahuje cyklus.

. Prochází se kolekcí:

.. Pro každý prvek kolekce se volá metoda [.method]``processIdentityConstraintDefinition``
    ([.parameter]``identityConstraintDefinition``) [<<PROCESS-IDENTITY-CONSTRAINT>>]. 
    Parametrem je konkrétní definice identitního omezení (_Identity-constraint definition_).


[[PROCESS-IDENTITY-CONSTRAINT]]
=== Zpracování definice identitního omezení
footnote:[http://www.w3.org/TR/xmlschema-1/#cIdentity-constraint_Definitions]

Definice identitního omezení (_Identity-constraint definition_, v Xercesu třída [.class]``XSIDCDefinition``) 
zajištuje jedinečnost a referenční omezení v rámci hodnot množiny elementů a atributů.

Metoda [.method]``processIdentityConstraintDefinition``
([.class]``XSIDCDefinition``[.parameter]``identityConstraintDefinition``) 
má na starost zpracování definice identitního omezení.

. Zjistí se kategorie této definice:

.. Pokud jde o unikátní klíč (``unique``), vytvoří se symbol <<SYMBOL-UNIQUE>>.
.. Pokud jde o primární klíč (``key``), vytvoří se symbol <<SYMBOL-KEY>>.
.. Pokud jde o cizí klíč (``keyref``), vytvoří se symbol <<SYMBOL-KEYREF>>.
. Vytvoří se symbol <<SYMBOL-SELECTOR>>.
. Prochází se kolekcí polí (``field``):

.. Pro každý prvek kolekce se vytvoří symbol <<SYMBOL-FIELD>>.

Potřebné informace pro vykreslení všech symbolů poskytne přímo objekt [.parameter]``identityConstraintDefinition``.
Jejich přehled naleznete u návrhu jednotlivých symbolů.
Každý ze symbolů je připojen na odpovídající místo stromové struktury.

[[PROCESS-PARTICLES]]
=== Zpracování kolekce částic

Kolekce částic (v Xercesu obalené obecnou třídou [.class]``XSObjectList``).

Metoda [.method]``processParticles``([.class]``XSObjectList``[.parameter]``particles``) provádí zpracování kolekce částic.
Metoda obsahuje cyklus:

. Prochází se kolekcí částic:

.. Pro každý prvek kolekce se volá [.method]``processParticle``([.parameter]``particle``) [<<PROCESS-PARTICLE>>].
    Parametrem je konkrétní částice (_Particle_).


[[PROCESS-PARTICLE]]
=== Zpracování částice
footnote:[http://www.w3.org/TR/xmlschema-1/#cParticles]

Částice (_Particle_, v Xercesu třída [.class]``XSParticle``) přidává dodatečné informace o minimálním a 
maximálním počtu výskytů k definici modelu obsahu.

Metoda [.method]``processParticle``([.class]``XSParticle``[.parameter]``particle``) zpracuje částici následujícím způsobem:

. Pomocná metoda [.method]``getCardinalityString``([.class]``XSParticle``[.parameter]``particle``)
    sestaví řetězec ``cardinality``, obsahující informaci o minimálním ([.property]``minOccurs``)
    a maximálním ([.property]``maxOccurs``) počtu výskytů částicí obaleného termínu ([.property]``term``).
. Zavolá pomocnou metodu [.method]``processTerm``([.parameter]``term``, [.parameter]``cardinality``) [<<PROCESS-TERM>>],
    která termín zpracuje, a pošle jí i řetězec ``cardinality``.


[[PROCESS-TERM]]
=== Zpracování termínu

Termín (_Term_, v Xercesu třída [.class]``XSTerm``) je obecná vlastnost zastupující modelovou skupinu,
deklaraci elementu, nebo divokou kartu pro elementy.

Metoda [.method]``processTerm``([.class]``XSTerm``[.parameter]``term``, [.class]``String``[.parameter]``cardinality``)
provádí tento algoritmus:

. Zjistí se typ termínu:

.. Pokud se jedná o modelovou skupinu (_Model group_), volá se metoda
    [.method]``processModelGroup``([.parameter]``modelGroup``, [.parameter]``cardinality``) [<<_process_model_group>>].
    Prvním parametrem je termín – modelová skupina, druhým parametrem se předává dál informace o kardinalitě.

.. Pokud jde o deklaraci elementu (_Element declaration_), volá se [.method]``processElementDeclaration``
    ([.parameter]``elementDeclaration``, [.parameter]``cardinality``) [<<PROCESS-ELEMENT-DECLARATION>>].
    Prvním parametrem je termín – deklarace elementu, druhým parametrem se předává dál informace o kardinalitě.

.. Pokud jde o divokou kartu (_Wildcard_) pro elementy, volá se metoda [.method]``processElementWildcard``
    ([.parameter]``wildcard``, [.parameter]``cardinality``) [<<PROCESS-WILDCARD>>].
    Prvním parametrem je termín – divoká karta, druhým parametrem se předává dál informace o kardinalitě.


[[_process_model_group]]
=== Zpracování modelové skupiny
{blank}footnote:[http://www.w3.org/TR/xmlschema-1/#Model_Groups]

Modelová skupina (_Model group_, v Xercesu třída [.class]``XSModelGroup``).
Pokud není definováno, že mají být děti informační položky element prázdné,
nebo že mají vyhovovat určité definici jednoduchého typu, může být obsah posloupnosti dětí informační položky element
specifikován detailněji pomocí modelové skupiny.
Díky tomu, že součástí částice může být modelová skupina a modelová skupina obsahuje částice,
může modelová skupina nepřímo obsahovat jiné modelové skupiny.

Metoda [.method]``processModelGroup``([.class]``XSModelGroup``[.parameter]``modelGroup``,
[.class]``String``[.parameter]``cardinality``) provádí algoritmus:

. Zjistí se typ kompozitoru ([.property]``compositor``):

.. Pokud se jedná o kompozitor ``all``, vytvoří se symbol <<SYMBOL-ALL>>.
.. Pokud jde o kompozitor ``choice``, vytvoří se symbol <<SYMBOL-CHOICE>>.
.. Jinak jde o kompozitor ``sequence``, vytvoří se symbol <<SYMBOL-SEQUENCE>>.

. Zavolá se pomocná metoda [.method]``processParticles``([.parameter]``particles``)
    [<<PROCESS-PARTICLES>>], parametrem je kolekce částic, obsažených uvnitř modelové skupiny.

U každého ze symbolů bude vypsán řetězec `cardinality` s informací o minimálním a maximálním počtu výskytů.
Vytvořený symbol je vždy připojen na odpovídající pozici stromové struktury.

[float]
==== Konečné uložení připravené struktury do SVG

Poté, co se dokončí procházení abstraktního datového modelu XML schématu a připravené symboly utvoří stromovou
strukturu, dojde k uložení stromu do SVG souboru.
Nejprve se vypíše jakási hlavička s XML deklarací, doctypem, titulkem, přidá se skript, předem definované symboly a
popřípadě styl; následují jednotlivé symboly komponent.
Přesný průběh vypadá tak, že se vezme kořenový symbol, nastaví se u něj správné rozměry a umístění na pomyslném plátně
a uloží se, totéž se pak opakuje se všemi dětmi a jejich potomky, až se dojde k listům stromu.
Tím jsou symboly vloženy do souboru a následuje už jen koncový tag `<svg>`

== Závěr

Cílem práce bylo navrhnout a implementovat aplikaci pro převod XML schématu do interaktivního diagramu ve formátu SVG.
Bylo proto třeba nastudovat principy, na kterých staví specifikace W3C XML schématu.
Ta silně odděluje abstraktní datový model od XML reprezentace.
Právě abstraktní datový model, jeho komponenty a vlastnosti komponent poskytují přímý a jednoduchý přístup k důležitým údajům.
Abych nemusel vše programovat od začátku, vybíral jsem mezi hotovými open source implementacemi modelu a zvolil
procesor tvořící součást parseru Xerces.
Ten vyhovuje specifikaci; zpřístupnil komponenty schématu a jejich struktury programovým prostředkům jazyka Java.

Dále bylo třeba rozhodnout se pro vhodný způsob zobrazení struktur definovaných schématem.
Zde jsem se inspiroval výstupy úspěšného XML editoru oXygen.
Z představy grafického modelu vzešel návrh tříd objektů – obecného abstraktního symbolu a konkrétních symbolů
komponent schématu –, návrh jejich vzhledu, parametrů a propojení i ve vazbě k zajištění interaktivity modelu.
Přitom bylo nutné alespoň v základu poznat možnosti formátu SVG.

Po načtení instance XML schématu do objektové reprezentace jazyka Java se spustí procházení těmito objekty a
začne se vytvářet stromová struktura definovaných symbolů.
Ta je nakonec uložena do SVG souboru.
Na něj jsou ale ještě vázány další technologie.
Především jde o ECMAScript, který je součástí souboru a provádí jeho zpracování při otevření v prohlížeči.
Zajišťuje interaktivitu reakcemi na události spuštěné pohybem a klikáním myši.
Aby skript mohl pracovat s elementy SVG dokumentu, potřebuje k nim získat přístup.
Přístup zajišťuje DOM úrovně 2.
Poslední technologií jsou kaskádové styly, které mohou tvořit součást SVG souboru nebo mohou být připojeny z
externího souboru a umožňují drobné úpravy výsledného vzhledu.

Na závěr mohu konstatovat, že se podařilo splnit cíl práce.
Praktickým produktem je funkční program, jehož výstupem je přehledný, interaktivní diagram zobrazující
strukturu XML souborů, vyhovujících schématu.
Konkrétně je to struktura použitelných elementů a atributů, jejich jména, jmenné prostory, datové typy,
kardinalita elementů, definované klíče atd.
Postromy symbolů lze zobrazovat a skrývat.
Dle mého názoru může diagram skutečně usnadnit orientaci a pochopení struktur, může tvořit kvalitní doplněk dokumentace.

I zde však existují určitá omezení.
První vyplývá z pomalé implementce SVG a ECMAScriptu v prohlížečích.
Projevuje se v pomalejší reakci na události a obecně v pomalejším vykreslování velkých diagramů.
V této oblasti lze jen doufat, že do budoucna vznikne lepší podpora.
Další problém se může vyskytnout při programovém zpracování schémat, popisujících velmi rozsáhlé struktury.
Může dojít k pádu aplikace v důsledku překročení paměťového prostoru.
Tento problém lze odstranit úpravou aplikace, vzhledem k prvnímu omezení však není nutné s úpravou moc spěchat.

Tím se dostávám k faktu, že aplikace včetně zdrojových kódů bude šířena jako svobodný software.
Momentálně je dostupná na přiloženém CD (viz <<_CD>>) a na webové stránce http://st.vse.cz/~XSLAV14/.
To přináší možnost budoucího rozvoje aplikace v podobě vylepšování nebo rozšiřování funkčnosti.
Například by šla přidělat tlačítka pro zoom in a zoom out; rozšířit program o podporu dalších schémových jazyků
(pokud vím, je jejich vizualizace předmětem jiných bakalářských prací);
nebo integrovat do systému pro generování kompletních dokumentací.

:sectnums!:

[bibliography]
== Literatura

[bibliography]
[float]
=== Hlavní
- [[[XSD0,1]]] Fallside, D. C., Walmsley, P. a kol.:
    _XML Schema Part 0: Primer Second Edition_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xmlschema-0/

- [[[XSD1,2]]] Thompson, H. S., Beech, D., Maloney, M., Mendelsohn, N. a kol.:
    _XML Schema Part 1: Structures Second Edition_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xmlschema-1/

- [[[XSD2,3]]] Biron, P. V., Malhotra, A. a kol.:
    _XML Schema Part 2: Datatypes Second Edition_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xmlschema-2/

- [[[XSD-VLIST,4]]] van der Vlist, E.:
    _Using W3C XML Schema. XML.com, 2001._
    Dostupný z WWW: http://www.xml.com/pub/a/2000/11/29/schemas/part1.html?page=1

- [[[SVG,5]]] Ferraiolo, J., Fujisawa, J., Jackson, D.: Scalable Vector Graphics (SVG) 1.1 Specification
    [online]. W3C, 2003. Dostupný z WWW: http://www.w3.org/TR/SVG/

[bibliography]

[float]
=== Vedlejší a doplňková
- [[[XML,6]]] Bray, T., Paoli, J., Sperberg-McQueen, C. M., Maler, E., Yergeau, F. a kol.:
    _Extensible Markup Language (XML) 1.0 (Fourth Edition)_
    [online]. W3C, 2006. Dostupný z WWW: http://www.w3.org/TR/REC-xml/

- [[[INFOSET,7]]] Cowan, J., Tobin, R.:
    _XML Information Set (Second Edition)_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xml-infoset/

- [[[NAMESPACE,8]]] Bray, T., Hollander, D., Layman, A., Tobin, R.:
    _Namespaces in XML 1.0 (Second Edition)_
    [online]. W3C, 2006. Dostupný z WWW: http://www.w3.org/TR/REC-xml-names/

- [[[DOM1,9]]] Wood, L. a kol.:
    _Document Object Model (DOM) Level 1 Specification_
    [online]. W3C, 1998. Dostupný z WWW: http://www.w3.org/TR/REC-DOM-Level-1/

- [[[DOM2,10]]] Wood, L. a kol.:
    _Document Object Model (DOM) Level 2 Core Specification_
    [online]. W3C, 2000. Dostupný z WWW: http://www.w3.org/TR/DOM-Level-2-Core/

- [[[CSS,11]]] Lie, H. W., Bos, B.:
    _Cascading Style Sheets, level 1_
    [online]. W3C, 1996. Dostupný z WWW: http://www.w3.org/TR/CSS1/

- [[[M254,12]]] Hall, W., Keynes, M.:
    _M254 Java everywhere_
    [online]. The Open University, 2005. Dostupný z WWW: http://computing.open.ac.uk/m254/

:sectnums:

:sectnums!:

[appendix]
== Termíny
[glossary]
API:: Application Programming Interface,
    rozhraní aplikačních programů. Sada procedur, funkcí nebo tříd
    určité knihovny, programu nebo jádra operačního systému, která může
    být využita v aplikacích.

CSS:: Cascading Style Sheets, kaskádové styly.
    Jednoduchý mechanismus pro přidání grafické úpravy webovým
    dokuentům. Standard organizace W3C mimo jiné v <<CSS>>.

Data binding:: Převod dat mezi různými formáty. Například mezi XML dokumenty,
    objekty objektově orientovaných systémů a relačními tabulkami
    databázových systémů.

DOM:: Document Object Model, objektový model
    dokumentu. Rozhraní nezávislé na platformě a jazyku, které umožňuje
    programům a skriptům dynamický přístup k obsahu, struktuře a stylu
    dokumentu a jeho editaci. Poskytuje objektově orientovanou
    reprezentaci XML nebo HTML dokumentu. Specifikace W3C v <<DOM1>>, <<DOM2>> a dalších.

DTD:: Document Type Definition, definice typu
    dokumentu. DTD poskytuje nástroje pro definování povolených struktur
    elementů a atributů, umožňuje stanovení implicitních hodnot
    atributů. V rámci DTD lze také definovat znovupoužitelný obsah
    (entity) a dodatečné informace (notace). Specifikace je součástí
    doporučení organizace W3C o XML – <<XML>> a
    další.

ECMAScript:: Skriptovací (programovací) jazyk, standardizován organizací
    Ecma International ve specifikaci
    ECMA-262. Je široce používán na webu a bývá
    často označován jako JavaScript nebo JScript, podle hlavních
    dialektů tohoto jazyka.

Framework:: Základní konceptuální struktura užívaná k řešení nebo zaměření
    se na komplexní problémy. V oblasti softwaru se často jedná
    o knihovny, podpůrné programy, návrhové vzory a doporučené postupy.
    Framework řeší typické úlohy, které jsou ve většině aplikací shodné,
    a usnadňuje tak vývoj.

HTML:: HyperText Markup Language, hypertextový
    značkovací jazyk. Jazyk pro tvorbu webových stránek, aplikace SGML.
    Specifikaci vydala organizace W3C.

Informační položka:: Information item. Představuje uzel
    stromové struktury XML infosetu. Specifikace <<INFOSET>> definuje jedenáct různých typů položek. Každá
    má určité vlastnosti jako je rodičovský element, lokální jméno atd.
    V této práci se zmiňuji o znakové informační položce, informační
    položce element a atribut.

Infoset:: XML Information Set je abstraktní datový
    model XML dokumentu, skládá se z jednotlivých informačních položek.
    Specifikace W3C <<INFOSET>>.

Java:: Objektově orientovaný, silně typový, na platformě nezávislý
    programovací jazyk od společnosti Sun Microsystems.

Namespace:: Jmenný prostor. XML poskytuje jednoduchou metodu pro
    kvalifikování jmen elementů a atributů jejich zařazením do jmenného
    prostoru s URI identifikátorem. Specifikace W3C <<NAMESPACE>>.

Parsování:: Analýza předložených dat a vyhledávání prvků odpovídajících
    definici určitého jazyka. Obvykle jde o syntaktickou analýzu
    zdrojových kódů napsaných v daném programovacím jazyce.

PSVI:: Post Schema Validation Infoset, infoset
    po validaci dokumentu oproti schématu. Je to infoset XML dokumentu
    rozšířený o informace o datových typech položek. Příspěvky k PSVI
    jsou definovány ve specifikaci XML schématu <<XSD1>>
    a <<XSD2>>.

Renderování:: Rendering, proces, při němž se vykresluje
    obraz ze zadaných dat.

SAX:: Simple API for XML, jednoduché aplikační
    rozhraní pro XML. Poskytuje mechanismus pro čtení dat z XML
    dokumentů. Čtení probíhá sekvenčně a je založeno na událostech
    (přečtení počátečního tagu, přečtení ukončujícího tagu atd.) Není
    proto možná modifikace struktury dokumentu, na rozdíl od DOM.

SVG:: Scalable Vector Graphics, škálovatelná
    vektorová grafika. SVG je jazyk pro popis dvourozměrné grafiky a
    grafických aplikací pomocí XML. Základ vývoje tvoří specifikace SVG
    1.1, vydaná jako doporučení konsorcia W3C 14. ledna 2003 <<SVG>>.

Tag:: Značka vymezující začátek a/nebo konec elementu.

Validace:: Ověření shody XML dokumentu se schématem.

W3C:: World Wide Web Consortium. Zabývá se
    vývojem interoperabilních technologií – specifikací, směrnic,
    softwaru a nástrojů – s cílem sjednotit používané technologie
    a dosáhnout plného rozvoje a využití možností webu.

XHTML:: Extensible HyperText Markup Language,
    rozšiřitelný hypertextový značkovací jazyk. Jazyk pro tvorbu
    webových stránek, aplikace XML. Specifikaci vydala organizace
    W3C.

XML:: Extensible Markup Language, rozšiřitelný
    značkovací jazyk. Umožňuje vývojářům vytvářet vlastní formáty pro
    uchování a sdílení dat. Specifikaci vydalo konsorcium W3C, <<XML>> a další.

XML schéma:: XML schémata poskytují prostředky pro definování struktury,
    obsahu a sémantiky XML dokumentů. XML schéma bylo schváleno jako
    doporučení organizace W3C 2. května 2001 a druhá, upravená verze
    byla vydána 28. října 2004 <<XSD0>>, <<XSD1>>, <<XSD2>>.


:sectnums:

:sectnums!:

[appendix]
[[_CD]]
== Obsah CD-ROM

Součástí této práce je přiložený CD-ROM s textem práce, zdrojovými kódy a hotovou aplikací.
Poslední verze bude přístupná na webové stránce: http://st.vse.cz/~XSLAV14/.
Konkrétně na CD naleznete následující strukturu adresářů a souborů:

. [.path]_/thesis_ – adresář týkající se psaní bakalářské práce, obsahuje:
** [.path]_/images_ – složka použitých obrázků kromě symbolů komponent schématu
** [.path]_/symbols_ – složka s obrázky symbolů komponent schématu ve formátu SVG
** [.path]_thesis.xml_ – vlastní text práce ve formátu DocBook
** [.path]_thesis.xsl_, [.path]_tp-fo.xsl_ – styly upravující standardní výstup DocBooku
** [.path]_kizi.pdf_ – logo katedry pro titulní stranufootnote:[Upravené styly a logo katedry pochází ze stránek Jiřího Koska, věnovaných výuce na VŠE: http://www.kosek.cz/vyuka/.]
** [.path]_thesis.pdf_ – vygenerované PDF s touto prací
. [.path]_/src_ – adresář zdrojových kódů Javy, struktura vychází ze zařazení tříd do balíčků
. [.path]_/res_ – adresář dalších zdrojů obsahující:
** [.path]_/examples_ – složka s příklady XSD vstupů
** [.path]_/licenses_ – složka s licencemi parseru Xerces
** [.path]_readme.txt_ – textový dokument, popisuje uživatelské rozhraní
. [.path]_/lib_ – adresář obsahuje implementaci parseru Xerces – [.path]_xercesImpl.jar_
. [.path]_/dist_ – složka s aplikací připravenou k použití, obsahuje:
** [.path]_/examples_ – překopírováno z adresáře [.path]_/res_
** [.path]_/licenses_ – překopírováno z adresáře [.path]_/res_
** [.path]_/lib_ – adresář knihoven:
... kopie souboru [.path]_xercesImpl.jar_ a případných dalších z adresáře [.path]_/lib_
... archiv s vlastní aplikací [.path]_xsdvi.jar_
** [.path]EXAMPLES.bat_ – spouští transformaci příkladů, schémat ze složky examples
** [.path]_readme.txt_ – překopírováno z adresáře [.path]_/res_
. [.path]_build.properties_ – nastavení vlastností využívaných v [.path]_build.xml_
. [.path]_build.xml_ – XML skript pro sestavovací program Ant


:sectnums:

:sectnums!:

[appendix]
[[EXAMPLES]]
== Příklad

=== XML schéma – ukázkový vstup

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="contact" type="ContactType"/>
    
    <xs:complexType name="ContactType">
        <xs:sequence>
            <xs:element name="phone" type="xs:string"/>
            <xs:element name="address" type="AddressType"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="AddressType">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="street" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
----

[[EXAMPLES-SVG-XML]]
=== SVG výstup (XML reprezentace)

[source, xml]
----
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN'
  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
<svg id='svg' onload='loadSVG();'
  xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<title>XsdVi</title>

<script type='text/ecmascript'><![CDATA[
  var efBoxes = [];
  var eSvg = null;
  function loadSVG() {
    efBoxes = getElementsByClassName('box', document.getElementsByTagName('g'));
    eSvg = document.getElementById('svg');
    expandAll();
  }

  function getElementsByClassName(sClass, nlNodes) {
    var elements = [];
    for (var i=0; i<nlNodes.length; i++) {
      if(nlNodes.item(i).nodeType==1
        && sClass==nlNodes.item(i).getAttribute('class')) {
        elements.push(nlNodes.item(i));
      }
    }
    return elements;
  }

  function show(sId) {
    var useElement = document.getElementById('s'+sId);
    var moveNext = false;
    var eBoxLast;
    var maxX = 500;
    
    if (notPlus(useElement)) {
      eBoxLast = document.getElementById(sId);
      setPlus(useElement);
      for (var i=0; i<efBoxes.length; i++) {
        var eBox = efBoxes[i];
        if (moveNext) {
          move(eBoxLast, eBox);
        }
        else if (isDescendant(sId, eBox.id)) {
          eBox.setAttribute('visibility', 'hidden');
        }
        else if (isHigherBranch(sId, eBox.id)) {
          move(eBoxLast, eBox);
          moveNext = true;
        }
        if (eBox.getAttribute('visibility') != 'hidden') {
          eBoxLast = eBox;
          x = xTrans(eBox);
          if (x > maxX) maxX = x;
        }
      }
    }
    else {
      setMinus(useElement);
      var skipDescendantsOf;
      for (var i=0; i<efBoxes.length; i++) {
        var eBox = efBoxes[i];
        if (moveNext) {
          move(eBoxLast, eBox);
        }
        else if (isDescendant(sId, eBox.id) && (!skipDescendantsOf
          || !isDescendant(skipDescendantsOf.id, eBox.id))) {
          eBox.setAttribute('visibility', 'visible');
          move(eBoxLast, eBox);
          if (nextClosed(eBox)) skipDescendantsOf = eBox;
        }
        else if (isHigherBranch(sId, eBox.id)) {
          move(eBoxLast, eBox);
          moveNext = true;
        }
        if (eBox.getAttribute('visibility') != 'hidden') {
          eBoxLast = eBox;
          x = xTrans(eBox);
          if (x > maxX) maxX = x;
        }
      }
    }
    setHeight(yTrans(eBoxLast)+71);
    setWidth(maxX+300);
  }

  function collapseAll() {
    for (var i=0; i<efBoxes.length; i++) {
      var eBox = efBoxes[i];
      var useElement = document.getElementById('s'+eBox.id);
      if (useElement) setPlus(useElement);
      if (eBox.id != '_1') eBox.setAttribute('visibility', 'hidden');
    }
    setHeight(400);
    setWidth(500);
  }

  function expandAll() {
    var eBoxLast;
    var maxX = 0;
    for (var i=0; i<efBoxes.length; i++) {
      var eBox = efBoxes[i];
      var useElement = document.getElementById('s'+eBox.id);
      if (useElement) setMinus(useElement);
      move(eBoxLast, eBox);
      eBox.setAttribute('visibility', 'visible');
      eBoxLast = eBox;
      var x = xTrans(eBox);
      if (x > maxX) maxX = x;
    }
    setHeight(yTrans(eBoxLast)+71);
    setWidth(maxX+300);
  }

  function makeVisible(sId) {
    var childNodes = document.getElementById(sId).childNodes;
    var hidden = getElementsByClassName('hidden', childNodes);
    var visible = getElementsByClassName('visible', childNodes);
    inheritVisibility(hidden);
    hiddenVisibility(visible);
  }

  function makeHidden(sId) {
    var childNodes = document.getElementById(sId).childNodes;
    var hidden = getElementsByClassName('hidden', childNodes);
    var visible = getElementsByClassName('visible', childNodes);
    inheritVisibility(visible);
    hiddenVisibility(hidden);
  }

  function inheritVisibility(efElements) {
    for (var i=0; i<efElements.length; i++) {
      efElements[i].setAttribute('visibility', 'inherit');
    }
  }

  function hiddenVisibility(efElements) {
    for (var i=0; i<efElements.length; i++) {
      efElements[i].setAttribute('visibility', 'hidden');
    }
  }

  function nextClosed(eBox) {
    var useElement = document.getElementById('s'+eBox.id);
    return (useElement && !notPlus(useElement));
  }

  function isHigherBranch(sSerialLower, sSerialHigher) {
    var sLower = sSerialLower.split('_');
    var sHigher = sSerialHigher.split('_');
    for (var i=0; i<sLower.length; i++) {
      if (Number(sHigher[i]) > Number(sLower[i])) return true;
      else if (Number(sHigher[i]) < Number(sLower[i])) return false;
    }
    return false;
  }

  function isOnHigherLevel(eBoxLower, eBoxHigher) {
    var sLower = eBoxLower.id.split('_');
    var sHigher = eBoxHigher.id.split('_');
    for (var i=0; i<sLower.length; i++) {
      if (Number(sHigher[i]) > Number(sLower[i])) return true;
    }
    return false;
  }

  function isDescendant(sSerialAsc, sSerialDesc) {
    return (sSerialDesc.length > sSerialAsc.length &&
      sSerialDesc.indexOf(sSerialAsc) === 0);
  }

  function getParent(eBox) {
    var serial = eBox.id.substring(0, eBox.id.lastIndexOf('_'));
    return document.getElementById(serial);
  }

  function move(eBoxLast, eBox) {
    if (!eBoxLast) return;
    if (isOnHigherLevel(eBoxLast, eBox)) {
      eBox.setAttribute('transform',
        'translate('+xTrans(eBox)+','+(yTrans(eBoxLast)+71)+')');
      var parent = getParent(eBox);
      var line = document.getElementById('p'+eBox.id);
      if (!parent || !line) return;
      line.setAttribute('y1', String(yTrans(parent)-yTrans(eBox)+23));
    }
    else {
      eBox.setAttribute('transform',
        'translate('+xTrans(eBox)+','+yTrans(eBoxLast)+')');
    }
  }

  function notPlus(eUseElement) {
    return (eUseElement.getAttributeNS('http://www.w3.org/1999/xlink',
      'href') != '#plus');
  }

    eUseElement.setAttributeNS('http://www.w3.org/1999/xlink',
      'href', '#plus');
  }

  function setMinus(eUseElement) {
    eUseElement.setAttributeNS('http://www.w3.org/1999/xlink',
      'href', '#minus');
  }

  function setHeight(nHeight) {
    eSvg.setAttribute('height', nHeight);
  }

  function setWidth(nWidth) {
    eSvg.setAttribute('width', nWidth);
  }

  function yTrans(eBox) {
    var transform = eBox.getAttribute('transform');
    var y = Number(transform.substring(10,
      Number(transform.length)-1).split(',')[1]);
    if(!y) y = 0;
    return y;
  }

  function xTrans(eBox) {
    var transform = eBox.getAttribute('transform');
    var x = Number(transform.substring(10,
      Number(transform.length)-1).split(',')[0]);
    if(!x) x = 0;
    return x;
  }
]]></script>

<defs>

<style type='text/css'><![CDATA[

svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}

]]></style>

  <symbol class='button' id='plus'>
    <rect x='1' y='1' width='10' height='10'/>
    <line x1='3' y1='6' x2='9' y2='6'/>
    <line x1='6' y1='3' x2='6' y2='9'/>
  </symbol>
  <symbol class='button' id='minus'>
    <rect x='1' y='1' width='10' height='10'/>
    <line x1='3' y1='6' x2='9' y2='6'/>
  </symbol>

</defs>

<rect class='button' x='300' y='10' width='20' height='20'
  onclick='collapseAll()'/>
<line x1='303' y1='20' x2='317' y2='20'/>
<text x='330' y='20'>collapse all</text>
<rect class='button' x='400' y='10' width='20' height='20'
  onclick='expandAll()'/>
<line x1='403' y1='20' x2='417' y2='20'/>
<line x1='410' y1='13' x2='410' y2='27'/>
<text x='430' y='20'>expand all</text>

<g id='_1' class='box' transform='translate(20,50)'>
<rect class='boxschema' x='0' y='12' width='63' height='21'/>
<text x='5' y='27'><tspan class='big'>/ </tspan>schema</text>
<use x='62' y='17' xlink:href='#minus' id='s_1' onclick='show("_1")'/>
</g>

<g id='_1_1' class='box' transform='translate(128,50)'>
<rect class='shadow' x='3' y='3' width='117' height='46'/>
<rect class='boxelement' x='0' y='0' width='117' height='46'
  onmouseover='makeVisible("_1_1")' onmouseout='makeHidden("_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>contact</text>
<text class='visible' x='5' y='41'>type: ContactType</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='116' y='17' xlink:href='#minus' id='s_1_1' onclick='show("_1_1")'/>
</g>

<g id='_1_1_1' class='box' transform='translate(290,50)'>
<rect class='boxcompositor' x='0' y='8' width='60' height='31' rx='9'/>
<circle cx='42' cy='14' r='2'/>
<circle cx='42' cy='23' r='2'/>
<circle cx='42' cy='32' r='2'/>
<text class='small' x='30' y='17'>1</text>
<text class='small' x='30' y='26'>2</text>
<text class='small' x='30' y='35'>3</text>
<line x1='42' y1='14' x2='42' y2='32'/>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='59' y='17' xlink:href='#minus' id='s_1_1_1'
  onclick='show("_1_1_1")'/>
</g>

<g id='_1_1_1_1' class='box' transform='translate(395,50)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_1")'
  onmouseout='makeHidden("_1_1_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>phone</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2' class='box' transform='translate(395,121)'>
<rect class='shadow' x='3' y='3' width='117' height='46'/>
<rect class='boxelement' x='0' y='0' width='117' height='46'
  onmouseover='makeVisible("_1_1_1_2")'
  onmouseout='makeHidden("_1_1_1_2")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>address</text>
<text class='visible' x='5' y='41'>type: AddressType</text>
<line class='connection' id='p_1_1_1_2' x1='-35' y1='-48' x2='-35' y2='-40'/>
<path class='connection' d='M-35,-40 Q-35,15 0,23'/>
<use x='116' y='17' xlink:href='#minus' id='s_1_1_1_2'
  onclick='show("_1_1_1_2")'/>
</g>

<g id='_1_1_1_2_1' class='box' transform='translate(557,121)'>
<rect class='boxcompositor' x='0' y='8' width='60' height='31' rx='9'/>
<circle cx='42' cy='14' r='2'/>
<circle cx='42' cy='23' r='2'/>
<circle cx='42' cy='32' r='2'/>
<text class='small' x='30' y='17'>1</text>
<text class='small' x='30' y='26'>2</text>
<text class='small' x='30' y='35'>3</text>
<line x1='42' y1='14' x2='42' y2='32'/>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='59' y='17' xlink:href='#minus' id='s_1_1_1_2_1'
  onclick='show("_1_1_1_2_1")'/>
</g>

<g id='_1_1_1_2_1_1' class='box' transform='translate(662,121)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_1")'
  onmouseout='makeHidden("_1_1_1_2_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>name</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2_1_2' class='box' transform='translate(662,192)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_2")'
  onmouseout='makeHidden("_1_1_1_2_1_2")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>street</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2_1_3' class='box' transform='translate(662,263)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_3")'
  onmouseout='makeHidden("_1_1_1_2_1_3")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>city</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' id='p_1_1_1_2_1_3'
  x1='-35' y1='-119' x2='-35' y2='-40'/>
<path class='connection' d='M-35,-40 Q-35,15 0,23'/>
</g>

</svg>
----

=== SVG výstup (grafická reprezentace)

[[MY-MODEL-APPENDIX]]
.Grafický výstup
image::images/model_my.svg[]


:sectnums:
