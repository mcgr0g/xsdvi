= Визуализация XML схемы
Václav Slavětínský <https://sourceforge.net/u/vaclaforge/profile/>;
květen 2008
:doctype: book
:sectnums:
:toc: left
:toclevels: 4
:icons: font
:experimental:

== Введение

XML позволяет разработчикам создавать собственные форматы для хранения и обмена данными, следуя правилам синтаксиса.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное объявление и документация,
то есть описание, которое позволит им обмениваться, определяться и использоваться. Для этого было разработано несколько языков.
К ним относятся W3C _XML schema_, DTD (_Document Type Definition_) и Oasis _Relax NG_.

Благодаря интеграции с другими стандартами на основе XML, а также широким возможностям и поддержке крупных компаний-разработчиков программного обеспечения - часто используют схему XML.
Однако его спецификация (см. <<XSD1>>, <<XSD2>>) довольно сложна, и схемы могут стать запутанными для пользователя.
Причиной этого являются различные возможности написания, вытекающие из объектных элементов этого языка.
Схема XML позволяет использовать, расширять и ограничивать типы данных;
создание ссылок на элементы, атрибуты и группы элементов или атрибутов;
элементы могут быть заменены механизмом групп замещения;
также можно импортировать, вставлять и переопределять внешние схемы или их части.

Тема данной работы - визуализация XML-схем.
Цель состоит в том, чтобы спроектировать и реализовать приложение, которое на входе получит экземпляр XML-схемы W3C, а на выходе бы
сохранила свое интерактивное графическое представление в формате SVG (_Scalable Vector Graphics_) <<SVG>>.
Это графическое представление или диаграмма могут использоваться как часть документации, соответствующей схеме XML.
На диаграмме будут показаны структуры используемых элементов и атрибутов, их имена, пространства имен,
типы данных и дополнительная информация - количество элементов, обязательное / необязательное использование атрибутов, определенные уникальные, первичные и внешние ключи и т. д.
Это также позволит просматривать структуры, открывать и скрывать подгруппы элементов и атрибутов, используя _ECMAScript_.
Важными требованиями являются то, чтобы графика была интерактивной, интуитивно понятной и понятной,
потому что целью работы является главным образом облегчить ориентацию и понимание XML-схем их пользователями - создателями XML-документов.

Файлы SVG можно открывать в современных веб-браузерах (для некоторых необходимо установить плагин SVG)
или в приложениях, предназначенных для просмотра или редактирования векторной графики.
Многие из них находятся в свободном доступе. Векторная графика использует геометрические объекты для представления изображений, что облегчает программное редактирование.
Однако некоторые ограничения возникают из-за сложности обработки и медленной реализации ECMAScript в браузерах.
Это становится очевидным в больших схемах, точнее в больших структурах описанных документов.
(большие структуры могут быть определены даже с относительно короткой схемой).
Ограничение отражается в более медленной реакции на события и, как правило, в более медленном построении диаграммы.
В этой области мы можем только надеяться на лучшую поддержку в будущем.

Само приложение будет написано на языке программирования Java и будет использовать пакеты синтаксического анализатора _Xerces_,
которая является реализацией интерфейса с открытым исходным кодом, определенного в <<XSD1>> и <<XSD2>>.
Для запуска вам необходимо установить среду исполнения _Java Runtime Environment_.
Сегодня, однако, JRE является общей частью большинства компьютеров.
С помощью Java приложение может быть легко перенесено на разные платформы.

Позвольте мне кратко упомянуть структуру работы.
Цель второй главы - познакомить читателя с технологиями, используемыми в приложении, и способами их использования.
К ним относятся XML-схема W3C, масштабируемая векторная графика, ECMAScript и объектная модель документа, каскадные таблицы стилей, язык Java.

Специальная глава (третья) посвящена возможностям загрузки и интерпретации модели XML-схемы.
Существует описание нескольких реализаций с открытым исходным кодом абстрактной модели данных XML-схемы и их оценка.
Я наконец выбрал процессор Xerces2-J из этих реализаций.
Он создает основу программы, предоставляя легкий доступ к компонентам схемы и их свойствам.

Четвертая глава посвящена разработке графической модели.
Сначала выбирается соответствующий тип, логическая модель; она четко отображает структуру определенных документов XML.
Ниже приведен анализ отдельных элементов - графических символов компонентов схемы - и их структуры.
Для каждого символа вы найдете изображения, значения и описания параметров, относящиеся к свойствам компонентов схемы.
Описан механизм интерактивности модели и возможность дополнительной модификации внешнего вида с помощью внешнего стиля.

Цель пятой главы - разработать алгоритм обработки схемы.
Вам нужно пройтись по некоторым компонентам и извлечь данные визуализации из их свойств.
Обработка компонентов, значение которых также описано здесь, обеспечивается отдельными методами.
Они вызывают друг друга, обмениваются параметрами и создают графические символы для последующего сохранения в файл SVG.

В заключение постараюсь подвести итоги работы и указать, где можно скачать приложение.

== Используемые технологии

=== XML-схема

XML, _Extensible Markup Language_, расширяемый язык разметки, позволяет разработчикам создавать свои собственные форматы
для хранения и обмена данными. Это создает новые словари пунктов - элементов и их свойств(качеств) - атрибутов.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное информация и документация,
то есть описание, которое позволяет совместно использовать, определять и использовать словари.

_XML схема_
    footnote:[Второе издание датировано 28 октября 2004 г., первое было утверждено 2 мая 2001 г.]
является спецификацией, выпущенной консорциумом W3C.
    footnote:[Консорциум World Wide Web, официальный сайт. http://www.w3.org/]
Определяет объектно-ориентированный язык, который можно использовать для формального описания документов XML;
он предоставляет средства для определения их структуры, содержания и семантики.
В частности, мы можем использовать схему для определения элементов и атрибутов, применимых к документу, включая их структуру - взаимное погружение и совмещение;
мы также можем указать тип данных для содержимого элемента или атрибута, значений по умолчанию и других ограничений целостности.
К ним относятся уникальные ключи (_unique_), первичные ключи (_key_) и внешние ключи (_keyref_), ссылающиеся на них.

Схему XML часто сравнивают с другим распространенным языком схемы - DTD, _Document Type Definition_.
Это уже было включено в спецификацию XML 1.0 W3C <<XML>>.
Наиболее важные различия заключаются в том, что DTD использует свой собственный синтаксис, а схема XML является приложением XML, то есть использует его синтаксис.
Другой причиной выбора схемы XML является возможность назначения типов данных для атрибутов и содержимого элементов.
У DTD не было этого базового свойства, поэтому все значения обрабатывались как текстовые строки.
Также не было возможности работать с пространствами имен.
Однако DTD все еще широко используются, главным образом для простоты.

Спецификация схемы XML и ее нотация XML являются сложными, а в некоторых местах довольно сложными для понимания и использования.
Поэтому были разработаны и другие языки: _Relax NG_ с общим (XML) и компактным синтаксисом и _Schematron_ с другим подходом - для проверки правил.
Однако схема XML имеет самое широкое применение, в том числе и потому, что она поддерживается крупными компаниями-разработчиками программного обеспечения (Microsoft, IBM, Oracle, Sun).

Схема XML формализует ограничения, выраженные в виде правил или структурных моделей, которым соответствует определенный класс документа XML.
Схемы часто служат инструментами проектирования, устанавливая структуру, на которой могут быть построены конкретные реализации.
Существует несколько типичных областей применения схем.
В основном это валидация, документирование, запросы, биндинг данных и редактирование данных <<XSD-VLIST>>:

* _Валидация_ означает проверку XML-документа на соответствие схеме.
    Он часто используется для управления доступом XML к приложению.
    Он действует как фильтр; документы, соответствующие схеме, будут переданы, другие не будут использоваться.
    Это внешнее управление значительно упрощает приложения, которые в противном случае должны были бы обрабатывать многие исключения, встречающиеся в
    обработка неудовлетворительных входных данных XML.

* _Документирование_ означает описание в виде XML-документа.
    Это формально и машиночитаемо. Поскольку схема XML является документом XML,
    формальная документация может быть легко преобразована в удобочитаемую,
    например, используя преобразования XSLT или другие преобразования.
    Также приложение, которое является результатом этой дипломной работы бакалавра, выполняет такое преобразование в изображение

* Схемы обеспечивают поддержку _query_, поиск содержимого в документах XML.
    Это можно сделать без них, кроме дополнительной информации о структуре и типах данных
    поможет ускорить и упростить поиск и сортировку и сопоставление.
    Использование можно найти на языках _XPath 2.0_, _XSLT 2.0_, _XQuery 1.0_.

* XML-схемы используются с самого начала для _биндинга данных_.
    Это означает преобразование данных, содержащихся в документах XML, в структуры конкретных приложений,
    такие как объекты в объектно-ориентированных системах и реляционные таблицы систем реляционных баз данных.
    Схемы предоставляют дополнительную информацию о типах данных, которые преобразуются в типы данных приложения.

* Как правило, схемы обычно используют для _редактирования_ XML-документов. Например, эта работа взята из _DocBook_,
    который также является применением XML. Редактор, который я использую, дает мне выбор элементов,
    которые допустимы на месте согласно схеме. Это значительно облегчает работу.
    Редактор использует DTD DocBook, предоставляя информацию о структуре,
    Кроме того, схемы XML предоставляют информацию о типах данных.


[float]
==== Компоненты схемы

Процессор схемы XML, соответствующие спецификации W3C <<XSD1>>,
должен работать с информацией, содержащейся в диаграмме, как описано в спецификации.
Схема XML рассматривается здесь как абстрактная модель данных концептуального уровня, независимая от реализации.
Модель данных состоит из отдельных, точно определенных компонентов – _komponent_.
Каждый из них включает в себя описание представления  XML, свойства и ограничения, описание правил проверки,
обращения к PSVI (_Post Schema Validation Infoset_),
    footnote:[Это XML infoset (набор информации), дополнен дополнительной информацией о типе отдельных пунктов – элементов,
        атрибутов, обычных узлов.]
и любые встроенные экземпляры этих компонентов.

Определение следующее:
    "`_Компонент схемы_ - это общий термин, который представляет строительные элементы
      составляющие модель данных абстрактной схемы... _XML Схема_ - это набор компонентов схемы.`"
    footnote:[XML Schema Abstract Data Model. http://www.w3.org/TR/xmlschema-1/#concepts-data-model]

Существует 13 видов компонентов, которые можно разделить на 3 группы.
_Приложение будет работать с ними, как описано в главе <<XSD-PROCESSING>>._
Чтобы быстро понять отношения между компонентами, используйте диаграмму <<DIAGRAM_KOMPONENT>>.
    footnote:[там же.]

[[DIAGRAM_KOMPONENT]]
.Диаграмма компонент XML схемы
image::images/components.gif[]

Первичные компоненты могут или должны быть названы:

* определение простых типов (_Simple type definitions_),
* определение сложных типов (_Complex type definitions_),
* декларирование атрибута (_Attribute declarations_),
* декларирование элемента (_Element declarations_).

Вторичные компоненты должны именоваться:

* определение групп атрибутов (_Attribute group definitions_),
* определение ограничений идентичности (_Identity-constraint definitions_),
* определение группы моделей (_Model group definitions_),
* декларирование нотации (_Notation declarations_).

Вспомогательные компоненты обеспечивают доступ к другим компонентам. Они зависят от контекста:

* аннотирование (_Annotations_),
* модельные группы (_Model groups_),
* гранулы (_Particles_),
* символы подстановки (_Wildcards_),
* использование атрибутов (_Attribute Uses_).


=== SVG

_Scalable Vector Graphics_, Масштабируемая векторная графика была создана на основе консорциума W3C.
Спецификации составляют основу разработки SVG 1.1 <<SVG>>.
Помимо нее, однако, есть много других:
_SVG Tiny 1.2_,
_SVG Mobile 1.1_,
_SVG Print_,
_SVG Filters_,
_SVG Requirements_.
Их тематика - это язык для описания двумерной графики и графических приложений с использованием XML.
Это векторная графика, которая использует геометрические объекты для представления изображений.
Это дает возможность масштабирования - уменьшения и увеличения - без потери качества;
объекты, составляющие изображение, различаются, и полученные файлы обычно занимают меньше места, чем файлы растровых изображений.
Само собой разумеется, что векторная графика подходит только для некоторых типов изображений, таких как символы, диаграммы или графики.
_Результатом исполнения приложения, которое является предметом этой работы, будет диаграмма схемы XML в SVG._

Формат SVG был разработан главным образом для использования в Интернете,
в наши дни это делает его возможным открыть прямо в браузерах Mozilla Firefox, Opera;
в MS Internet Explorer к сожалению, после установки соответствующего плагина (Adobe SVG Viewer).
Формат также поддерживается в коммерческих (Adobe Illustrator, CorelDraw) и open source (Inkscape, Sodipodi) редакторов.

SVG предоставляет три типа графических объектов.
Это векторные графические фигуры, такие как контуры, состоящие из линий и кривых, изображений и текста.
Эти объекты можно группировать, преобразовывать, предварительно отображать и назначать стили.
Другие функции включают в себя вложенные преобразования, обрезание объектов по путям,
альфа-маскирование, фильтрацию изображений и шаблоны объектов.

Получающиеся изображения могут быть интерактивными и динамическими.
Анимации могут быть определены и выполнены декларативно с использованием специальных элементов SVG или скриптов.
Все элементы, атрибуты и свойства доступны для скриптовых языков через SVG _Document Object Model_ (DOM).
K любому графическому объекту могут быть назначены разные обработчики событий, такие как onmouseover, onclick.
footnote:[Наведение курсора мыши.]

Кроме того, SVG может быть встроен в другие форматы XML с использованием технологии пространства имен (_namespace_).
Совместимость также обеспечивается в том смысле, что скрипты могут выполняться, например, на XHTML
(_Extensible HyperText Markup Language_) веб-странице, на которой были вставлены элементы SVG.
Точно так же легко использовать каскадные таблицы стилей (_Cascading Style Sheets_, CSS) для описания внешнего вида отдельных объектов.

[float]
==== Элементы, используемые в выходных данных приложения

Ниже приведено краткое описание элементов SVG, используемых приложением для графического представления схемы.
Элементы также содержат некоторые важные атрибуты.
Кроме того, необходимы общие атрибуты: [.property]`id` для уникальной идентификации элемента в документе и [.property]`class` назначения элемента определенной группе, которой затем может быть назначен стиль.
Пример конкретного приложения можно найти во вложении <<EXAMPLES-SVG-XML>>.

==== <svg>
footnote:[http://www.w3.org/TR/SVG11/struct.html#NewDocument]

Фрагмент документа SVG состоит из любого количества элементов SVG, заключенных в тег `<svg>`
В нашем случае это будет не фрагмент, а отдельный документ, корневым элементом которого будет `<svg>`
Кроме обычных атрибутов ([.property]`id`, [.property]`class`) здесь они будут:

* [.property]`xmlns` – декларация пространства имен,
* [.property]`onload` – запускает скрипт, когда этот элемент загружен.


==== <title>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DescriptionAndTitleElements]

Заголовок, короткая подпись может быть добавлена к каждому контейнеру или графическому элементу.
Он не будет отображаться напрямую, но может отображаться как _tooltip_.
Заголовок, добавленный `<svg>` элементом, отображается браузером в строке заголовка.

==== <script>
footnote:[http://www.w3.org/TR/SVG11/script.html#ScriptElement]

Используется для вставки скрипта, будет включен как дочерний элемент для `<svg>` элемента.
Сам скрипт должен быть обернут секцией `<![CDATA[ skript ]]>`,
что бы интерпретатор понимал содержимое только как текст и не ищет теги.

* Атрибут [.property]`type` – указывает скриптовый язык, значение MIME типа, в случае ECMAScript -  `text/ecmascript`.

==== <defs>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DefsElement]

Содержит элементы, на которые есть ссылки в документе.
Содержимое может совпадать с контейнером `<g>`, разница в том, что перечисленные здесь графические объекты не будут отображаться напрямую.
Определения в выходных данных приложения включают элемент стиль `<style>` и часто используемые символы `<symbol>`

==== <style>
footnote:[http://www.w3.org/TR/SVG11/styling.html#StyleElement]

Используется для вставки стиля, который описывает расположение объектов и их групп.
Опять же, будет уместно обернуть стиль разделами `<![CDATA[ styl ]]>`

* Атрибут [.property]`type` – указывает язык стиля, значение - MIME-типа,
    footnote:[RFC спецификация 2045: Multipurpose Internet Mail Extensions. http://www.ietf.org/rfc/rfc2045.txt]
    в каскадном стиле `text/css`.


==== <symbol>
footnote:[http://www.w3.org/TR/SVG11/struct.html#SymbolElement]

Символ определяет графический шаблон, который не отображается до тех пор,
пока он не будет использован в документе SVG элементом  `<use>`.
Определение символов имеет смысл для часто используемых объектов.
В этом приложении будет два  – _plus_ и _minus_ для раскрытия и скрытия поддерева графических символов (блоков).
Будут использованы только общие атрибуты.

==== <use>
footnote:[http://www.w3.org/TR/SVG11/struct.html#UseElement]

Относится к другому элементу и указывает, что его графическое содержимое должно быть
включено и отображено там, где находится элемент `<use>` указан.
Среди них могут быть графические элементы, `<g>`, `<svg>`, `<use>` и (в нашем случае только) `<symbol>`.
В дополнение к обычным атрибутам здесь мы используем:

* [.property]`x` – задает координату на оси X, где будет расположен ссылочный объект,
* [.property]`y` – задает координату на оси Y, где будет расположен ссылочный объект,
* [.property]`xlink:href` – URI ссылка на объект, реализованная с использованием идентификатора,
* [.property]`onclick` – запускает скрипт при нажатии на графический объект, который будет _plus_ или _minus_.     Скрипт раскрывает или скрывает поддерево графических символов (блоков).

[[g-container]]
==== <g>
footnote:[http://www.w3.org/TR/SVG11/struct.html#Groups]

Представляет собой контейнер для группировки связанных графических элементов.
Мы будем использовать его для ассоциации SVG элементов формирующих конкретный графический символ компонента схемы (блок).

* Атрибут [.property]`transform` – определяет графическое преобразование контента.
Графика может быть перемещена, масштабирована, повернута и искривлена.
Мы будем перемещать секции только на _x_ единиц по оси X и на _y_ единиц по оси Y, используя
[.property]`transform` = `translate`([.parameter]`x`, [.parameter]`y`).


==== <text>
footnote:[http://www.w3.org/TR/SVG11/text.html#TextElement]

Определяет текстовый графический элемент.
Он отображается с использованием тех же методов, что и другие графические элементы.
Будет использоваться для отображения различных имен, свойств и меток в блоках.
Будут необходимы атрибуты:

* [.property]`x` – представляет абсолютную позицию текста, отсчитанную от первого символа, по оси X.
    Также можно указать несколько (_n_) значений, которые затем представляют позиции первых _n_ символов.

* [.property]`y` – представляет абсолютную позицию текста, отсчитанную от первого символа на оси Y.
    Вы также можете указать здесь несколько значений, разделенные пробелом или запятой,
    с тем же значением, что и атрибут [.property]`x`.

* [.property]`visibility` – определяет, является ли текст видимым, скрытым
    или наследует видимость от своего родителя.
    Этот атрибут будет необходим, чтобы скрыть и показать некоторые символьные метки для компонентов схемы.


==== <line>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#LineElement]

Определяет отрезок.
С помощью линий и кривых соединяются отдельные графические символы (секции),
а из отрезков будут состоять и другие элементы.
Будем использовать атрибуты:

* [.property]`x1` – координаты начала линии на оси X,
* [.property]`y1` – координаты начала линии на оси Y,
* [.property]`x2` – координаты конца линии на оси X,
* [.property]`y2` – координаты конца линии на оси Y.


==== <polyline>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolylineElement]

Он определяет набор взаимосвязанных линий, обычно образующих открытые фигуры.
Элемент `<polyline>` используется только в некоторых графических символах компонентов схемы.

* Атрибут [.property]`points` – список пар координат X и Y, начала и конца отрезков, из которых состоит это образование.


==== <polygon>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolygonElement]

Определяет замкнутую форму, состоящую из множества взаимосвязанных отрезков.
Элемент `polygon` будет использоваться только в некоторых графических символах компонентов схемы.

* Атрибут [.property]`points` – список пар координат по осям X и Y, образующих многоугольник.


==== <rect>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#RectElement]

Определяет прямоугольник.
Используется для рендеринга секций, их теней и других графических элементов.
Для классификации мы будем использовать атрибут [.property]`class`, следующим образом:

* [.property]`x` – координаты стороны прямоугольника по оси X, эта сторона,
    чьи координаты имеют меньшее значение в системе координат пользователя (обычно слева).
* [.property]`y` – координаты стороны прямоугольника вдоль оси Y
    сторона определяется по аналогии с атрибутом [.property]`x`, обычно это верхняя сторона.
* [.property]`width` – ширина прямоугольника,
* [.property]`height` – высота прямоугольника,
* [.property]`rx` – радиус эллипса, образующий закруглённые углы прямоугольника, по оси X.
* [.property]`onclick` – имеет то же значение, что и элемент `<use>`,
    атрибут будет установлен для прямоугольных кнопок управления.


==== <circle>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#CircleElement]

Определяет окружность, круг. Он будет использоваться в выходных данных приложения только в качестве дополнительного графического элемента.
Будем использовать атрибуты:

* [.property]`cx` – координаты центра круга по оси X,
* [.property]`cy` – координаты центра круга по оси Y,
* [.property]`r` – радиус.


==== <path>
footnote:[http://www.w3.org/TR/SVG11/paths.html#PathElement]

Представляет контур формы.
Он может быть заполнен, обведен или может служить в качестве шаблона, по которому будут обрезаны другие объекты.
В этом приложении он будет служить конечной частью соединения секций.

* Атрибут [.property]`d` – определяет формы контура.
    Обычно состоит из команд _moveto_, _lineto_, _curveto_, _arc_ и _closepath_,
    или абсолютный или относительный.
        footnote:[Перемещение курсора в указанную позицию без рисования линии; с отрисовкой линии;
        с прорисовкой более детальной кривой; с рендерингом дуги;
        с прорисовкой отрезка, ведущей к начальной точке, чтобы сформировать замкнутую форму.]
    Для команд дополнительно вводятся пары координат по осям X и Y.


=== ECMAScript

ECMAScript это скриптовый язык, стандартизированный организацией _Ecma International_ в спецификации _ECMA-262_.
    footnote:[Ecma International: Standard ECMA-262. ECMAScript Language Specification 3rd edition (December 1999).
    http://www.ecma-international.org/publications/standards/Ecma-262.htm]
Широко используется в интернете, и, как правило, часто упоминается как _JavaScript_ или _JScript_, согласно основных диалектов этого языка.
Синтаксис намеренно похож на синтаксис _Java_, но он более облегчён,
чтобы сделать его более легким в использовании, например, нет необходимости объявлять тип переменных.
В то же время такой подход увеличивает вероятность ошибки.

ECMAScript это объектно-ориентированный язык программирования для выполнения вычислений и манипулирования объектами _в пользовательском окружении_.
Следовательно, он не работает независимо, ввод и вывод данных и обрабатываемых объектов предоставляет другая существующая система,
возможности которой расширяются скриптами.
Это суть скриптовых языков. _В этом приложении скрипт будет использоваться для обеспечения интерактивности модели схемы SVG в среде браузера._
Более подробная информация находится в разделе <<INTERACTIVITY>>.

ECMAScript был первоначально разработан для Интернета, чтобы оживить веб-страницы и перенести часть производительности на клиента - браузер - в архитектуре клиент-сервер.
Когда страница HTML (_HyperText Markup Language_) браузер предоставляет объекты, представляющие окна, меню, диалоговые поля, текстовые области, ссылки, кадры и многое другое.
Он также будет предоставлять способы запуска кода сценариев для таких событий, как загрузка страниц, изменение размеров окон, движение мыши, клики.

Однако нам нужны не специальные HTML-элементы, а интерфейсы к SVG или вообще объектам XML.
Общий интерфейс стандартизирован в следующей спецификации W3C, называемой DOM (_Document Object Model_).
    footnote:[W3C: Модель объекта документа (DOM). http://www.w3.org/DOM/]
DOM существует в нескольких уровнях – уровне 1-3. В этом приложении, второго уровня будет достаточно.
Для программных манипуляций с масштабируемыми графическими объектами создан специальный SVG DOM.
Это часть спецификации SVG
    footnote:[Приложение B: Модель объекта документа SVG (DOM). http://www.w3.org/TR/SVG/svgdom.html]
и далее расширяет DOM Уровень 2.
Мы могли бы использовать SVG DOM хорошо, но мы должны иметь дело с несовместимостью некоторых браузеров.
В итоге, мы будем придерживаться базового уровнем DOM 2, который является более распространенным.
Нам понадобятся методы и атрибуты, описанные в <<DOM1>> и <<DOM2>>, а их конкретное применение показано в примере <<EXAMPLES-SVG-XML>>:

* [.interface]#Document#
    :
        [.interface]#Element#
        [.method]`getElementById`
    (in
        [.interface]#DOMString#
        [.parameter]`elementId`
    ); получить элемент по его идентификатору, который указан в
        [.property]`id`
    .

* [.interface]#Document#
    :
        [.interface]#NodeList#
        [.method]`getElementsByTagName`
    (in
        [.interface]#DOMString#
        [.parameter]`tagname`
    ); получить список узлов с указанным именем тега.

* [.interface]#Node#
    :
        `readonly attribute`
        [.interface]#NodeList#
        [.property]`childNodes`
    ; содержит список всех детях узла.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]`getAttribute`
    (in
        [.interface]#DOMString#
        [.parameter]`name`
    ); для получения значения атрибута с указанным именем.

* [.interface]#Element#
    :
        `void` [.method]`setAttribute`
    (in
        [.interface]#DOMString#
        [.parameter]`name`
    , in
        [.interface]#DOMString#
        [.parameter]`value`
    );
    установить значение атрибута с данным именем или создать новый атрибут для этого узла с
    с указанным именем и значением.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]`getAttributeNS`
    (in
        [.interface]#DOMString#
        [.parameter]`namespaceURI`
    , in
        [.interface]#DOMString#
        [.parameter]`localName`
    );чтобы получить значение атрибута с данным локальным именем и пространством имен.

* [.interface]#Element#
    :
        `void` [.method]`setAttributeNS`
    (in
        [.interface]#DOMString#
        [.parameter]`namespaceURI`
    , in
        [.interface]#DOMString#
        [.parameter]`qualifiedName`
    , in
        [.interface]#DOMString#
        [.parameter]`value`
    );
    установить значение атрибута с данным именем и в пространстве имен, или создать
    новый атрибут для этого узла с указанным именем и значением в данном пространстве имен.


=== CSS

CSS, _Cascading Style Sheets_, каскадные стили снова являются результатом активности W3C.
    footnote:[W3C: Cascading Style Sheets. Домашняя страница. http://www.w3.org/Style/CSS/]
Спецификация определяет язык описания стиля, который позволяет создателям и пользователям прикрепить стиль
(например, шрифты и отступы) к структурированным документам, таким как HTML документы и XML документы.
Это может отделить описание внешнего вида документа от его содержания и упростить создание и управление сайтом.

CSS предназначен быть легко читаемым для людей, стиль выражается в терминологии, которая является общей в DTP.
    footnote:[Desktop publishing (DTP), https://en.wikipedia.org/wiki/Desktop_publishing]
Одной из основных особенностей является то, что стиль является _каскадным_.
Это означает, что несколько определений стилей могут накладываться друг на друга, но применяется только последний.
Создатель прикрепляет предпочтительный стиль к документу, но пользователь может наложить на него свой собственный стиль,
с учетом человеческого или технологического преимущества <<CSS>>.

Стиль состоит из индивидуальных _правил_.
Каждое правило определяет внешний вид одного или нескольких элементов – элементов, выбранных _селектором_, первой части правила.
За селекторами следует список деклараций, оговоренных скобками, каждая декларация разделена запятой.
Каждая декларация состоит из _свойства_ (вслед за двоеточием) и _значения_ свойства.
Селектор может выбрать все элементы с определенным именем или элементами, содержащими указанные атрибуты,
он может указывать их в зависимости от того, где они размещены по отношению к другим элементам, и выбрать их в соответствии с
_псевдоклассами_ (`:hover`) и _псевдоэлементами_ (`:first-line`).
Если несколько правил могут быть применены к определенному элементу, он будет использоваться с более высоким приоритетом.
Проще говоря, это правило с более конкретным селектором.

_Каскадный стиль, который мы используем для вывода SVG этого приложения, позволит легко выполнять дополнительные манипуляции внешним видом
каждого класса графических элементов_, для более подробной информации см <<STYLE>>.

=== Java

Java — это объектно-ориентированный язык программирования для общего пользования.
Он был разработан _Sun Microsystems_ и стал одним из наиболее широко используемых языков программирования после его введения в 1995 году.
С мая 2007 года Java была разработана как открытый исходный код.

Характерной особенностью является переносимость на разные платформы.
Однажды написанная программа может работать на любой поддерживаемой операционной системе и оборудовании.
Письменный исходный код предварительно компилируется в так называемый _bytecode_, который является одинаковым для всех платформ;
различаются только виртуальные машины (_Virtual Machine_). Эти байткоды интерпретируют или переводят во время выполнения в нативный код.
Вы можете запустить программу везде, где есть соответствующая среда исполнения (_Java Runtime Environment_).

Намерение создателей Java в соответствии с <<M254>> вопросом заключается в том, чтобы создать язык, который будет:

* _Простой_: Java основывается на нескольких основных концепциях, которые разработчики могут легко узнать.

* _Подобный установленным технологиям_: синтаксис основан на синтаксисе популярного языка С++, но его сложность снижается.

* _Объектно-ориентированный_: программы работают с объектами. Определяются объекты класса, которые могут быть унаследованы от других классов.
    может реализовать готовые интерфейсы. Объекты или целые классы предоставляют свойства (атрибуты) и методы.
    Методы могут быть перекрыты и перегружены. Реализация скрыта;
    объекты предоставляют общедоступный интерфейс, который позволяет ими манипулировать, в противном случае они инкапсулируются. Язык сильно набран.

* _Надежный_: Java-программы строго проверяются перед запуском,
    язык не включает в себя различные опции C и C++, которые подвержены ошибкам.

* _Безопасный_: Java включает в себя специальные средства безопасности,
    программы, работающие по сети, не могут повредить файлы на компьютере или содержать вирусы.

* _Пореносимый_: Программы могут быть легко перенести с одной платформы на другую, с минимальными изменениями или без изменений.

* _Высокопроизводительный_: Java-программы работают достаточно быстро для желаемых целей.

* _Исполняемый_: связано с переносимостью, см.

* _Использование программных потоков_: это позволит программе выполнять сразу несколько задач для повышения производительности.

* _Динамичный_: Программы могут адаптироваться к изменениям в среде даже во время выполнения.

_Java я выбрал для этого приложения в основном из-за переносимости и большого распространения, этот язык также близок мне благодаря
курсам, завершенным в ВШЭ._

== Параметры загрузки и интерпретации модели XML Schema

В предыдущей главе я кратко описал технологии, используемые в интерактивном приложении визуализации.
Теперь вам нужно решить, как открыть схему, загрузить ее в память, интерпретировать и обработать.
Схему XML можно рассматривать с нескольких уровней:

[float]
=== Обычный текстовый файл

Если бы мы понимали схему только как текстовый файл, нам пришлось бы запрограммировать полный способ интерпретации разметки,
затем работать с результатом в виде документа XML. К счастью, это уже давно решается с помощью стандартизированных интерфейсов
SAX (_Simple API for XML_) и DOM (_Document Object Model_).

[float]
=== Документ XML

Было бы достаточно загрузить документ с помощью SAX и при этом искать типичные структуры, состоящие в основном из имен элементов и
значения атрибутов, важные для интерпретации схемы.
Эти структуры будут представлены в качестве объектов и их свойств, 
либо так, чтобы эти объекты соответствовали своему назначению - мы просто хотим визуализировать схему -,
либо в соответствии с спецификацией.
Соответствие спецификациям обеспечивает совместимость, функциональность и облегчает работу в случае изменений.
Однако после прочтения файла необходимо решить другие задачи, в том числе:

* Извлечение импортнных, встроенных и переопределенных схем, чтобы убедиться, что они не зациклились.
* Вставка типов, встроенных в спецификацию как часть схемы.
* Необходимо переопределить типы данных, группы элементов и группы атрибутов.
* Необходимо составить ссылки на глобально объявленные типы, первичные и уникальные ключи, 
    глобально объявленные элементы и атрибуты, глобально объявленные группы элементов и атрибутов.

Однако даже в этой области есть готовые реализации, которые просто указывают входной файл, устанавливают их с несколькими параметрами и позволяют загружать схему.
Мы обязательно воспользуемся одним из них (см. <<XSD-API>>), это сэкономит много работы.
В конце концов, мы будем работать на самом высоком уровне, с абстрактной моделью данных.

[float]
=== Абстрактная модель данных

Интерпретация схемы в соответствии с <<XSD1>> дает нам легкий доступ ко всем компонентам и свойствам.
С более подробным описанием обработки можно ознакомиться в главе <<XSD-PROCESSING>>.

[[XSD-API]]
=== Выбор соответствующей реализации схемы XML

Лучшим вариантом будет найти приемлемую реализацию с открытым исходным кодом, соответствующую спецификациям, и узнать, как с ней справиться.
Ниже приводится описание четырех известных открытых приложений, которые работают со схемой, и выбор одного из них.

==== Eclipse: Инструменты разработки моделей - XSD
footnote:[Eclipse Modeling: Model Development Tools(MDT). http://www.eclipse.org/modeling/mdt/?project=xsd#xsd]

_Model Development Tools_ (MDT) является частью _Eclipse_,
которая ориентирована на разработку и продвижение технологий для разработки моделей - Eclipse Modeling Project.
Eclipse предоставляет различные рамки, инструменты и реализации технологических стандартов.
В частности, MDT предназначен для внедрения стандартных метамоделей и образцов инструментов для разработки моделей на основе этих метамоделей.
Компоненты MDT:

* Бизнес-модель и нотация бизнес-процессов (BPMN2),
* Онтологическое определение метамодели (EODM),
* Метамодель управления информацией (IMM),
* Язык ограничения объектов (OCL)
* Семантика бизнес-вокабулярности и бизнес-правил (SBVR),
* Единый язык моделирования (UML2),
* Инструменты UML2,
* Модель XML Schema Infoset (XSD).

_XML Schema Infoset Model_ — это библиотека, предоставляющая интерфейс для приложений, которые ищут,
w3c xml схемы. Для управления компонентами можно использовать интерфейс, описанный в спецификации,
но вы также можете работать с представлением DOM схемы. Для модификаций оба представления меняются соответственно.
Библиотека также включает в себя услуги по сериализации и десериализации схем. _Цель проекта должна полностью охватить функциональность
представления XML схем_, но без предоставления службы валидации, которая обычно входит в валидаторы парсеров (Xerces-J).

==== Apache: Xerces2 Java Parser - XML Schema
footnote:[The Apache XML Project: Xerces2 Java ParserReadme. http://xerces.apache.org/xerces2-j/]

_Xerces2_ является открытым XML парсером с исходным кодом, разработанным компанией _Apache_, его преимуществом является высокая производительность и соответствие стандартам.
Кроме того, он включает в себя Xerces Native Interface, framework для построения компонентов и парсеров конфигураций.

Xerces может сравнивать документы, написанные в соответствии с нотациями XML 1.1, а также правильно работает с пространствами имен
в соответствии с XML Namespaces 1.1. Он также обеспечивает полную реализацию DOM Level 3 Core,
Load and Save реализует XML Inclusions (они являются нотациями W3C) и обеспечивает поддержку каталогов OASIS XML v1.1.

_Xerces2 также является процессором схемы XML, который, за некоторыми незначительными исключениями, полностью соответствует спецификации <<XSD1>> и <<XSD2>>_.

==== Saxonica: Saxon
footnote:[Saxon, The XSLT andXQuery Processor.http://saxon.sourceforge.net]

_Saxon_ – это полная реализация рекомендаций XSLT 2.0, XQuery 1.0 и консорциума XPath 2.0 w3c.
Публикуется _Saxonica_, а также для платформ Java и .NET.
Он выпущен в двух версиях: Saxon-B является продуктом с открытым исходным кодом, реализует XSLT 2.0 и XQuery так, что
что он соответствует спецификациям только на базовом уровне требований.
Saxon-SA является коммерческим продуктом, но он позволяет применять XSLT и XQuery с использованием схем.
Таким образом, можно импортировать схему и проверять входне или выходные данные и выбирать элементы в соответствии с их типом.
Saxon-SA также включает в себя отдельный валидатор схемы XML и другие расширения по сравнению с Saxon-B.

_К сожалению, в версии с открытым исходным кодом нет интерфейса для доступа к компонентам схемы xml, и поэтому мы не можем использовать Saxon.

==== ExoLab: Castor - Source Generator XML Schema Support
footnote:[The Castor Project.http://www.castor.org/xmlschema.html]

_Castor_ — это платформа с открытым исходным кодом для Java, используемая для связывания данных, преобразования данных между объектами Java, XML-документами и таблицами из реляционных баз данных.

Она включает в себя, среди прочего, генератор исходного кода XML.
Последний создает классы Java, представляющие объектную модель в соответствии с входной XML-схемой.
Поэтому Castor поддерживает спецификацию W3C XML Schema <<XSD1>>, спецификацию <<XSD2>>.
Модель объекта представляет схему XML в памяти компьютера, в то время как генератор исходного кода преобразует данные
типов и структур схемы в соответствующие типы и структуры Java.
_Объектные модели схемы могут читать и записывать документы, манипулировать ими.
Они соответствуют спецификациям без отступлений._ Генератор кода еще не предлагает отображения для всех компонентов.

==== Volba Xerces2

Из описанных реализаций мы не можем использовать Saxon, другие кажутся эквивалентными и полностью соответствуют спецификации.
Наконец, я выбрал процессор схемы XML, который является частью парсера _Xerces2-J_.
Он прост и предоставляет именно те варианты, которые нам понадобятся.
Классы, представляющие отдельные компоненты, содержат методы доступа к свойствам, определеным в спецификации.
Изменение свойства не поддерживается, и в любом случае мы не будем его использовать.
Кроме того, легко управлять процессором, загружать схему и обрабатывать ее, использование хорошо документировано.
Кроме того, Xerces используется для визуализации схем в известном редакторе XML oXygen.
Eclipse MDT и Castor будут служить так же хорошо, но их функциональность излишне широка (работа с деревом DOM, создание и изменение схем).

== Дизайн графической модели

Прежде чем начать программировать приложение, которое будет генерировать графическое представление схем XML,
Я должен показать, как должно выглядеть это представление.
Я собираюсь принять решение о правильном типе модели, разработать дизайн символов - элементов модели - и связать их,
Я буду иметь дело с интерактивностью итоговой модели. Все это является предметом этой главы.

=== Два типа моделей

Существует два основных способа отображения схемы XML.
Оба, конечно, основаны на дереве документов XML, но отличаются по своей детализации и предназначению для использования.
Я покажу разницу на выходе _oXygen_,
    footnote:[Oxygen XML editor, официальная страница. http://www.oxygenxml.com]
который предлагает оба типа отображения.

В качестве примера используется простая схема XML:

[source, xml]
----
include::examples/ContactEntity.xsd[]
----

==== Полная модель

Полная графическая модель копирует XML-представление схемы. Для каждого элемента отображается собственный символ.
Кроме того, можно открыть дерево символов дальше и увидеть, что скрыто за ссылками на глобально определенные компоненты
схемы, такие как определения типов, глобальные декларации элементов, их группы и т.д.

Например, см <<FULL-MODEL>>.
После символа элемента `contact`, я раскрыл ветку с определением ее типа `ContactType`.
Это последовательность элементов `phone` и `address`.
Открыв дерево снова, я хотел бы получить определение типов этих элементов.
Кроме того, я могу видеть их ниже, как потомков декларирование `ContactType`.

Полная модель очень подробная.
Он предлагает компоненты, которые могут быть использованы для расширения схемы, но еще не применены в описанном документе;
подробно отображает все параметры и значения, глобальные определения типов, групповые декларации; списки импортированных и встроенных файлов.
Поэтому он предназначен для создателей схем XML, а не пользователей.

[[FULL-MODEL]]
.Представление схемы в полной модели
image::images/model_full.png[]


==== Логическая модель

В отличие от этого, логическая графическая модель отображает только основную информацию, важную для создателей документов XML, которые соответствуют схемам.
Символы значительно меньше, чем в случае полной модели.
Речь идет о показе пользователю возможной структуры элементов и атрибутов.
Ссылки на глобальные компоненты должны быть составлены так же, как и для полной модели,
однако при просмотре дерева на первый взгляд не видно, в какой части схемы определяется элемент.

Например, см. рисунок <<LOGICAL-MODEL>>.
Корневым элементом валидного документа XML является `contact`.
Внутри него должна появиться последовательность элементов `phone` и `address`.
В то время как `телефон` содержит строку текста (_string_), внутри элемента `address` есть другая последовательность,
и это элементы `name`, `street` и `city`.
Каждый из них имеет тип текстовой строки.

Таким образом, логическая модель подходит для пользователей схем XML, что облегчает им понимание определенных структур;
создатели также позволят быстрее контролировать свою работу.
Именно логическая модель будет результатом работы моего приложения, поскольку цель состоит в том, чтобы создать документацию схемы,
которая будет интуитивно понятна, и каждый быстро разберется в ней.
В документации описывается не схема XML, а документы, совместимые со схемой XML;
в частности, структуры (комбинирование, наследование) элементов, их атрибутов и типов данных.
Элементы схемы, которые не являются необходимыми для понимания цели, будут удалены из модели, как и компоненты, которые не используются напрямую.

[[LOGICAL-MODEL]]
 Представление диаграммы по логической модели
image::images/model_logical.png[]


=== Модель как дерево абстрактных символов

Эти примеры и характер документов XML подразумевают, что символы, которые составляют графическую модель,
понимается как узлы дерева.
Таким образом, на базовом уровне, будет абстрактный символ ([.class]`AbstractSymbol`)
со ссылкой на вашего родителя и отсортированный список ссылок на своих детей.
[.class]`AbstractSymbol` предоставит методы получения и назначения этих ссылок и запросов для получения дополнительной информации.

Кроме того, для визуализации каждого символа необходимо знать горизонтальную ([.parameter]`xPosition`)
и вертикальную позиции ([.parameter]`yPosition`), каждый символ имеет ширину и высоту.
[.class]`AbstractSymbol` определяет методы настройки подходящей ширины, высоты и визуализации символа.
Они должны быть переопределены у определенных символов.

[[ABSTRACT-MODEL]]
.Модель абстрактного символа
image::images/abstract_symbols.png[]


=== Символы отдельных компонентов схемы

Конкретный символ расширяет свойства абстрактного символа ([.class]`AbstractSymbol`).
Он в обязательном порядке заменяет методы для установки правильной ширины и высоты и для визуализации символа.
Ширина должна быть установлена с учетом длины текстовых строк, чтобы вписаться в символ.
При использовании пропорциональных шрифтов это можно решить только приблизительно.

Символ также предоставляет методы получения и задания параметров, описанных ниже.
Если нет ни одного из перечисленных параметров (например, потому что он представляет собой дополнительное свойство), то его значение не указано или обработано иным образом.

Ниже приведен обзор конкретных символов и их связей со схемой XML.
В описаниях параметров я исхожу из свойств и значений, определенных в спецификации <<XSD1>>.

[[SYMBOL-SCHEMA]]
==== `schema`

[.class]`SymbolSchema` представляет собой корневой элемент схемы.

Для рендеринга не нужно указывать никаких параметров.

.Символ `schema`
image::symbols/schema.svg[]


[[SYMBOL-ELEMENT]]
==== `element`

[.class]`SymbolElement` отображает название элементов информации элемента, их тип и классификацию,
пространство имен и другие свойства, доступные из компонента объявления элемента  (_Element declaration_).

* Параметр [.parameter]`name`- это текстовая строка, содержащая локальную часть информации об элементе, имена элементов,
    которые подтверждены. Значение задается объявлением элемента в свойстве [.property]`name`.

* Параметр [.parameter]`namespace`- это строка с пространством имен. Он квалифицирует информационный элемент элемента.
    Целевое пространство имен указывает на объявление элемента в свойстве [.property]`namespace`.

* Параметр [.parameter]`type` - это шрифт, содержащий имя типа элемента информационного элемента,
    pokud je tento typ pojmenovaný; nebo, pokud je typ anonymní a zároveň jednoduchý, obsahuje jméno základního typu,
    ze kterého je typ informačních položek element odvozen.
    Základem je vlastnost [.property]`name` definice typu (_Type definition_).

* Параметр [.parameter]`cardinality`- это строка, указывающая минимальное и максимальное количество вхождений элемента information items.
    Если он не указан в списке, это означает, что значения неявны (min = max = 1), и строка не будет визуализирована.
    Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_), содержащей это объявление элемента.
    Их имена [.property]`min occurs` a [.property]`max occurs`.

* Параметр [.parameter]`nillable`- логический тип говорящий, может ли он иметь информационные позиции элемента
    пустое содержимое (значение `true`) или нет (`false`).
    Значение указывается объявлением элемента в свойстве [.property]`nillable`.

* Параметр [.parameter]`abstr` является логическим типом.
    Если значение установлено на `true`, то это объявление само по себе не используется для проверки содержимого элементов.
    Значение указывается объявлением элемента в свойстве [.property]`abstract`.

* Параметр [.parameter]`substitution`- это строка с именем группы подстановок, к которой принадлежит данное объявление.
    Фактическое значение обеспечивается объявлением элемента в свойстве [.property]`substitution group affiliation`.

Нужно будет втиснуть в символ много информации, при этом не заполняя большую площадь.
Поэтому последние три свойства будут отображаться только при нажатии мыши вместо свойств [.property]`namespace` и [.property]`type`.

.Символ `element` (нормальный режим; при движении)
image::symbols/element.svg[]


[[SYMBOL-ATTRIBUTE]]
==== `attribute`

[.class]`SymbolAttribute` отображает имя элемента атрибутивной информации,
его вид и классификацию в пространстве имен и другие свойства, доступные из компонентов использования атрибутов (_Attribute use_)
и объявление атрибута (_Attribute declaration_).

* Параметр [.parameter]`name`- это текстовое сообщение, содержащее локальное сообщение, указывающее на элемент атрибутивной информации,
    что подтверждается. Значение предоставляется объявлением атрибута в свойстве [.property]`name`.

* Параметр [.parameter]`namespace` - это строка с пространством имен.
    Он квалифицирует атрибут информационного элемента. Целевое пространство имен указывает объявление атрибута своими свойствами [.property]`namespace`.

* Параметр [.parameter]`type` - это строка, содержащая имя атрибута типа информационного элемента,
    если этот тип имеет имя; или если тип является анонимным, содержит имя базового типа,
    из которого выводится тип атрибута информационного элемента. Основой является свойство [.property]`name` определение простого типа (_Simple type definition_).

* Параметр [.parameter]`required` - логический тип говорящий, должен ли присутствовать
    соответствующий элемент атрибутивной информации (значение `true`), или же это необязательно (`false`).
    В дополнение к перечислению соответствующей строки необязательный атрибут будет ограничен пунктирной линией,
    в то время как обязательный атрибут будет полным. Параметр имеет то же значение, что и свойство использования атрибута с именем [.property]`required`.

* Параметр [.parameter]`constraint` - это текстовая строка, указывающая ограничение на значение
     элемента атрибутивной информации (фиксированное или стандартное значение). Строка создается из свойства [.property]`value constraint`.
    Это то, что обеспечивает компонент использования атрибута или объявление атрибута.

Значения последних двух параметров отображаются только после наведения курсора мыши на символ `attribute`.

.Символ `attribute` (необязательный атрибут в обычном режиме; и при наведении курсора мыши; обязательный атрибут в обычном режиме)
image::symbols/attribute_optional.svg[]


[[SYMBOL-ANY]]
==== `any`

[.class]`SymbolAny` представляет собой подстановочный символ (_wildcard_) для элементов.
На его месте могут быть информационные элементы элемента с любым локальным именем, но они должны соответствовать ограничениям, наложенным на их пространство имен.

* Параметр [.parameter]`namespace` представляет собой текстовую строку, представляющую ограничения, наложенные на элемент пространства имен информационных элементов.
    Строка формируется из свойства [.property]`namespace constraint` компонента wild card.

* Параметр [.parameter]`processContents` это целое число, которое используется для разрешения проблемы способов обработки информационных статей элемента.
    Значение основано на свойстве [.property]`process contents` подстановочного символа и от него зависит изображение символа. Параметр приобретает значения:

** [.constant]`3` – метод обработки "слабый". Если существует уникальная декларация элемента, то элемент должен соответствовать этой декларации.
** [.constant]`2` – соответствует методу обработки "пропустить". Ограничений нет, элемент должна быть только хорошо структурированным xml.
** [.constant]`1` (и другие допустимые значения) - метод обработки "строгий".
    Информационному элементу должен быть присвоен xsi:type или должна быть доступна его декларация, по которой выполняется валидация.

* Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
    Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не
    будет отображаться. Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),
    содержащей эту дикую карту. Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `any` (Метод обработки `strict`; Метод обработки `skip`; Метод обработки `lax`)
image::symbols/any_strict.svg[]


[[SYMBOL-ANY-ATTRIBUTE]]
==== `anyAttribute`

[.class]`SymbolAnyAttribute` представляет собой подставновочный символ (_wildcard_) для атрибутов.
Вместо него информационные элементы могут быть атрибутом с любым локальным именем, но они должны соответствовать ограничениям, наложенным на их пространство имен.

* Параметр [.parameter]`namespace` это текстовая строка, представляющая ограничения, наложенные на пространство имен элементов атрибутивной информации.
    Строка формируется из свойства [.property]`namespace constraint` компонента wild card.

* Параметр [.parameter]`processContents` это целое число, которое используется для разрешения проблемы способов обработки атрибутов информационных элементов.
    Значение основано на свойстве [.property]`process contents` wild card и зависит от него изображение символа. Параметр приобретает значения:

** [.constant]`3` – метод обработки "слабый". Если существует уникальная декларация элемента, то элемент должен соответствовать этой декларации.
** [.constant]`2` – соответствует методу обработки "пропустить". Ограничений нет, запись должна быть только хорошо структурированным xml.
** [.constant]`1` (и другие допустимые значения) - метод обработки "строгий".
    Информационному элементу должен быть присвоен xsi:type или должна быть доступна его декларация, по которой выполняется валидация.


.Symbol `anyAttribute` (Метод обработки `strict`; Метод обработки `skip`; Метод обработки `lax`)
image::symbols/any_attribute_strict.svg[]


[[SYMBOL-ALL]]
==== `all`

[.class]`SymbolAll` представляет композит `all` модельной группы (_Model group_).
Он говорит, что дочерние элементы информационного элемента, определенные в модельной группе как [.property]`particles`, могут встречаться в любом порядке.

Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не будет нарисована. 
Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),содержащей эту дикую карту. 
Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `all`
image::symbols/all.svg[]


[[SYMBOL-CHOICE]]
==== `choice`

[.class]`SymbolChoice` представляет композит `choice` модельной группы (_Model group_).
Только одна из частиц (_particle_) определенных в модельной группе как [.property]`particles`,
может появиться в XML-документе как дочерний элемент элемента информации.

* Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
    Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не
    будет нарисована. Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),
    содержащей эту дикую карту. Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `choice`
image::symbols/choice.svg[]


[[SYMBOL-SEQUENCE]]
==== `sequence`

[.class]`SymbolSequence` представляет композит `sequence` модельной группы (_Model group_).
Каждая из частиц (_particle_) определяется в модельной группе как  [.property]`particles`,
 может отображаться в XML-документе как дочерний элемент информационного элемента в указанном порядке.

* Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
    Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не
    будет нарисована. Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),
    содержащей эту дикую карту. Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `sequence`
image::symbols/sequence.svg[]


[[SYMBOL-UNIQUE]]
==== `unique`

[.class]`SymbolUnique` представляет часть определения ограничения идентичности (_Identity-constraint definition_),
в частности, имя и пространство имен `unique` категории.
Это обеспечивает уникальность значений в содержимом, определяемом <<SYMBOL-SELECTOR>>,
которые являются результатом вычисления XPath выражений, указанных в полях <<SYMBOL-FIELD>>.

* Параметр [.parameter]`name` это текстовая строка, содержащая имя определения ограничения идентичности.
    Значение задается этим определением в свойстве [.property]`name`.
* Параметр [.parameter]`namespace` это строка с пространством имен.
    Последнее уточняет определение ограничения идентичности. Пространство имен определяет свое свойство [.property]`namespace`.
    Имя пары и пространство имен идентифицирует определение ограничения идентификации и поэтому должна быть уникальной в рамках XML-схемы.


.Symbol `unique`
image::symbols/unique.svg[]


[[SYMBOL-KEY]]
==== `key`

[.class]`SymbolKey` представляет часть определения ограничения идентичности (_Identity-constraint definition_),
в частности, имя и пространство имен `key` категории.
Это обеспечивает уникальность и наличие значений в содержимом, определяемом селектором <<SYMBOL-SELECTOR>>,
которые являются результатом вычисления выражений XPath, указанных в полях <<SYMBOL-FIELD>>.

* Параметр [.parameter]`name` это текстовая строка, содержащая имя определения ограничения идентичности.
    Значение задается этим определением в свойстве [.property]`name`.
* Параметр [.parameter]`namespace` это строка с пространством имен.
    Последнее уточняет определение ограничения идентичности. Пространство имен определяет свое свойство [.property]`namespace`.
    Имя пары и пространство имен идентифицирует определение ограничения идентификации и поэтому должна быть уникальной в рамках XML-схемы.


.Symbol `key`
image::symbols/key.svg[]


[[SYMBOL-KEYREF]]
==== `keyref`

[.class]`SymbolKeyref` представляет часть определения ограничения идентичности (_Identity-constraint definition_),
в частности имя и пространство имен категории `keyref`.
Это гарантирует, что значения, полученные в результате вычисления XPath выражений, указанных в полях <<SYMBOL-FIELD>>,
будут соответствовать значениям, указанным в определении свойства [.property]`referenced key` ограничения идентичности.
Это условие вычисляется в содержимом, заданном селектором <<SYMBOL-SELECTOR>>.

* Параметр [.parameter]`name` это текстовая строка, содержащая имя определения ограничения идентичности.
    Значение задается этим определением в свойстве [.property]`name`.
* Параметр [.parameter]`namespace` это строка с пространством имен.
    Последнее уточняет определение ограничения идентичности. Пространство имен определяет свое свойство [.property]`namespace`. Имя пары и пространство имен идентифицирует определение ограничения идентификации и поэтому должна быть уникальной в рамках XML-схемы.
* Параметр [.parameter]`refer` это строка, которая служит ссылкой на другое определение ограничения идентичности
    категории `key 'или' unique'. Значение задается этим определением в свойстве [.property]`referenced key`.


.Symbol `keyref`
image::symbols/keyref.svg[]


[[SYMBOL-SELECTOR]]
==== `selector`

[.class]`SymbolSelector` служит для отображения свойства [.property]`selector` определения ограничения идентичности (_Identity-constraint definition_).

* Параметр [.parameter]`xpath` это текстовая строка. Задает ограниченное выражение XPath относительно экземпляра объявленного элемента.
    Выражение должно идентифицировать набор узлов-подчиненных элементов, к которым применяется ограничение.
    Значение параметра получается из свойства [.property]`selector` ограничения идентичности.


.Symbol `selector`
image::symbols/selector.svg[]


[[SYMBOL-FIELD]]
==== `field`

[.class]`SymbolField` представляет один элемент из списка - свойства [.property]`fields`
определения ограничения идентичности (_Identity-constraint definition_).

* Параметр [.parameter]`xpath` это текстовая строка. Задает ограниченное выражение XPath относительно экземпляра объявленного элемента,
    выбранного селектором <<SYMBOL-SELECTOR>>. Выражение должно идентифицировать конкретный узел (элемент или атрибут),
    содержимое или значение которого должно иметь простой тип и использоваться в ограничении.  Значение параметра получается из
    определения [.property]`fields` ограничения идентичности.


.Symbol `field`
image::symbols/field.svg[]


[[SYMBOL-LOOP]]
==== петля

[.class]`SymbolLoop` это вспомогательный символ, который не принадлежит XML-схеме. Он будет нарисован, если произойдет зацикливание.
Фактически, объявление элемента может косвенно содержать само себя при условии выполнения следующих условий:

. Объявление элемента имеет комплексный тип.
. Комплексный тип (1) содержит частицу (_Particle_).
. Термин ([.property]`term`) частица (2) является модельной группой (_ModelGroup_) – всегда состоящей из других частиц.
. Термин по крайней мере одной из частиц (3) является объявлением элемента, идентичным объявлению, упомянутому в пункте (1);
    или член хотя бы одной из частиц (3) является модельной группой, и в этом случае рекурсивно исходят из точки (3),
    до тех пор, пока не будет найдено объявление элемента, идентичное тому, что указано в пункте (1).

У него нет параметров.

.Символ петля
image::symbols/_loop.svg[]


[[INTERACTIVITY]]
=== Интерактивная модель

Одним из требований, предъявляемых к графической модели, является ее интерактивность.
SVG можно перемещать с помощью ECMAScript (JavaScript). Вы можете просто изменить информацию, отображаемую при наведении курсора мыши на символы <<SYMBOL-ELEMENT>> и <<SYMBOL-ATTRIBUTE>>.
Сложнее реализовать распаковку и скрытие поддеревьев отдельных символов.
Для этого SVG-документ должен знать расположение символов в дереве.
Я буду использовать следующий пример, чтобы объяснить:

[source, xml]
----
include::examples/ADDRESS-SYMBOL.xml[]
----

Это XML-представление символа "адрес".
Он состоит из нескольких SVG-элементов и отображается как <<ADDRESS-SYMBOL>>.

* Символ состоит из двух прямоугольников. Первая слегка сдвинута, образуя легкую тень.
    Последний образует основную коробку и чувствителен к зависанию мыши.
* Кроме того, символ содержит четыре текстовых элемента. Первые два содержат "nillable: 0" ` и "abstract: 0"`
    теперь они спрятаны. Строки „address"` и „type: addressstype"` видны.
* За ним следует отрезок линии, за которым следует кривая, соединяющая символ с его родителем слева.
* Наконец, используется заранее определенный символ "плюс", представляющий собой небольшой квадрат со знаком "плюс".
    Он чувствителен к щелчкам мыши.

Кроме того, для того, чтобы работать с символом как единым целым,
все описанные элементы упаковываются в группу элементом `<g>`
Последнее также позволяет трансформировать положение символа и его однозначную идентификацию внутри дерева.

[[ADDRESS-SYMBOL]]
.Символ элемента адреса (в обычном режиме; при наведении мыши)
image::images/address.svg[]

Чтобы изменить отображаемые элементы при наведении курсора мыши, достаточно, чтобы каждый символ имел уникальный идентификатор.
Это передается в ECMAScript методами [.method]`makeVisible`([.parameter]`id`)
и [.method]`makeHidden`([.parameter]`id`) при наведении курсора мыши на поле основного символа или при его выходе из поля.
Изменение заключается в том, что элементы, которые имели заданную категорию ([.property]`class`) скрытыми, теперь будут видны.
Это текстовые строки "nillable: 0"` a "abstract: 0"`. Наоборот, предметы в классе будут временно скрыты.
Это включает в себя только строку „type: AddressType"`. См. изображение <<ADDRESS-SYMBOL>>.

Идентификатор символа, используемый здесь, довольно сложен, это строка `_1_1_1_2`.
Однако его использование оправдано.
Я уже писал, что для работы с поддеревьями символов в SVG-документе должно быть видно, к какой части дерева относится символ.
Это можно однозначно определить с помощью таких идентификаторов, указывающих путь от корня дерева к определенному символу.
Посмотрите на изображение <<INTERACTIVITY_MODEL>>.

[[INTERACTIVITY_MODEL]]
.Модель с кодами символов
image::images/model_interactivity.png[]

Корневой символ имеет идентификатор `_1`.
Разделитель необходим из-за допустимых значений атрибута `id`, поэтому он также выбирается в качестве разделителя.
Корневой символ также имеет двух детей.
Их идентификаторы состоят из идентификатора родительского и добавленной собвстенной части, указывающей их позицию.
Мы получаем строки `_1_1` a `_1_2`.
По аналогии, символ `_1_1` имеет дочернее значение `_1_1_1`.
Символ с идентификатором `_1_1_1` имеет два дочерних элемента, и второй из них (`_1_1_1_2`) является описываемым элементом, символом элемента `address`.

Когда вы нажимаете на символ минус после поля `address` используется ECMAScript метод [.method]`show`([.parameter]`"_1_1_1_2"`).
Последний выполняет следующие функции:

* Меняет символ минуса здесь на плюс, переписав атрибут `xlink:href` elementu `<use>`
    так, что это относится к предопределенному графическому объекту `plus`.
* Скрывает все поддерево символов, прикрепленное справа от поля. Он включает в себя все символы,
    чей идентификатор также начинается с `_1_1_1_2`. Для элементов `<<g-container>>`
    группирующих объекты, составляющие символ, атрибут "видимость" имеет значение [.property]`hidden`.
* Полученное пространство заполняется боковыми ветвями. Они перемещаются вверх, регулируя значение атрибута `transform`
    для группирующего элемента `<g>`.
    Расчет расстояния, на которое могут перемещаться символы, нужно делать только для одного символа, для остальных расстояние такое же.
    Здесь также будет работать система идентификации.
    Кроме того, необходимо укоротить отрезок линии, соединяющий родительские символы с прокрученной ветвью.

Результат можно увидеть на рисунке <<INTERACTIVITY-MODEL-2>>.
Если мы сейчас нажмем на символ плюса, то будет снова вызван метод [.method]`show`([.parameter]`"_1_1_1_2"`).
Но теперь он будет работать прямо противоположно тому, что было описано.

В дополнение к вышеописанному функционалу будут предусмотрены кнопки для отображения и скрытия всех символов, кроме корневого.
Со временем будут добавлены кнопки масштабирования _zoom in_ и _zoom out_, пока вы можете обойтись без них и использовать функции браузера.

[[INTERACTIVITY-MODEL-2]]
.Модель после скрытия поддерева элемента адреса
image::images/model_interactivity2.png[]


=== Итоговое SVG-представление схемы

Если все условия выполнены, я получаю вывод SVG из приложения,
графическое представление которого можно увидеть на рисунке <<MY-MODEL>>.
В приложении <<EXAMPLES>> для наглядности, снова показано, как вводится XML-схема,
таким образом, SVG выводится как в XML, так и в графическом представлении.

[float]
[[STYLE]]
==== Стиль

Однако полученную диаграмму можно дополнительно модифицировать, поскольку ее внешний вид задан в стиле CSS.
Приложение может сгенерировать стиль как часть SVG-документа или отдельно, или только прикрепить существующий внешний стиль.
Каскадные стили используют селекторы для выбора определенных элементов, которые затем задают внешний вид.
Выбор может быть определен именем тега, но если мы хотим единообразно редактировать определенные логические единицы, мы можем использовать их включение в классы ([.property]`class`). В выходных данных SVG были созданы следующие классы:

* [.property]`strong` для важных надписей, таких как названия элементов и атрибутов. Шрифт больше и жирнее.
* [.property]`small` для текста, который является частью графики, написанной более мелким шрифтом.
* [.property]`big` для текста, который является частью графики, написанной более крупным шрифтом.
* [.property]`button` для кнопок; суть в том, что он имеет в параметре [.property]`pointer-events`
    включается чувствительность к определенным событиям, в первую очередь речь идет о щелчках мыши.
* [.property]`shadow` это класс для тени, отображаемой за некоторыми блоками.
* [.property]`connection` включает в себя сегменты и кривые, соединяющие отдельные графические символы (боксы).
* [.property]`empty` для форм обтаженных, без заливки.
* [.property]`filled` для форм, заполненных, без границы.
* [.property]`boxelement` для поля символов <<SYMBOL-ELEMENT>>.
* [.property]`boxattribute1` для поля символов <<SYMBOL-ATTRIBUTE>>, если использование атрибута является обязательным.
* [.property]`boxattribute2` для поля символов <<SYMBOL-ATTRIBUTE>>, если использование атрибута является необязательны
* [.property]`boxany` для поля символов <<SYMBOL-ANY>>.
* [.property]`boxanyattribute` для поля символов <<SYMBOL-ANY-ATTRIBUTE>>.
* [.property]`boxschema` для поля символов <<SYMBOL-SCHEMA>>.
* [.property]`boxcompositor` для поля символов <<SYMBOL-ALL>>, <<SYMBOL-CHOICE>>, <<SYMBOL-SEQUENCE>>.
* [.property]`boxloop` для поля символов <<SYMBOL-LOOP>>.
* [.property]`boxidc` для поля символов <<SYMBOL-UNIQUE>>, <<SYMBOL-KEY>>, <<SYMBOL-KEYREF>>.
* [.property]`boxselector` для поля символов <<SYMBOL-SELECTOR>>.
* [.property]`boxfield` для поля символов <<SYMBOL-FIELD>>.
* [.property]`lax` служит для дальнейшей регулировки внешнего вида блоков <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    если их метод обработки установлен на _lax_.
* [.property]`skip` служит для дальнейшей регулировки внешнего вида блоков <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    если их метод обработки установлен на _skip_.
* [.property]`strict` служит для дальнейшей регулировки внешнего вида блоков <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    если их метод обработки установлен на _strict_.


[float]
==== Оригинальный стиль, сгенерированный приложением

[source, css]
----
svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}
----

[[MY-MODEL]]
.Вывод приложения для приведенного выше примера XML-схемы
image::images/model_my.svg[]


[[XSD-PROCESSING]]
== Обработка XML-схемы

В этой главе я покажу, как переключаться между компонентами схемы для создания концепции ядра приложения.
Отдельные разделы посвящены обработке конкретных компонентов, и в дополнение к алгоритму обработки они также содержат описание, взятое из спецификации <<XSD1>>.
Я ссылаюсь на конкретную часть спецификации в сноске для каждого раздела.

В качестве базовой библиотеки, на которой я буду строить приложение, я выбрал парсер с открытым исходным кодом Xerces после предварительного рассмотрения.
Он обеспечивает полную поддержку XML-схем согласно <<XSD0>>, <<XSD1>> a <<XSD2>>, с некоторыми ограничениями,
что в подавляющем большинстве случаев не станет препятствием.
    footnote:[The Apache XML Project: Xerces2 Java Parser Readme. XML Schema. http://xerces.apache.org/xerces2-j/xml-schema.html]
Таким образом, реализация Xerces будет работать в соответствии со спецификацией W3C и будет использовать ее условия.

Иллюстрация <<DIAGRAM_KOMPONENT>> позволит нам легко составить представление о связях и основных свойствах каждого из 
компонентов XML-схемы, определенных в третьей части спецификации.
    footnote:[Schema Component Details. http://www.w3.org/TR/xmlschema-1/#components]

[[PROCESS-MODEL]]
=== Обработка самой схемы
footnote:[http://www.w3.org/TR/xmlschema-1/#Schemas]

Схема (_Schema_, в классе Xerces [.class]`XSModel`) служит на абстрактном уровне контейнером для отдельных компонентов.
Это компоненты Глобальные, то есть именованные и аннотированные.

Метод [.method]`processModel`([.class]`XSModel`[.parameter]`model`) будет отвечать за обработку схемы.

. Символ <<SYMBOL-SCHEMA>> создается и вставляется как корень в структуру дерева символов.
. Вспомогательный метод [.method]`processElementDeclarations`([.parameter]`elementDeclarations`)
    [<<PROCESS-ELEMENT-DECLARATIONS>>], будет называться параметром всех глобально объявленных элементов.

Другие свойства схемы ([.property]`attribute declarations`, [.property]`model group definitions`,
    [.property]`attribute group definitions`, [.property]`type definitions`, [.property]`notation declarations`,
    [.property]`annotations`) для создания логической модели графического представления непосредственно не используются напрямую;
    Xerces предоставит нам некоторые из них позже через ссылки, как глобально определенные типы, атрибуты, элементы и их группы.
Таким образом, при рендеринге нам вообще не придется работать с компонентами определения группы атрибутов
    (_Attribute group definition_), определением группы моделей (_Model group definition_) и декларации обозначения
    (_Notation declaration_), которые доступны только из схемы, и нам также не понадобится аннотация (_Annotation_).

[[PROCESS-ELEMENT-DECLARATIONS]]
=== Обработка коллекции объявлений элементов

Коллекция объявлений элементов (объявленная в общем классе Xerces [.class]`XSNamedMap`).

Метод [.method]`processElementDeclarations`([.class]`XSNamedMap`[.parameter]`map`) выполняет глобальную обработку
объявления элементов. Метод включает в себя цикл.

. Совершает обход коллекции объявлений элементов:

.. Для каждого элемента коллекции вызывается [.method]`processElementDeclaration`([.parameter]`elementDeclaration`, `null`)
    [<<PROCESS-ELEMENT-DECLARATION>>]. Первый параметр-это конкретное объявление элемента (_Element declaration_), второй-строка, выражающая мощность элемента. В случае глобального объявления оно всегда имеет значение `null`.

[[PROCESS-ELEMENT-DECLARATION]]
=== Обработка объявления элемента
footnote:[http://www.w3.org/TR/xmlschema-1/#cElement_Declarations]

Объявление элемента (_Element declaration_, в классе Xerces [.class]`XSElementDeclaration`) позволяет:

* локальная проверка значений информационных элементов Element с использованием определений типов;
* указание значений по умолчанию или фиксированных значений для информационных элементов Element;
* обеспечение уникальности значений и установление контрольных ограничений в пределах значений связанных элементов и атрибутов;
* проверка подстановочности элементов с помощью механизма групп подстановок (_element substitution groups_).

Метод [.method]`processElementDeclaration`([.class]`XSElementDeclaration`[.parameter]`elementDeclaration`,
    [.class]`String`[.parameter]`cardinality`) будет обрабатывать объявление элемента:

. Символ <<SYMBOL-ELEMENT>> создается и прикрепляется к соответствующему месту древовидной структуры.
    В символе должна быть задана основная информация, предоставляемая непосредственно объектом [.parameter]`elementDeclaration`,
    но также и некоторая дополнительная информация, например, строка с типом элемента, полученная вызовом вспомогательного метода
    [.method]`getTypeString`([.parameter]`typeDefinition`) [<<PROCESS-SIMPLE-TYPE>>],  и строка, указывающая
    минимальное и максимальное число вхождений, полученных из параметра [.parameter]`cardinality`.
    Описание каждого элемента можно найти в графическом оформлении символа `element`.

. Должно быть установлено, не существует ли одного и того же объявления между предками этого объявления.
    Там будет цикл, и рендеринг модели никогда не закончится должным образом. Контроль осуществляется по методу
    [.method]`processLoop`([.class]`XSElementDeclaration`[.parameter]`elementDeclaration`),
    который имеет задачу прикрепления символа <<SYMBOL-LOOP>> в случае появления цикла и остановки обработки потомков.

. Если элемент имеет сложный тип данных, его определение будет обработано на текущем этапе.
    Это обеспечивается методом [.method]`processComplexTypeDefinition`([.parameter]`complexTypeDefinition`) [<<PROCESS-COMPLEX-TYPE>>]

. Будет вызван вспомогательный метод [.method]`processIdentityConstraints`([.parameter]`IdentityConstraints`)
    [<<PROCESS-IDENTITY-CONSTRAINTS>>], параметром которого являются все ограничения идентичности, определенные в этой декларации.


[[PROCESS-ATTRIBUTE-USES]]
=== Обработка коллекции использования атрибутов

Коллекция атрибутов (объявленная в общем классе Xerces [.class]`XSObjectList`).

Метод [.method]`processAttributeUses`([.class]`XSObjectList`[.parameter]`attributeUses`) выполняет обработку коллекции с утилитными атрибутами.
Метод включает в себя цикл.

. Совершает обход коллекции:

.. Для каждого элемента коллекции вызывается метод [.method]`processAttributeUse`([.parameter]`attributeUse`)
    [<<PROCESS-ATTRIBUTE-USE>>]. Параметр-это конкретное использование атрибута (_Attribute use_).

[[PROCESS-ATTRIBUTE-USE]]
=== Использование атрибутов обработки
footnote:[http://www.w3.org/TR/xmlschema-1/#cAttributeUse]

Компонент "использование атрибута" (_Attribute use_, в классе Xerces [.class]`XSAttributeUse`) является вспомогательным,
который управляет появлением и поведением по умолчанию объявлений атрибутов.
Для объявления атрибута он выполняет аналогичную роль в сложном типе, как частица (_Particle_) для объявления элемента.

Метод [.method]`processAttributeUse`([.class]`XSAttributeUse`[.parameter]`attributeUse`)
используется для обработки задействия атрибута, а также самого объявления атрибута:

. На этом этапе будет обработана декларация атрибута [<<PROCESS-ATTRIBUTE-DECLARATION>>].


[[PROCESS-ATTRIBUTE-DECLARATION]]
=== Обработка объявлений атрибутов
footnote:[http://www.w3.org/TR/xmlschema-1/#cAttribute_Declarations]

Декларация атрибута (_Attribute declaration_, v Xercesu třída [.class]`XSAttributeDeclaration`) позволяет:

* локальная проверка значений элементов атрибутивной информации с использованием простых определений типов;
* указание значений по умолчанию или фиксированных значений для элемента атрибутивной информации.

Для простоты декларация атрибута обрабатывается внутри метода
[.method]`processAttributeUse`([.class]`XSAttributeUse`[.parameter]`attributeUse`) [<<PROCESS-ATTRIBUTE-USE>>].

. Символ <<SYMBOL-ATTRIBUTE>> создается и присоединяется к древовидной структуре.
    Перед этим необходимо найти основную информацию, предоставленную непосредственно декларацией атрибута,
    а также дополнительная информация о типе атрибута, полученная при вызове вспомогательного метода
    [.method]`getTypeString`([.parameter]`typeDefinition`) [<<PROCESS-SIMPLE-TYPE>>].
   Описание каждого элемента можно найти в графическом оформлении символа `attribute`.


[[PROCESS-WILDCARD]]
=== Обработка подстановочного символа
footnote:[http://www.w3.org/TR/xmlschema-1/#Wildcards]

Подстановочный знак (_Wildcard_, v Xercesu třída [.class]`XSWildcard`)
позволяет проверять элементы информации об элементах и атрибутах в зависимости от пространства имен, но независимо от локального имени.

Метод [.method]`processElementWildcard`([.class]`XSWildcard`[.parameter]`wildcard`,
[.class]`String`[.parameter]`cardinality`) используется для обработки карты для элемента:

. Создает символ <<SYMBOL-ANY>> и прикрепляет его к соответствующей позиции в древовидной структуре.
    Вспомогательный метод [.method]`getNamespaceString`([.class]`XSWildcard`[.parameter]`wildcard`)
    позволяет построить строку, указывающую на ограничения пространства имен,
    параметр `cardinality` предоставляет информацию о минимальном и максимальном количестве вхождений.

Метод [.method]`processAttributeWildcard`([.class]`XSWildcard`[.parameter]`wildcard`)
используйте для обработки подстановочного символа для атрибута:

. Создает символ <<SYMBOL-ANY-ATTRIBUTE>> и прикрепляет его к соответствующей позиции в древовидной структуре.
    Вспомогательный метод [.method]`getNamespaceString`([.class]`XSWildcard`[.parameter]`wildcard`)
    позволяет построить строку, указывающую на ограничения пространств имен.


[[PROCESS-SIMPLE-TYPE]]
=== Обработка определения простого типа
footnote:[http://www.w3.org/TR/xmlschema-1/#Simple_Type_Definitions]

Определение простого типа (_Simple type definition_, в классе Xerces [.class]`XSSimpleTypeDefinition`)
допускает ограничение символьных информационных элементов – дочерних элементов элемента и атрибута информационных элементов.

Вспомогательный метод [.method]`getTypeString`([.class]`XSTypeDefinition`[.parameter]`typeDefinition`)
вызывается при обработке объявлений элементов и атрибутов.
Для простого типа вам нужно только найти имя или имя базового типа и отобразить его как тип элемента / атрибута.

. Если тип имеет имя (оно может быть сложным), он возвращает имя типа.
. Если тип является анонимным и простым, он возвращает имя базового типа, из которого он получен.
. В противном случае возвращает `null`.


[[PROCESS-COMPLEX-TYPE]]
=== Обработка определения комплексного типа
footnote:[http://www.w3.org/TR/xmlschema-1/#Complex_Type_Definitions]

Определение сложного типа (_Complex type definition_, в классе Xerces [.class]`XSComplexTypeDefinition`) позволяет:

* ограничение элементов информационных элементов, добавление объявлений атрибутов, указание вхождения и содержания атрибутов;
* ограничивает элементы информации об элементах таким образом, чтобы они либо имели пустое содержимое, либо соответствовали заданному
    содержимому, смешанному или состоящему только из элементов; или ограничивает элементы информации о символах,
    чтобы они соответствовали заданному определению простого типа;
* использование механизма иерархии определений типов (_Type definition hierarchy_)
    для получения сложного типа из другого простого или сложного типа;
* спецификация вклада в инфосеть элементов после проверки схемы;
* ограничение возможности получения других типов из этого сложного типа;
* управление заменой элементов производного типа элементами, 
    объявленными в содержательной модели этого сложного типа.

Определение сложного типа обрабатывается методом [.method]`processComplexTypeDefinition`
    ([.class]`XSComplexTypeDefinition`[.parameter]`complexTypeDefinition`).

. Он определяет, содержит ли определение частицу (_Particle_), если да, то вызывается метод
    [.method]`processParticle`([.parameter]`particle`) [<<PROCESS-PARTICLE>>].
    Параметр-это частица, полученная из определения сложного типа.
. Этот параметр [.method]`processAttributeUses`([.parameter]`attributeUses`) [<<PROCESS-ATTRIBUTE-USES>>],
    является коллекцией использования атрибутов.
.  Если для атрибутов определен подстановочный знак (_Wildcard_) то вызывается метод [.method]`processAttributeWildcard`
    ([.parameter]`wildcard`) [<<PROCESS-WILDCARD>>]. Параметр-это подстановочный знак, полученный из определения сложного типа.


[[PROCESS-IDENTITY-CONSTRAINTS]]
=== Обработка набора ограничений идентичности

Коллекция объявлений ограничений идентичности (включенная в класс Xerces [.class]`XSNamedMap`).

Метод [.method]`processIdentityConstraints`([.class]`XSNamedMap`[.parameter]`identityConstraints`)
выполняет обработку деклараций об ограничении идентификации. Метод включает в себя цикл.

. Совершает обход коллекции:

.. Для каждого элемента коллекции вызывается метод [.method]`processIdentityConstraintDefinition`
    ([.parameter]`identityConstraintDefinition`) [<<PROCESS-IDENTITY-CONSTRAINT>>].
    Параметр представляет собой конкретное определение ограничения идентичности (_Identity-constraint definition_).


[[PROCESS-IDENTITY-CONSTRAINT]]
=== Обработка определения ограничения идентичности
footnote:[http://www.w3.org/TR/xmlschema-1/#cIdentity-constraint_Definitions]

Определение ограничения идентичности (_Identity-constraint definition_, в классе Xerces [.class]`XSIDCDefinition`)
обеспечивает уникальность и ссылочное ограничение в пределах значений набора элементов и атрибутов.

Метод [.method]`processIdentityConstraintDefinition`
([.class]`XSIDCDefinition`[.parameter]`identityConstraintDefinition`)
отвечает за обработку определения ограничения идентичности.

. Идентефицируется категория этого определения:
.. Если найден уникального ключа (`unique`), то создается символ <<SYMBOL-UNIQUE>>.
.. Если найден первичного ключа (`key`), то создается символ <<SYMBOL-KEY>>.
.. Если найден внешнего ключа (`keyref`), то создается символ <<SYMBOL-KEYREF>>.

. Cоздается символ <<SYMBOL-SELECTOR>>.

. Обходит коллекцию полей (`field`):
.. Для каждого элемента коллекции создается символ <<SYMBOL-FIELD>>.

Необходимая информация для изображения всех символов предоставляется непосредственно объектом [.parameter]`identityConstraintDefinition`.
Их перечень можно найти в предложении отдельных символов.
Каждый из символов привязан к соответствующему месту древовидной структуры.

[[PROCESS-PARTICLES]]
=== Обработка коллекции частиц

Коллекция частиц (в Xercesu выделенных общим классом [.class]`XSObjectList`).

Метод [.method]`processParticles`([.class]`XSObjectList`[.parameter]`particles`) осуществляет обработку коллекции частиц.
Метод включает в себя цикл:

. Совершает обход коллекции:

.. Для каждого элемента коллекции вызывается [.method]`processParticle`([.parameter]`particle`) [<<PROCESS-PARTICLE>>].
    Параметр-это конкретная частица (_Particle_).


[[PROCESS-PARTICLE]]
=== Обработка частиц
footnote:[http://www.w3.org/TR/xmlschema-1/#cParticles]

Частица (_Particle_, в классе Xerces [.class]`XSParticle`)  добавляет дополнительную информацию о минимальном и
максимальном количестве вхождений в определение модели содержимого.

Метод [.method]`processParticle`([.class]`XSParticle`[.parameter]`particle`) обрабатывает частицу следующим образом:

. Вспомогательный метод [.method]`getCardinalityString`([.class]`XSParticle`[.parameter]`particle`)
    компилирует строку `cardinality`, содержащую информацию о минимуме ([.property]`minOccurs`)
    и максимальном ([.property]`maxOccurs`) числе вхождений обернутого частицей термина ([.property]`term`).
. Вызывает вспомогательный метод [.method]`processTerm`([.parameter]`term`, [.parameter]`cardinality`) [<<PROCESS-TERM>>],
    который обрабатывает термин и отправляет ему строку `cardinality`.


[[PROCESS-TERM]]
=== Тремин обработка

Термин (_Term_, v Xercesu třída [.class]`XSTerm`) это универсальное свойство, представляющее группу моделей,
объявление элемента или подстановочный знак для элементов.

Метод [.method]`processTerm`([.class]`XSTerm`[.parameter]`term`, [.class]`String`[.parameter]`cardinality`)
выполняет следующий алгоритм:

. Установка типа термина:

.. Если это группа моделей (_Model group_), то вызывается метод
    [.method]`processModelGroup`([.parameter]`modelGroup`, [.parameter]`cardinality`) [<<_process_model_group>>].
    Первый параметр-это термин - группа моделей, второй параметр передает информацию о мощности.

.. Если это объявление элемента (_Element declaration_), то оно называется [.method]`processElementDeclaration`
    ([.parameter]`elementDeclaration`, [.parameter]`cardinality`) [<<PROCESS-ELEMENT-DECLARATION>>].
    Первый параметр-это термин-декларация элемента, второй параметр передает информацию о мощности.

..  Если это wild card (_Wildcard_) для элементов, то метод называется [.method]`processElementWildcard`
    ([.parameter]`wildcard`, [.parameter]`cardinality`) [<<PROCESS-WILDCARD>>].
    Первый параметр-это термин-wild card, второй параметр передает информацию о мощности.


[[_process_model_group]]
=== Обработка группы моделей
footnote:[http://www.w3.org/TR/xmlschema-1/#Model_Groups]

Модельная группа (_Model group_, v Xercesu třída [.class]`XSModelGroup`).
Если не определено, что дочерние элементы информационного элемента элемента должны быть пустыми
или соответствуют простому определению типа, содержимое дочерних элементов последовательности информационного элемента элемента может быть
более подробно указано с помощью группы моделей.
Из-за того, что часть частицы может быть модельной группой, а модельная группа содержит частицы,
группа моделей может косвенно содержать другие группы моделей.

Метод [.method]`processModelGroup`([.class]`XSModelGroup`[.parameter]`modelGroup`,
[.class]`String`[.parameter]`cardinality`) выполняет алгоритм:

. Найти тип композитора ([.property]`compositor`):

.. Если это составное `all`, то создается символ <<SYMBOL-ALL>>.
.. Что касается `choice`, то создается символ <<SYMBOL-CHOICE>>.
.. В противном случае `sequence`, то создается символ <<SYMBOL-SEQUENCE>>.

. Вспомогательный метод [.method]`processParticles`([.parameter]`particles`)
    [<<PROCESS-PARTICLES>>], параметр-это совокупность частиц, содержащихся в модельной группе.

Для каждого из символов будет напечатана строка "мощности" с информацией о минимальном и максимальном количестве вхождений.
Созданный символ всегда прикрепляется к соответствующей позиции древовидной структуры.

[float]
==== Окончательное хранение готовой конструкции в SVG

После того, как абстрактная модель данных XML-схемы закончена и подготовленные символы образуют древовидную структуру,
дерево сохраняется в SVG-файл.
Сначала пишется заголовок с XML-декларацией, тип документа, заголовок, добавляется скрипт, предопределенные символы и, при необходимости, стиль;
затем добавляются отдельные символы компонентов.
Корректный процесс выглядит как установка корневого символа, установка правильных размеров и расположения на воображаемом холсте
и это сохраняется, то же самое затем повторяется со всеми детьми и их потомством, пока не появятся листья дерева.
Ими являются символы, вложенные в документ, за которыми следует только конечный тег `<svg>`

== Вывод

Целью работы была разработка и реализация приложения для преобразования XML-схемы в интерактивную диаграмму в формате SVG.
Поэтому было необходимо изучить принципы, на которых основана спецификация XML-схемы W3C.
Последнее сильно отделяет абстрактную модель данных от представления XML.
Именно абстрактная модель данных, ее компоненты и свойства компонентов обеспечивают прямой и легкий доступ к важным данным.
Чтобы не пришлось программировать все с нуля, я выбрал среди готовых реализаций модели с открытым исходным кодом и подобрал
процессор, который является частью парсера Xerces.
Последний соответствует спецификации; он сделал компоненты схемы и их структуры доступными для ресурсов Java-программ.

Далее необходимо было выбрать подходящий способ отображения структур, определенных схемой.
Здесь меня вдохновили результаты успешного XML - редактора oXygen.
Из идеи графической модели возникло оформление классов объектов – общего абстрактного символа и специфических символов
компоненты схемы - дизайн их внешнего вида, параметры, взаимосвязь и привязка для обеспечения интерактивности модели.
В то же время необходимо было хотя бы в общих чертах знать возможности формата SVG.

Когда экземпляр XML-схемы загружается в представление объекта Java, он начинает просматривать эти объекты и
начинает формироваться древовидная структура определенных символов.
В конечном итоге это сохраняется в файле SVG.
Но другие технологии все еще привязаны к нему.
Прежде всего, это ECMAScript, который является частью файла и выполняет его обработку при открытии в браузере.
Он обеспечивает интерактивность, реагируя на события, вызванные перемещением и щелчком мыши.
Для того чтобы скрипт мог работать с SVG-элементами документа, ему необходимо получить к ним доступ.
Доступ осуществляется через DOM 2-го уровня.
Новейшая технология-это каскадные стили, которые могут быть частью SVG-файла или могут быть подключены из
внешнего файла и разрешать незначительные корректировки полученного внешнего вида.

В заключение могу сказать, что цель работы была достигнута.
Практический продукт-это функциональная программа, выход которой представляет собой четкую интерактивную диаграмму, показывающую
структуру XML-файлов соответствующую схеме.
В частности, это структура используемых элементов и атрибутов, их имена, пространства имен, типы данных,
мощность элементов, определенные ключи и т. д.
Символы могут отображаться и скрываться.
На мой взгляд, схема действительно может облегчить ориентацию и понимание структур, она может стать качественным дополнением к документации.

Однако и здесь есть некоторые ограничения.
Первый возникает из-за медленной реализации SVG и ECMAScript в браузерах.
Это проявляется в более медленной реакции на события и, в общем, в более медленном отображении больших диаграмм.
В этой области можно только надеяться на лучшую поддержку в будущем.
Другая проблема может возникнуть при программировании схем, описывающих очень большие структуры.
Приложение может выйти из строя из-за превышения объема памяти.
Эту проблему можно решить, изменив приложение, но из-за первого ограничения спешить с модификацией не стоит.

Это подводит меня к тому, что приложение, включая исходный код, будет распространяться как свободное программное обеспечение.
В настоящее время он доступен на прилагаемом компакт-диске (viz <<_CD>>) и на веб-сайте http://st.vse.cz/~XSLAV14/.
Это дает возможность дальнейшего развития приложения в виде доработок или расширения функционала.
Например, можно было бы выделить кнопки для увеличения и уменьшения масштаба; расширить программу с поддержкой других схематических языков
(насколько я знаю, их визуализация является предметом других бакалаврских диссертаций);
или интегрировать в систему для создания полной документации.

:sectnums!:

[bibliography]
==  Литература   

[bibliography]
[float]
=== Главное
- [[[XSD0,1]]] Фоллсайд, Д. К., Уолмсли, П. a kol.:
    _XML Schema Part 0: Primer Second Edition_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xmlschema-0/

- [[[XSD1,2]]] Томпсон, Х. С., Бук, Д., Малони, M., Мендельсон, N. a kol.:
    _XML Schema Part 1: Structures Second Edition_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xmlschema-1/

- [[[XSD2,3]]] Бирон, П. В., Малхотра, А. a kol.:
    _XML Schema Part 2: Datatypes Second Edition_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xmlschema-2/

- [[[XSD-VLIST,4]]] ван дер Влист, Е.:
    _Using W3C XML Schema. XML.com, 2001._
    Доступно с сайта: http://www.xml.com/pub/a/2000/11/29/schemas/part1.html?page=1

- [[[SVG,5]]] Феррайоло, Дж., Фудзисава, Дж., Джексон, Д.: 
    _Scalable Vector Graphics (SVG) 1.1 Specification_
    [online]. W3C, 2003. Доступно с сайта: http://www.w3.org/TR/SVG/

[bibliography]

[float]
=== Вторичные и дополнительные
- [[[XML,6]]] Брей, Т., Паоли, Дж., Сперберг-Маккуин, С. М., Малер Э., Йерго, Ф. a kol.:
    _Extensible Markup Language (XML) 1.0 (Fourth Edition)_
    [online]. W3C, 2006. Доступно с сайта: http://www.w3.org/TR/REC-xml/

- [[[INFOSET,7]]] Коуэн, Дж., Тобин, Р.:
    _XML Information Set (Second Edition)_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xml-infoset/

- [[[NAMESPACE,8]]] Брэй, Т., Холландер, Д., Лейман, А., Тобин, Р.:
    _Namespaces in XML 1.0 (Second Edition)_
    [online]. W3C, 2006. Доступно с сайта: http://www.w3.org/TR/REC-xml-names/

- [[[DOM1,9]]] Вуд, Л. a kol.:
    _Document Object Model (DOM) Level 1 Specification_
    [online]. W3C, 1998. Доступно с сайта: http://www.w3.org/TR/REC-DOM-Level-1/

- [[[DOM2,10]]] Вуд, Л. a kol.:
    _Document Object Model (DOM) Level 2 Core Specification_
    [online]. W3C, 2000. Доступно с сайта: http://www.w3.org/TR/DOM-Level-2-Core/

- [[[CSS,11]]] Лие Х. В., Бос, Б.:
    _Cascading Style Sheets, level 1_
    [online]. W3C, 1996. Доступно с сайта: http://www.w3.org/TR/CSS1/

- [[[M254,12]]] Холл, У., Кейнс, М.:
итм    _M254 Java everywhere_
    [online]. The Open University, 2005. Доступно с сайта: http://computing.open.ac.uk/m254/

:sectnums:

:sectnums!:

[appendix]
== Термины
[glossary]
API:: Application Programming Interface,
    интерфейс прикладных программ. Набор процедур, функций или классов
    конкретная библиотека, программа или ядро операционной системы, которые могут
    быть использованным в приложениях.

CSS:: Cascading Style Sheets, каскадные стили.
    Простой механизм добавления графического редактирования в сеть
    докуранты. Стандарт W3C, в частности, в <<CSS>>.

Data binding:: Конвертируемые данные между различными форматами. Например, между XML-документами,
    объекты объектно-ориентированных систем и реляционные таблицы
    систем баз данных.

DOM:: Document Object Model, объектная модель
    документов. Независимый от платформы и языка интерфейс, который позволяет
    программам и скриптам динамического доступа к контенту, структуре и стилю
    документа, и его редактирование. Обеспечивает объектно-ориентированное
    представление документа XML или HTML. Спецификации W3C в <<DOM1>>, <<DOM2>> и др.

DTD:: Document Type Definition, определение типа
    документа. DTD предоставляет инструменты для определения разрешенных структур
    элементов и атрибутов, позволяющих устанавливать значения атрибутов по умолчанию. 
    Повторно используемое содержимое также может быть определено в DTD
    (entity) и дополнительная информация (notace). Спецификация 
    является частью рекомендации W3C по XML – <<XML>> и
    другие.

ECMAScript:: Язык сценариев (программирования), стандартизированный организацией
    Ecma International в спецификации
    ECMA-262. Он широко используется в интернете и часто
    упоминается как JavaScript или JScript, в соответствии с основными
    диалектами этого языка.

Framework:: Базовая концептуальная структура, используемая для решения или фокусировки
    внимания на сложных проблемах. В области программного обеспечения это часто
    библиотеки, вспомогательные программы, шаблоны проектирования и лучшие практики.
    Фреймворк решает типичные задачи, которые идентичны в большинстве приложений,
    что облегчает разработку.

HTML:: HyperText Markup Language, язык
    разметки гиперссылок. Язык для создания сайтов, приложений SGML.
    Спецификация была выпущена организацией W3C.

Информационный элемент:: Information item. Представляет узел
    древовидной структуры XML infosetu. Спецификация <<INFOSET>> определяет одиннадцать различных типов элементов. Каждый
    из них имеет определенные свойства, такие как родительский элемент, локальное имя и т. д.
    В этой работе я упоминаю информационный элемент персонажа, 
    атрибут информационного элемента.

Infoset:: XML Information Set это абстрактная модель
    данных XML документа, состоящая из отдельных информационных элементов.
    Спецификация W3C <<infoset>>.

Java:: Объектно-ориентированный, строго наборный, платформенно-независимый
    язык программирования от Sun Microsystems.

Namespace:: Пространство имен. XML обеспечивает простой метод для
    квалификация наименований элементов и атрибутов путем их включения в в пространство имен
    с идентификатором URI. Спецификация W3C <<NAMESPACE>>.

Разбор:: Анализ представленных данных и поиск элементов,
    соответствующих определению того или иного языка. Обычно это синтаксический анализ
    исходных кодов, написанных на заданном языке программирования.

PSVI:: Post Schema Validation Infoset, информационный пакет (инфосеть?)
    после проверки документа по схеме. Это информационный набор XML - документов,
    дополненный информацией о типах элементов данных. Вклады PSVI
    определяются в спецификации XML-схемы <<XSD1>>
    и < < xsd2>>.

Визуализация:: Рендеринг-процесс, с помощью которого
    изображение визуализируется из введенных данных.

SAX:: Simple API for XML, простой интерфейс
    приложения для XML. Предоставляет механизм для чтения данных из XML
    документов. Чтение происходит последовательно и основано на событиях
    (чтение начального тега, чтение конечного тега и т. д.). Поэтому
    модификация структуры документа, в отличие от Dom, невозможна.

SVG:: Scalable Vector Graphics, масштабируемая
    векторная графика. SVG-это язык для описания двумерной графики и
    графических приложений с использованием XML. Разработка основана на спецификации SVG
    1.1, выпущенной в качестве рекомендации консорциума W3C 14. 1 января 2003 года <<SVG>>.

Tag:: Метка, определяющая начало и/или конец элемента.

Validace:: Верификация XML-документа в соответствии со схемой.

W3C:: World Wide Web Consortium. Она занимается
    разработкой совместимых технологий-спецификаций, руководств,
    программного обеспечения и инструментов с целью унификации используемых технологий
    и достижения полного развития и использования возможностей интернета.

XHTML:: Extensible HyperText Markup Language,
    расширяемый язык разметки гипертекста. Язык для создания 
    веб-страниц, xml-приложений. Спецификация была выпущена организацией
    W3C.

XML:: Extensible Markup Language, расширяемый
    язык разметки. Позволяет разработчикам создавать пользовательские форматы хранения и обмена данными.
    Спецификация была опубликована консорциумом W3C, <<XML>> и другими.

XML schéma:: XML-схемы предоставляют средства для определения структуры,
    содержания и семантики XML-документов. Xml-схема была одобрена в качестве
    рекомендации W3C 2 мая 2001 года, а вторая, измененная версия
    была выпущена 28 октября 2004 года <<XSD0>>, <<XSD1>>, <<XSD2>>.


:sectnums:

:sectnums!:

[appendix]
[[_CD]]
== Содержимое компакт-диска

Эта работа включает в себя прилагаемый компакт-диск с текстом работы, исходные коды и готовое приложение.
Последняя версия будет доступна по адресу: http://st.vse.cz/~XSLAV14/.
В частности, на компакт-диске вы найдете следующую структуру каталогов и файлов:

. [.path]_/thesis_ – справочник, связанный с написанием бакалаврской диссертации, содержит:
** [.path]_/images_ – папку используемых изображений за исключением символов компонентов схемы
** [.path]_/symbols_ – папку с изображениями символов компонентов схемы в формате SVG
** [.path]_thesis.xml_ – пользовательский текст работы в формате DocBook
** [.path]_thesis.xsl_, [.path]_tp-fo.xsl_ – стили, изменяющие стандартный вывод DocBook
** [.path]_kizi.pdf_ – логотип отдела для первой страницы footnote:[Измененные стили и логотип кафедры взяты с сайта Иржи Коска, посвященного обучению в ВШЭ: http://www.kosek.cz/vyuka/]
** [.path]_thesis.pdf_ – сгенерированный PDF файл с этой работой
. [.path]_/src_ – Каталог исходного кода Java, структура которого основана на включении классов в пакеты
. [.path]_/res_ – каталог других ресурсов, содержащих:
** [.path]_/examples_ – папку с примерами XSD-входов
** [.path]_/licenses_ – лицензионную папку Xerces 
** [.path]_readme.txt_ – текстовый документ, описывающий пользовательский интерфейс
. [.path]_/lib_ – каталог содержащий реализацию парсера Xerces – [.path]_xercesImpl.jar_
. [.path]_/dist_ – папка с готовым к использованию приложением содержит:
** [.path]_/examples_ – скопировано из каталога [.path]_/res_
** [.path]_/licenses_ – скопировано из каталога [.path]_/res_
** [.path]_/lib_ – библиотечный каталог:
... копия файла [.path]_xercesImpl.jar_ и любые другие файлы из каталога [.path]_/lib_
... архив с приложением [.path]_xsdvi.jar_
** [.path]EXAMPLES.bat_ – запуск преобразования примеров, схем из папки examples_
** [.path]_readme.txt_ – скопировано из каталога [.path]_/res_
. [.path]_build.properties_ – настройку свойств, используемых в [.path]_build.xml_
. [.path]_build.xml_ – XML скрипт для программы сборки Ant


:sectnums:

:sectnums!:

[appendix]
[[EXAMPLES]]
== Пример

=== XML schema – пример входных данных

[source, xml]
----
include::examples/ContactEntity.xsd[]
----

[[EXAMPLES-SVG-XML]]
=== выходные данные SVG  (XML представления)

[source, xml]
----
include::examples/ContactEntityOutputSVG.xml[]
----

=== выходные данные SVG (графическое представление)

[[MY-MODEL-APPENDIX]]
.Графический вывод
image::images/model_my.svg[]


:sectnums:

