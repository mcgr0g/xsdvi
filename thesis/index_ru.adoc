= Визуализация XML схемы
Václav Slavětínský <https://sourceforge.net/u/vaclaforge/profile/>;
květen 2008
:doctype: book
:sectnums:
:toc: left
:toclevels: 4
:icons: font
:experimental:

== Введение

XML позволяет разработчикам создавать собственные форматы для хранения и обмена данными, следуя правилам синтаксиса.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное объявление и документация,
то есть описание, которое позволит им обмениваться, определяться и использоваться. Для этого было разработано несколько языков.
К ним относятся W3C _XML schema_, DTD (_Document Type Definition_) и Oasis _Relax NG_.

Благодаря интеграции с другими стандартами на основе XML, а также широким возможностям и поддержке крупных компаний-разработчиков программного обеспечения - часто используют схему XML.
Однако его спецификация (см. <<XSD1>>, <<XSD2>>) довольно сложна, и схемы могут стать запутанными для пользователя.
Причиной этого являются различные возможности написания, вытекающие из объектных элементов этого языка.
Схема XML позволяет использовать, расширять и ограничивать типы данных;
создание ссылок на элементы, атрибуты и группы элементов или атрибутов;
элементы могут быть заменены механизмом групп замещения;
также можно импортировать, вставлять и переопределять внешние схемы или их части.

Тема данной работы - визуализация XML-схем.
Цель состоит в том, чтобы спроектировать и реализовать приложение, которое на входе получит экземпляр XML-схемы W3C, а на выходе бы
сохранила свое интерактивное графическое представление в формате SVG (_Scalable Vector Graphics_) <<SVG>>.
Это графическое представление или диаграмма могут использоваться как часть документации, соответствующей схеме XML.
На диаграмме будут показаны структуры используемых элементов и атрибутов, их имена, пространства имен,
типы данных и дополнительная информация - количество элементов, обязательное / необязательное использование атрибутов, определенные уникальные, первичные и внешние ключи и т. д.
Это также позволит просматривать структуры, открывать и скрывать подгруппы элементов и атрибутов, используя _ECMAScript_.
Важными требованиями являются то, чтобы графика была интерактивной, интуитивно понятной и понятной,
потому что целью работы является главным образом облегчить ориентацию и понимание XML-схем их пользователями - создателями XML-документов.

Файлы SVG можно открывать в современных веб-браузерах (для некоторых необходимо установить плагин SVG)
или в приложениях, предназначенных для просмотра или редактирования векторной графики.
Многие из них находятся в свободном доступе. Векторная графика использует геометрические объекты для представления изображений, что облегчает программное редактирование.
Однако некоторые ограничения возникают из-за сложности обработки и медленной реализации ECMAScript в браузерах.
Это становится очевидным в больших схемах, точнее в больших структурах описанных документов.
(большие структуры могут быть определены даже с относительно короткой схемой).
Ограничение отражается в более медленной реакции на события и, как правило, в более медленном построении диаграммы.
В этой области мы можем только надеяться на лучшую поддержку в будущем.

Само приложение будет написано на языке программирования Java и будет использовать пакеты синтаксического анализатора _Xerces_,
которая является реализацией интерфейса с открытым исходным кодом, определенного в <<XSD1>> и <<XSD2>>.
Для запуска вам необходимо установить среду исполнения _Java Runtime Environment_.
Сегодня, однако, JRE является общей частью большинства компьютеров.
С помощью Java приложение может быть легко перенесено на разные платформы.

Позвольте мне кратко упомянуть структуру работы.
Цель второй главы - познакомить читателя с технологиями, используемыми в приложении, и способами их использования.
К ним относятся XML-схема W3C, масштабируемая векторная графика, ECMAScript и объектная модель документа, каскадные таблицы стилей, язык Java.

Специальная глава (третья) посвящена возможностям загрузки и интерпретации модели XML-схемы.
Существует описание нескольких реализаций с открытым исходным кодом абстрактной модели данных XML-схемы и их оценка.
Я наконец выбрал процессор Xerces2-J из этих реализаций.
Он создает основу программы, предоставляя легкий доступ к компонентам схемы и их свойствам.

Четвертая глава посвящена разработке графической модели.
Сначала выбирается соответствующий тип, логическая модель; она четко отображает структуру определенных документов XML.
Ниже приведен анализ отдельных элементов - графических символов компонентов схемы - и их структуры.
Для каждого символа вы найдете изображения, значения и описания параметров, относящиеся к свойствам компонентов схемы.
Описан механизм интерактивности модели и возможность дополнительной модификации внешнего вида с помощью внешнего стиля.

Цель пятой главы - разработать алгоритм обработки схемы.
Вам нужно пройтись по некоторым компонентам и извлечь данные визуализации из их свойств.
Обработка компонентов, значение которых также описано здесь, обеспечивается отдельными методами.
Они вызывают друг друга, обмениваются параметрами и создают графические символы для последующего сохранения в файл SVG.

В заключение постараюсь подвести итоги работы и указать, где можно скачать приложение.

== Используемые технологии

=== XML-схема

XML, _Extensible Markup Language_, расширяемый язык разметки, позволяет разработчикам создавать свои собственные форматы
для хранения и обмена данными. Это создает новые словари пунктов - элементов и их свойств(качеств) - атрибутов.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное информация и документация,
то есть описание, которое позволяет совместно использовать, определять и использовать словари.

_XML схема_
    footnote:[Второе издание датировано 28 октября 2004 г., первое было утверждено 2 мая 2001 г.]
является спецификацией, выпущенной консорциумом W3C.
    footnote:[Консорциум World Wide Web, официальный сайт. http://www.w3.org/]
Определяет объектно-ориентированный язык, который можно использовать для формального описания документов XML;
он предоставляет средства для определения их структуры, содержания и семантики.
В частности, мы можем использовать схему для определения элементов и атрибутов, применимых к документу, включая их структуру - взаимное погружение и совмещение;
мы также можем указать тип данных для содержимого элемента или атрибута, значений по умолчанию и других ограничений целостности.
К ним относятся уникальные ключи (_unique_), первичные ключи (_key_) и внешние ключи (_keyref_), ссылающиеся на них.

Схему XML часто сравнивают с другим распространенным языком схемы - DTD, _Document Type Definition_.
Это уже было включено в спецификацию XML 1.0 W3C <<XML>>.
Наиболее важные различия заключаются в том, что DTD использует свой собственный синтаксис, а схема XML является приложением XML, то есть использует его синтаксис.
Другой причиной выбора схемы XML является возможность назначения типов данных для атрибутов и содержимого элементов.
У DTD не было этого базового свойства, поэтому все значения обрабатывались как текстовые строки.
Также не было возможности работать с пространствами имен.
Однако DTD все еще широко используются, главным образом для простоты.

Спецификация схемы XML и ее нотация XML являются сложными, а в некоторых местах довольно сложными для понимания и использования.
Поэтому были разработаны и другие языки: _Relax NG_ с общим (XML) и компактным синтаксисом и _Schematron_ с другим подходом - для проверки правил.
Однако схема XML имеет самое широкое применение, в том числе и потому, что она поддерживается крупными компаниями-разработчиками программного обеспечения (Microsoft, IBM, Oracle, Sun).

Схема XML формализует ограничения, выраженные в виде правил или структурных моделей, которым соответствует определенный класс документа XML.
Схемы часто служат инструментами проектирования, устанавливая структуру, на которой могут быть построены конкретные реализации.
Существует несколько типичных областей применения схем.
В основном это валидация, документирование, запросы, биндинг данных и редактирование данных <<XSD-VLIST>>:

* _Валидация_ означает проверку XML-документа на соответствие схеме.
    Он часто используется для управления доступом XML к приложению.
    Он действует как фильтр; документы, соответствующие схеме, будут переданы, другие не будут использоваться.
    Это внешнее управление значительно упрощает приложения, которые в противном случае должны были бы обрабатывать многие исключения, встречающиеся в
    обработка неудовлетворительных входных данных XML.

* _Документирование_ означает описание в виде XML-документа.
    Это формально и машиночитаемо. Поскольку схема XML является документом XML,
    формальная документация может быть легко преобразована в удобочитаемую,
    например, используя преобразования XSLT или другие преобразования.
    Также приложение, которое является результатом этой дипломной работы бакалавра, выполняет такое преобразование в изображение

* Схемы обеспечивают поддержку _query_, поиск содержимого в документах XML.
    Это можно сделать без них, кроме дополнительной информации о структуре и типах данных
    поможет ускорить и упростить поиск и сортировку и сопоставление.
    Использование можно найти на языках _XPath 2.0_, _XSLT 2.0_, _XQuery 1.0_.

* XML-схемы используются с самого начала для _биндинга данных_.
    Это означает преобразование данных, содержащихся в документах XML, в структуры конкретных приложений,
    такие как объекты в объектно-ориентированных системах и реляционные таблицы систем реляционных баз данных.
    Схемы предоставляют дополнительную информацию о типах данных, которые преобразуются в типы данных приложения.

* Как правило, схемы обычно используют для _редактирования_ XML-документов. Например, эта работа взята из _DocBook_,
    который также является применением XML. Редактор, который я использую, дает мне выбор элементов,
    которые допустимы на месте согласно схеме. Это значительно облегчает работу.
    Редактор использует DTD DocBook, предоставляя информацию о структуре,
    Кроме того, схемы XML предоставляют информацию о типах данных.


[float]
==== Компоненты схемы

Процессор схемы XML, соответствующие спецификации W3C <<XSD1>>,
должен работать с информацией, содержащейся в диаграмме, как описано в спецификации.
Схема XML рассматривается здесь как абстрактная модель данных концептуального уровня, независимая от реализации.
Модель данных состоит из отдельных, точно определенных компонентов – _komponent_.
Каждый из них включает в себя описание представления  XML, свойства и ограничения, описание правил проверки,
обращения к PSVI (_Post Schema Validation Infoset_),
    footnote:[Это XML infoset (набор информации), дополнен дополнительной информацией о типе отдельных пунктов – элементов,
        атрибутов, обычных узлов.]
и любые встроенные экземпляры этих компонентов.

Определение следующее:
    "`_Компонент схемы_ - это общий термин, который представляет строительные элементы
      составляющие модель данных абстрактной схемы... _XML Схема_ - это набор компонентов схемы.`"
    footnote:[XML Schema Abstract Data Model. http://www.w3.org/TR/xmlschema-1/#concepts-data-model]

Существует 13 видов компонентов, которые можно разделить на 3 группы.
_Приложение будет работать с ними, как описано в главе <<XSD-PROCESSING>>._
Чтобы быстро понять отношения между компонентами, используйте диаграмму <<DIAGRAM_KOMPONENT>>.
    footnote:[там же.]

[[DIAGRAM_KOMPONENT]]
.Диаграмма компонент XML схемы
image::images/components.gif[]

Первичные компоненты могут или должны быть названы:

* определение простых типов (_Simple type definitions_),
* определение сложных типов (_Complex type definitions_),
* декларирование атрибута (_Attribute declarations_),
* декларирование элемента (_Element declarations_).

Вторичные компоненты должны именоваться:

* определение групп атрибутов (_Attribute group definitions_),
* определение ограничений идентичности (_Identity-constraint definitions_),
* определение группы моделей (_Model group definitions_),
* декларирование нотации (_Notation declarations_).

Вспомогательные компоненты обеспечивают доступ к другим компонентам. Они зависят от контекста:

* аннотирование (_Annotations_),
* модельные группы (_Model groups_),
* гранулы (_Particles_),
* символы подстановки (_Wildcards_),
* использование атрибутов (_Attribute Uses_).


=== SVG

_Scalable Vector Graphics_, Масштабируемая векторная графика была создана на основе консорциума W3C.
Спецификации составляют основу разработки SVG 1.1 <<SVG>>.
Помимо нее, однако, есть много других:
_SVG Tiny 1.2_,
_SVG Mobile 1.1_,
_SVG Print_,
_SVG Filters_,
_SVG Requirements_.
Их тематика - это язык для описания двумерной графики и графических приложений с использованием XML.
Это векторная графика, которая использует геометрические объекты для представления изображений.
Это дает возможность масштабирования - уменьшения и увеличения - без потери качества;
объекты, составляющие изображение, различаются, и полученные файлы обычно занимают меньше места, чем файлы растровых изображений.
Само собой разумеется, что векторная графика подходит только для некоторых типов изображений, таких как символы, диаграммы или графики.
_Результатом исполнения приложения, которое является предметом этой работы, будет диаграмма схемы XML в SVG._

Формат SVG был разработан главным образом для использования в Интернете,
в наши дни это делает его возможным открыть прямо в браузерах Mozilla Firefox, Opera;
в MS Internet Explorer к сожалению, после установки соответствующего плагина (Adobe SVG Viewer).
Формат также поддерживается в коммерческих (Adobe Illustrator, CorelDraw) и open source (Inkscape, Sodipodi) редакторов.

SVG предоставляет три типа графических объектов.
Это векторные графические фигуры, такие как контуры, состоящие из линий и кривых, изображений и текста.
Эти объекты можно группировать, преобразовывать, предварительно отображать и назначать стили.
Другие функции включают в себя вложенные преобразования, обрезание объектов по путям,
альфа-маскирование, фильтрацию изображений и шаблоны объектов.

Получающиеся изображения могут быть интерактивными и динамическими.
Анимации могут быть определены и выполнены декларативно с использованием специальных элементов SVG или скриптов.
Все элементы, атрибуты и свойства доступны для скриптовых языков через SVG _Document Object Model_ (DOM).
K любому графическому объекту могут быть назначены разные обработчики событий, такие как onmouseover, onclick.
footnote:[Наведение курсора мыши.]

Кроме того, SVG может быть встроен в другие форматы XML с использованием технологии пространства имен (_namespace_).
Совместимость также обеспечивается в том смысле, что скрипты могут выполняться, например, на XHTML
(_Extensible HyperText Markup Language_) веб-странице, на которой были вставлены элементы SVG.
Точно так же легко использовать каскадные таблицы стилей (_Cascading Style Sheets_, CSS) для описания внешнего вида отдельных объектов.

[float]
==== Элементы, используемые в выходных данных приложения

Ниже приведено краткое описание элементов SVG, используемых приложением для графического представления схемы.
Элементы также содержат некоторые важные атрибуты.
Кроме того, необходимы общие атрибуты: [.property]`id` для уникальной идентификации элемента в документе и [.property]`class` назначения элемента определенной группе, которой затем может быть назначен стиль.
Пример конкретного приложения можно найти во вложении <<EXAMPLES-SVG-XML>>.

==== <svg>
footnote:[http://www.w3.org/TR/SVG11/struct.html#NewDocument]

Фрагмент документа SVG состоит из любого количества элементов SVG, заключенных в тег `<svg>`
В нашем случае это будет не фрагмент, а отдельный документ, корневым элементом которого будет `<svg>`
Кроме обычных атрибутов ([.property]`id`, [.property]`class`) здесь они будут:

* [.property]`xmlns` – декларация пространства имен,
* [.property]`onload` – запускает скрипт, когда этот элемент загружен.


==== <title>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DescriptionAndTitleElements]

Заголовок, короткая подпись может быть добавлена к каждому контейнеру или графическому элементу.
Он не будет отображаться напрямую, но может отображаться как _tooltip_.
Заголовок, добавленный `<svg>` элементом, отображается браузером в строке заголовка.

==== <script>
footnote:[http://www.w3.org/TR/SVG11/script.html#ScriptElement]

Используется для вставки скрипта, будет включен как дочерний элемент для `<svg>` элемента.
Сам скрипт должен быть обернут секцией `<![CDATA[ skript ]]>`,
что бы интерпретатор понимал содержимое только как текст и не ищет теги.

* Атрибут [.property]`type` – указывает скриптовый язык, значение MIME типа, в случае ECMAScript -  `text/ecmascript`.

==== <defs>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DefsElement]

Содержит элементы, на которые есть ссылки в документе.
Содержимое может совпадать с контейнером `<g>`, разница в том, что перечисленные здесь графические объекты не будут отображаться напрямую.
Определения в выходных данных приложения включают элемент стиль `<style>` и часто используемые символы `<symbol>`

==== <style>
footnote:[http://www.w3.org/TR/SVG11/styling.html#StyleElement]

Используется для вставки стиля, который описывает расположение объектов и их групп.
Опять же, будет уместно обернуть стиль разделами `<![CDATA[ styl ]]>`

* Атрибут [.property]`type` – указывает язык стиля, значение - MIME-типа,
    footnote:[RFC спецификация 2045: Multipurpose Internet Mail Extensions. http://www.ietf.org/rfc/rfc2045.txt]
    в каскадном стиле `text/css`.


==== <symbol>
footnote:[http://www.w3.org/TR/SVG11/struct.html#SymbolElement]

Символ определяет графический шаблон, который не отображается до тех пор,
пока он не будет использован в документе SVG элементом  `<use>`.
Определение символов имеет смысл для часто используемых объектов.
В этом приложении будет два  – _plus_ и _minus_ для раскрытия и скрытия поддерева графических символов (блоков).
Будут использованы только общие атрибуты.

==== <use>
footnote:[http://www.w3.org/TR/SVG11/struct.html#UseElement]

Относится к другому элементу и указывает, что его графическое содержимое должно быть
включено и отображено там, где находится элемент `<use>` указан.
Среди них могут быть графические элементы, `<g>`, `<svg>`, `<use>` и (в нашем случае только) `<symbol>`.
В дополнение к обычным атрибутам здесь мы используем:

* [.property]`x` – задает координату на оси X, где будет расположен ссылочный объект,
* [.property]`y` – задает координату на оси Y, где будет расположен ссылочный объект,
* [.property]`xlink:href` – URI ссылка на объект, реализованная с использованием идентификатора,
* [.property]`onclick` – запускает скрипт при нажатии на графический объект, который будет _plus_ или _minus_.     Скрипт раскрывает или скрывает поддерево графических символов (блоков).

[[g-container]]
==== <g>
footnote:[http://www.w3.org/TR/SVG11/struct.html#Groups]

Представляет собой контейнер для группировки связанных графических элементов.
Мы будем использовать его для ассоциации SVG элементов формирующих конкретный графический символ компонента схемы (блок).

* Атрибут [.property]`transform` – определяет графическое преобразование контента.
Графика может быть перемещена, масштабирована, повернута и искривлена.
Мы будем перемещать секции только на _x_ единиц по оси X и на _y_ единиц по оси Y, используя
[.property]`transform` = `translate`([.parameter]`x`, [.parameter]`y`).


==== <text>
footnote:[http://www.w3.org/TR/SVG11/text.html#TextElement]

Определяет текстовый графический элемент.
Он отображается с использованием тех же методов, что и другие графические элементы.
Будет использоваться для отображения различных имен, свойств и меток в блоках.
Будут необходимы атрибуты:

* [.property]`x` – представляет абсолютную позицию текста, отсчитанную от первого символа, по оси X.
    Также можно указать несколько (_n_) значений, которые затем представляют позиции первых _n_ символов.

* [.property]`y` – представляет абсолютную позицию текста, отсчитанную от первого символа на оси Y.
    Вы также можете указать здесь несколько значений, разделенные пробелом или запятой,
    с тем же значением, что и атрибут [.property]`x`.

* [.property]`visibility` – определяет, является ли текст видимым, скрытым
    или наследует видимость от своего родителя.
    Этот атрибут будет необходим, чтобы скрыть и показать некоторые символьные метки для компонентов схемы.


==== <line>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#LineElement]

Определяет отрезок.
С помощью линий и кривых соединяются отдельные графические символы (секции),
а из отрезков будут состоять и другие элементы.
Будем использовать атрибуты:

* [.property]`x1` – координаты начала линии на оси X,
* [.property]`y1` – координаты начала линии на оси Y,
* [.property]`x2` – координаты конца линии на оси X,
* [.property]`y2` – координаты конца линии на оси Y.


==== <polyline>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolylineElement]

Он определяет набор взаимосвязанных линий, обычно образующих открытые фигуры.
Элемент `<polyline>` используется только в некоторых графических символах компонентов схемы.

* Атрибут [.property]`points` – список пар координат X и Y, начала и конца отрезков, из которых состоит это образование.


==== <polygon>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolygonElement]

Определяет замкнутую форму, состоящую из множества взаимосвязанных отрезков.
Элемент `polygon` будет использоваться только в некоторых графических символах компонентов схемы.

* Атрибут [.property]`points` – список пар координат по осям X и Y, образующих многоугольник.


==== <rect>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#RectElement]

Определяет прямоугольник.
Используется для рендеринга секций, их теней и других графических элементов.
Для классификации мы будем использовать атрибут [.property]`class`, следующим образом:

* [.property]`x` – координаты стороны прямоугольника по оси X, эта сторона,
    чьи координаты имеют меньшее значение в системе координат пользователя (обычно слева).
* [.property]`y` – координаты стороны прямоугольника вдоль оси Y
    сторона определяется по аналогии с атрибутом [.property]`x`, обычно это верхняя сторона.
* [.property]`width` – ширина прямоугольника,
* [.property]`height` – высота прямоугольника,
* [.property]`rx` – радиус эллипса, образующий закруглённые углы прямоугольника, по оси X.
* [.property]`onclick` – имеет то же значение, что и элемент `<use>`,
    атрибут будет установлен для прямоугольных кнопок управления.


==== <circle>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#CircleElement]

Определяет окружность, круг. Он будет использоваться в выходных данных приложения только в качестве дополнительного графического элемента.
Будем использовать атрибуты:

* [.property]`cx` – координаты центра круга по оси X,
* [.property]`cy` – координаты центра круга по оси Y,
* [.property]`r` – радиус.


==== <path>
footnote:[http://www.w3.org/TR/SVG11/paths.html#PathElement]

Представляет контур формы.
Он может быть заполнен, обведен или может служить в качестве шаблона, по которому будут обрезаны другие объекты.
В этом приложении он будет служить конечной частью соединения секций.

* Атрибут [.property]`d` – определяет формы контура.
    Обычно состоит из команд _moveto_, _lineto_, _curveto_, _arc_ и _closepath_,
    или абсолютный или относительный.
        footnote:[Перемещение курсора в указанную позицию без рисования линии; с отрисовкой линии;
        с прорисовкой более детальной кривой; с рендерингом дуги;
        с прорисовкой отрезка, ведущей к начальной точке, чтобы сформировать замкнутую форму.]
    Для команд дополнительно вводятся пары координат по осям X и Y.


=== ECMAScript

ECMAScript это скриптовый язык, стандартизированный организацией _Ecma International_ в спецификации _ECMA-262_.
    footnote:[Ecma International: Standard ECMA-262. ECMAScript Language Specification 3rd edition (December 1999).
    http://www.ecma-international.org/publications/standards/Ecma-262.htm]
Широко используется в интернете, и, как правило, часто упоминается как _JavaScript_ или _JScript_, согласно основных диалектов этого языка.
Синтаксис намеренно похож на синтаксис _Java_, но он более облегчён,
чтобы сделать его более легким в использовании, например, нет необходимости объявлять тип переменных.
В то же время такой подход увеличивает вероятность ошибки.

ECMAScript это объектно-ориентированный язык программирования для выполнения вычислений и манипулирования объектами _в пользовательском окружении_.
Следовательно, он не работает независимо, ввод и вывод данных и обрабатываемых объектов предоставляет другая существующая система,
возможности которой расширяются скриптами.
Это суть скриптовых языков. _В этом приложении скрипт будет использоваться для обеспечения интерактивности модели схемы SVG в среде браузера._
Более подробная информация находится в разделе <<INTERACTIVITY>>.

ECMAScript был первоначально разработан для Интернета, чтобы оживить веб-страницы и перенести часть производительности на клиента - браузер - в архитектуре клиент-сервер.
Когда страница HTML (_HyperText Markup Language_) браузер предоставляет объекты, представляющие окна, меню, диалоговые поля, текстовые области, ссылки, кадры и многое другое.
Он также будет предоставлять способы запуска кода сценариев для таких событий, как загрузка страниц, изменение размеров окон, движение мыши, клики.

Однако нам нужны не специальные HTML-элементы, а интерфейсы к SVG или вообще объектам XML.
Общий интерфейс стандартизирован в следующей спецификации W3C, называемой DOM (_Document Object Model_).
    footnote:[W3C: Модель объекта документа (DOM). http://www.w3.org/DOM/]
DOM существует в нескольких уровнях – уровне 1-3. В этом приложении, второго уровня будет достаточно.
Для программных манипуляций с масштабируемыми графическими объектами создан специальный SVG DOM.
Это часть спецификации SVG
    footnote:[Приложение B: Модель объекта документа SVG (DOM). http://www.w3.org/TR/SVG/svgdom.html]
и далее расширяет DOM Уровень 2.
Мы могли бы использовать SVG DOM хорошо, но мы должны иметь дело с несовместимостью некоторых браузеров.
В итоге, мы будем придерживаться базового уровнем DOM 2, который является более распространенным.
Нам понадобятся методы и атрибуты, описанные в <<DOM1>> и <<DOM2>>, а их конкретное применение показано в примере <<EXAMPLES-SVG-XML>>:

* [.interface]#Document#
    :
        [.interface]#Element#
        [.method]`getElementById`
    (in
        [.interface]#DOMString#
        [.parameter]`elementId`
    ); получить элемент по его идентификатору, который указан в
        [.property]`id`
    .

* [.interface]#Document#
    :
        [.interface]#NodeList#
        [.method]`getElementsByTagName`
    (in
        [.interface]#DOMString#
        [.parameter]`tagname`
    ); получить список узлов с указанным именем тега.

* [.interface]#Node#
    :
        `readonly attribute`
        [.interface]#NodeList#
        [.property]`childNodes`
    ; содержит список всех детях узла.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]`getAttribute`
    (in
        [.interface]#DOMString#
        [.parameter]`name`
    ); для получения значения атрибута с указанным именем.

* [.interface]#Element#
    :
        `void` [.method]`setAttribute`
    (in
        [.interface]#DOMString#
        [.parameter]`name`
    , in
        [.interface]#DOMString#
        [.parameter]`value`
    );
    установить значение атрибута с данным именем или создать новый атрибут для этого узла с
    с указанным именем и значением.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]`getAttributeNS`
    (in
        [.interface]#DOMString#
        [.parameter]`namespaceURI`
    , in
        [.interface]#DOMString#
        [.parameter]`localName`
    );чтобы получить значение атрибута с данным локальным именем и пространством имен.

* [.interface]#Element#
    :
        `void` [.method]`setAttributeNS`
    (in
        [.interface]#DOMString#
        [.parameter]`namespaceURI`
    , in
        [.interface]#DOMString#
        [.parameter]`qualifiedName`
    , in
        [.interface]#DOMString#
        [.parameter]`value`
    );
    установить значение атрибута с данным именем и в пространстве имен, или создать
    новый атрибут для этого узла с указанным именем и значением в данном пространстве имен.


=== CSS

CSS, _Cascading Style Sheets_, каскадные стили снова являются результатом активности W3C.
    footnote:[W3C: Cascading Style Sheets. Домашняя страница. http://www.w3.org/Style/CSS/]
Спецификация определяет язык описания стиля, который позволяет создателям и пользователям прикрепить стиль
(например, шрифты и отступы) к структурированным документам, таким как HTML документы и XML документы.
Это может отделить описание внешнего вида документа от его содержания и упростить создание и управление сайтом.

CSS предназначен быть легко читаемым для людей, стиль выражается в терминологии, которая является общей в DTP.
    footnote:[Desktop publishing (DTP), https://en.wikipedia.org/wiki/Desktop_publishing]
Одной из основных особенностей является то, что стиль является _каскадным_.
Это означает, что несколько определений стилей могут накладываться друг на друга, но применяется только последний.
Создатель прикрепляет предпочтительный стиль к документу, но пользователь может наложить на него свой собственный стиль,
с учетом человеческого или технологического преимущества <<CSS>>.

Стиль состоит из индивидуальных _правил_.
Каждое правило определяет внешний вид одного или нескольких элементов – элементов, выбранных _селектором_, первой части правила.
За селекторами следует список деклараций, оговоренных скобками, каждая декларация разделена запятой.
Каждая декларация состоит из _свойства_ (вслед за двоеточием) и _значения_ свойства.
Селектор может выбрать все элементы с определенным именем или элементами, содержащими указанные атрибуты,
он может указывать их в зависимости от того, где они размещены по отношению к другим элементам, и выбрать их в соответствии с
_псевдоклассами_ (`:hover`) и _псевдоэлементами_ (`:first-line`).
Если несколько правил могут быть применены к определенному элементу, он будет использоваться с более высоким приоритетом.
Проще говоря, это правило с более конкретным селектором.

_Каскадный стиль, который мы используем для вывода SVG этого приложения, позволит легко выполнять дополнительные манипуляции внешним видом
каждого класса графических элементов_, для более подробной информации см <<STYLE>>.

=== Java

Java — это объектно-ориентированный язык программирования для общего пользования.
Он был разработан _Sun Microsystems_ и стал одним из наиболее широко используемых языков программирования после его введения в 1995 году.
С мая 2007 года Java была разработана как открытый исходный код.

Характерной особенностью является переносимость на разные платформы.
Однажды написанная программа может работать на любой поддерживаемой операционной системе и оборудовании.
Письменный исходный код предварительно компилируется в так называемый _bytecode_, который является одинаковым для всех платформ;
различаются только виртуальные машины (_Virtual Machine_). Эти байткоды интерпретируют или переводят во время выполнения в нативный код.
Вы можете запустить программу везде, где есть соответствующая среда исполнения (_Java Runtime Environment_).

Намерение создателей Java в соответствии с <<M254>> вопросом заключается в том, чтобы создать язык, который будет:

* _Простой_: Java основывается на нескольких основных концепциях, которые разработчики могут легко узнать.

* _Подобный установленным технологиям_: синтаксис основан на синтаксисе популярного языка С++, но его сложность снижается.

* _Объектно-ориентированный_: программы работают с объектами. Определяются объекты класса, которые могут быть унаследованы от других классов.
    может реализовать готовые интерфейсы. Объекты или целые классы предоставляют свойства (атрибуты) и методы.
    Методы могут быть перекрыты и перегружены. Реализация скрыта;
    объекты предоставляют общедоступный интерфейс, который позволяет ими манипулировать, в противном случае они инкапсулируются. Язык сильно набран.

* _Надежный_: Java-программы строго проверяются перед запуском,
    язык не включает в себя различные опции C и C++, которые подвержены ошибкам.

* _Безопасный_: Java включает в себя специальные средства безопасности,
    программы, работающие по сети, не могут повредить файлы на компьютере или содержать вирусы.

* _Пореносимый_: Программы могут быть легко перенести с одной платформы на другую, с минимальными изменениями или без изменений.

* _Высокопроизводительный_: Java-программы работают достаточно быстро для желаемых целей.

* _Исполняемый_: связано с переносимостью, см.

* _Использование программных потоков_: это позволит программе выполнять сразу несколько задач для повышения производительности.

* _Динамичный_: Программы могут адаптироваться к изменениям в среде даже во время выполнения.

_Java я выбрал для этого приложения в основном из-за переносимости и большого распространения, этот язык также близок мне благодаря
курсам, завершенным в ВШЭ._

== Параметры загрузки и интерпретации модели XML Schema

В предыдущей главе я кратко описал технологии, используемые в интерактивном приложении визуализации.
Теперь вам нужно решить, как открыть схему, загрузить ее в память, интерпретировать и обработать.
Схему XML можно рассматривать с нескольких уровней:

[float]
=== Обычный текстовый файл

Если бы мы понимали схему только как текстовый файл, нам пришлось бы запрограммировать полный способ интерпретации разметки,
затем работать с результатом в виде документа XML. К счастью, это уже давно решается с помощью стандартизированных интерфейсов
SAX (_Simple API for XML_) и DOM (_Document Object Model_).

[float]
=== Документ XML

Было бы достаточно загрузить документ с помощью SAX и при этом искать типичные структуры, состоящие в основном из имен элементов и
значения атрибутов, важные для интерпретации схемы.
Эти структуры будут представлены в качестве объектов и их свойств, 
либо так, чтобы эти объекты соответствовали своему назначению - мы просто хотим визуализировать схему -,
либо в соответствии с спецификацией.
Соответствие спецификациям обеспечивает совместимость, функциональность и облегчает работу в случае изменений.
Однако после прочтения файла необходимо решить другие задачи, в том числе:

* Извлечение импортнных, встроенных и переопределенных схем, чтобы убедиться, что они не зациклились.
* Вставка типов, встроенных в спецификацию как часть схемы.
* Необходимо переопределить типы данных, группы элементов и группы атрибутов.
* Необходимо составить ссылки на глобально объявленные типы, первичные и уникальные ключи, 
    глобально объявленные элементы и атрибуты, глобально объявленные группы элементов и атрибутов.

Однако даже в этой области есть готовые реализации, которые просто указывают входной файл, устанавливают их с несколькими параметрами и позволяют загружать схему.
Мы обязательно воспользуемся одним из них (см. <<XSD-API>>), это сэкономит много работы.
В конце концов, мы будем работать на самом высоком уровне, с абстрактной моделью данных.

[float]
=== Абстрактная модель данных

Интерпретация схемы в соответствии с <<XSD1>> дает нам легкий доступ ко всем компонентам и свойствам.
С более подробным описанием обработки можно ознакомиться в главе <<XSD-PROCESSING>>.

[[XSD-API]]
=== Выбор соответствующей реализации схемы XML

Лучшим вариантом будет найти приемлемую реализацию с открытым исходным кодом, соответствующую спецификациям, и узнать, как с ней справиться.
Ниже приводится описание четырех известных открытых приложений, которые работают со схемой, и выбор одного из них.

==== Eclipse: Инструменты разработки моделей - XSD
footnote:[Eclipse Modeling: Model Development Tools(MDT). http://www.eclipse.org/modeling/mdt/?project=xsd#xsd]

_Model Development Tools_ (MDT) является частью _Eclipse_,
которая ориентирована на разработку и продвижение технологий для разработки моделей - Eclipse Modeling Project.
Eclipse предоставляет различные рамки, инструменты и реализации технологических стандартов.
В частности, MDT предназначен для внедрения стандартных метамоделей и образцов инструментов для разработки моделей на основе этих метамоделей.
Компоненты MDT:

* Бизнес-модель и нотация бизнес-процессов (BPMN2),
* Онтологическое определение метамодели (EODM),
* Метамодель управления информацией (IMM),
* Язык ограничения объектов (OCL)
* Семантика бизнес-вокабулярности и бизнес-правил (SBVR),
* Единый язык моделирования (UML2),
* Инструменты UML2,
* Модель XML Schema Infoset (XSD).

_XML Schema Infoset Model_ — это библиотека, предоставляющая интерфейс для приложений, которые ищут,
w3c xml схемы. Для управления компонентами можно использовать интерфейс, описанный в спецификации,
но вы также можете работать с представлением DOM схемы. Для модификаций оба представления меняются соответственно.
Библиотека также включает в себя услуги по сериализации и десериализации схем. _Цель проекта должна полностью охватить функциональность
представления XML схем_, но без предоставления службы валидации, которая обычно входит в валидаторы парсеров (Xerces-J).

==== Apache: Xerces2 Java Parser - XML Schema
footnote:[The Apache XML Project: Xerces2 Java ParserReadme. http://xerces.apache.org/xerces2-j/]

_Xerces2_ является открытым XML парсером с исходным кодом, разработанным компанией _Apache_, его преимуществом является высокая производительность и соответствие стандартам.
Кроме того, он включает в себя Xerces Native Interface, framework для построения компонентов и парсеров конфигураций.

Xerces может сравнивать документы, написанные в соответствии с нотациями XML 1.1, а также правильно работает с пространствами имен
в соответствии с XML Namespaces 1.1. Он также обеспечивает полную реализацию DOM Level 3 Core,
Load and Save реализует XML Inclusions (они являются нотациями W3C) и обеспечивает поддержку каталогов OASIS XML v1.1.

_Xerces2 также является процессором схемы XML, который, за некоторыми незначительными исключениями, полностью соответствует спецификации <<XSD1>> и <<XSD2>>_.

==== Saxonica: Saxon
footnote:[Saxon, The XSLT andXQuery Processor.http://saxon.sourceforge.net]

_Saxon_ – это полная реализация рекомендаций XSLT 2.0, XQuery 1.0 и консорциума XPath 2.0 w3c.
Публикуется _Saxonica_, а также для платформ Java и .NET.
Он выпущен в двух версиях: Saxon-B является продуктом с открытым исходным кодом, реализует XSLT 2.0 и XQuery так, что
что он соответствует спецификациям только на базовом уровне требований.
Saxon-SA является коммерческим продуктом, но он позволяет применять XSLT и XQuery с использованием схем.
Таким образом, можно импортировать схему и проверять входне или выходные данные и выбирать элементы в соответствии с их типом.
Saxon-SA также включает в себя отдельный валидатор схемы XML и другие расширения по сравнению с Saxon-B.

_К сожалению, в версии с открытым исходным кодом нет интерфейса для доступа к компонентам схемы xml, и поэтому мы не можем использовать Saxon.

==== ExoLab: Castor - Source Generator XML Schema Support
footnote:[The Castor Project.http://www.castor.org/xmlschema.html]

_Castor_ — это платформа с открытым исходным кодом для Java, используемая для связывания данных, преобразования данных между объектами Java, XML-документами и таблицами из реляционных баз данных.

Она включает в себя, среди прочего, генератор исходного кода XML.
Последний создает классы Java, представляющие объектную модель в соответствии с входной XML-схемой.
Поэтому Castor поддерживает спецификацию W3C XML Schema <<XSD1>>, спецификацию <<XSD2>>.
Модель объекта представляет схему XML в памяти компьютера, в то время как генератор исходного кода преобразует данные
типов и структур схемы в соответствующие типы и структуры Java.
_Объектные модели схемы могут читать и записывать документы, манипулировать ими.
Они соответствуют спецификациям без отступлений._ Генератор кода еще не предлагает отображения для всех компонентов.

==== Volba Xerces2

Из описанных реализаций мы не можем использовать Saxon, другие кажутся эквивалентными и полностью соответствуют спецификации.
Наконец, я выбрал процессор схемы XML, который является частью парсера _Xerces2-J_.
Он прост и предоставляет именно те варианты, которые нам понадобятся.
Классы, представляющие отдельные компоненты, содержат методы доступа к свойствам, определеным в спецификации.
Изменение свойства не поддерживается, и в любом случае мы не будем его использовать.
Кроме того, легко управлять процессором, загружать схему и обрабатывать ее, использование хорошо документировано.
Кроме того, Xerces используется для визуализации схем в известном редакторе XML oXygen.
Eclipse MDT и Castor будут служить так же хорошо, но их функциональность излишне широка (работа с деревом DOM, создание и изменение схем).

== Дизайн графической модели

Прежде чем начать программировать приложение, которое будет генерировать графическое представление схем XML,
Я должен показать, как должно выглядеть это представление.
Я собираюсь принять решение о правильном типе модели, разработать дизайн символов - элементов модели - и связать их,
Я буду иметь дело с интерактивностью итоговой модели. Все это является предметом этой главы.

=== Два типа моделей

Существует два основных способа отображения схемы XML.
Оба, конечно, основаны на дереве документов XML, но отличаются по своей детализации и предназначению для использования.
Я покажу разницу на выходе _oXygen_,
    footnote:[Oxygen XML editor, официальная страница. http://www.oxygenxml.com]
который предлагает оба типа отображения.

В качестве примера используется простая схема XML:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="contact" type="ContactType"/>

    <xs:complexType name="ContactType">
        <xs:sequence>
            <xs:element name="phone" type="xs:string"/>
            <xs:element name="address" type="AddressType"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="AddressType">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="street" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
----

==== Полная модель

Полная графическая модель копирует XML-представление схемы. Для каждого элемента отображается собственный символ.
Кроме того, можно открыть дерево символов дальше и увидеть, что скрыто за ссылками на глобально определенные компоненты
схемы, такие как определения типов, глобальные декларации элементов, их группы и т.д.

Например, см <<FULL-MODEL>>.
После символа элемента `contact`, я раскрыл ветку с определением ее типа `ContactType`.
Это последовательность элементов `phone` и `address`.
Открыв дерево снова, я хотел бы получить определение типов этих элементов.
Кроме того, я могу видеть их ниже, как потомков декларирование `ContactType`.

Полная модель очень подробная.
Он предлагает компоненты, которые могут быть использованы для расширения схемы, но еще не применены в описанном документе;
подробно отображает все параметры и значения, глобальные определения типов, групповые декларации; списки импортированных и встроенных файлов.
Поэтому он предназначен для создателей схем XML, а не пользователей.

[[FULL-MODEL]]
.Представление схемы в полной модели
image::images/model_full.png[]


==== Логическая модель

В отличие от этого, логическая графическая модель отображает только основную информацию, важную для создателей документов XML, которые соответствуют схемам.
Символы значительно меньше, чем в случае полной модели.
Речь идет о показе пользователю возможной структуры элементов и атрибутов.
Ссылки на глобальные компоненты должны быть составлены так же, как и для полной модели,
однако при просмотре дерева на первый взгляд не видно, в какой части схемы определяется элемент.

Например, см. рисунок <<LOGICAL-MODEL>>.
Корневым элементом валидного документа XML является `contact`.
Внутри него должна появиться последовательность элементов `phone` и `address`.
В то время как `телефон` содержит строку текста (_string_), внутри элемента `address` есть другая последовательность,
и это элементы `name`, `street` и `city`.
Каждый из них имеет тип текстовой строки.

Таким образом, логическая модель подходит для пользователей схем XML, что облегчает им понимание определенных структур;
создатели также позволят быстрее контролировать свою работу.
Именно логическая модель будет результатом работы моего приложения, поскольку цель состоит в том, чтобы создать документацию схемы,
которая будет интуитивно понятна, и каждый быстро разберется в ней.
В документации описывается не схема XML, а документы, совместимые со схемой XML;
в частности, структуры (комбинирование, наследование) элементов, их атрибутов и типов данных.
Элементы схемы, которые не являются необходимыми для понимания цели, будут удалены из модели, как и компоненты, которые не используются напрямую.

[[LOGICAL-MODEL]]
 Представление диаграммы по логической модели
image::images/model_logical.png[]


=== Модель как дерево абстрактных символов

Эти примеры и характер документов XML подразумевают, что символы, которые составляют графическую модель,
понимается как узлы дерева.
Таким образом, на базовом уровне, будет абстрактный символ ([.class]`AbstractSymbol`)
со ссылкой на вашего родителя и отсортированный список ссылок на своих детей.
[.class]`AbstractSymbol` предоставит методы получения и назначения этих ссылок и запросов для получения дополнительной информации.

Кроме того, для визуализации каждого символа необходимо знать горизонтальную ([.parameter]`xPosition`)
и вертикальную позиции ([.parameter]`yPosition`), каждый символ имеет ширину и высоту.
[.class]`AbstractSymbol` определяет методы настройки подходящей ширины, высоты и визуализации символа.
Они должны быть переопределены у определенных символов.

[[ABSTRACT-MODEL]]
.Модель абстрактного символа
image::images/abstract_symbols.png[]


=== Символы отдельных компонентов схемы

Конкретный символ расширяет свойства абстрактного символа ([.class]`AbstractSymbol`).
Он в обязательном порядке заменяет методы для установки правильной ширины и высоты и для визуализации символа.
Ширина должна быть установлена с учетом длины текстовых строк, чтобы вписаться в символ.
При использовании пропорциональных шрифтов это можно решить только приблизительно.

Символ также предоставляет методы получения и задания параметров, описанных ниже.
Если нет ни одного из перечисленных параметров (например, потому что он представляет собой дополнительное свойство), то его значение не указано или обработано иным образом.

Ниже приведен обзор конкретных символов и их связей со схемой XML.
В описаниях параметров я исхожу из свойств и значений, определенных в спецификации <<XSD1>>.

[[SYMBOL-SCHEMA]]
==== `schema`

[.class]`SymbolSchema` представляет собой корневой элемент схемы.

Для рендеринга не нужно указывать никаких параметров.

.Символ `schema`
image::symbols/schema.svg[]


[[SYMBOL-ELEMENT]]
==== `element`

[.class]`SymbolElement` отображает название элементов информации элемента, их тип и классификацию,
пространство имен и другие свойства, доступные из компонента объявления элемента  (_Element declaration_).

* Параметр [.parameter]`name`- это текстовая строка, содержащая локальную часть информации об элементе, имена элементов,
    которые подтверждены. Значение задается объявлением элемента в свойстве [.property]`name`.

* Параметр [.parameter]`namespace`- это строка с пространством имен. Он квалифицирует информационный элемент элемента.
    Целевое пространство имен указывает на объявление элемента в свойстве [.property]`namespace`.

* Параметр [.parameter]`type` - это шрифт, содержащий имя типа элемента информационного элемента,
    pokud je tento typ pojmenovaný; nebo, pokud je typ anonymní a zároveň jednoduchý, obsahuje jméno základního typu,
    ze kterého je typ informačních položek element odvozen.
    Základem je vlastnost [.property]`name` definice typu (_Type definition_).

* Параметр [.parameter]`cardinality`- это строка, указывающая минимальное и максимальное количество вхождений элемента information items.
    Если он не указан в списке, это означает, что значения неявны (min = max = 1), и строка не будет визуализирована.
    Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_), содержащей это объявление элемента.
    Их имена [.property]`min occurs` a [.property]`max occurs`.

* Параметр [.parameter]`nillable`- логический тип говорящий, может ли он иметь информационные позиции элемента
    пустое содержимое (значение `true`) или нет (`false`).
    Значение указывается объявлением элемента в свойстве [.property]`nillable`.

* Параметр [.parameter]`abstr` является логическим типом.
    Если значение установлено на `true`, то это объявление само по себе не используется для проверки содержимого элементов.
    Значение указывается объявлением элемента в свойстве [.property]`abstract`.

* Параметр [.parameter]`substitution`- это строка с именем группы подстановок, к которой принадлежит данное объявление.
    Фактическое значение обеспечивается объявлением элемента в свойстве [.property]`substitution group affiliation`.

Нужно будет втиснуть в символ много информации, при этом не заполняя большую площадь.
Поэтому последние три свойства будут отображаться только при нажатии мыши вместо свойств [.property]`namespace` и [.property]`type`.

.Символ `element` (нормальный режим; при движении)
image::symbols/element.svg[]


[[SYMBOL-ATTRIBUTE]]
==== `attribute`

[.class]`SymbolAttribute` отображает имя элемента атрибутивной информации,
его вид и классификацию в пространстве имен и другие свойства, доступные из компонентов использования атрибутов (_Attribute use_)
и объявление атрибута (_Attribute declaration_).

* Параметр [.parameter]`name`- это текстовое сообщение, содержащее локальное сообщение, указывающее на элемент атрибутивной информации,
    что подтверждается. Значение предоставляется объявлением атрибута в свойстве [.property]`name`.

* Параметр [.parameter]`namespace` - это строка с пространством имен.
    Он квалифицирует атрибут информационного элемента. Целевое пространство имен указывает объявление атрибута своими свойствами [.property]`namespace`.

* Параметр [.parameter]`type` - это строка, содержащая имя атрибута типа информационного элемента,
    если этот тип имеет имя; или если тип является анонимным, содержит имя базового типа,
    из которого выводится тип атрибута информационного элемента. Основой является свойство [.property]`name` определение простого типа (_Simple type definition_).

* Параметр [.parameter]`required` - логический тип говорящий, должен ли присутствовать
    соответствующий элемент атрибутивной информации (значение `true`), или же это необязательно (`false`).
    В дополнение к перечислению соответствующей строки необязательный атрибут будет ограничен пунктирной линией,
    в то время как обязательный атрибут будет полным. Параметр имеет то же значение, что и свойство использования атрибута с именем [.property]`required`.

* Параметр [.parameter]`constraint` - это текстовая строка, указывающая ограничение на значение
     элемента атрибутивной информации (фиксированное или стандартное значение). Строка создается из свойства [.property]`value constraint`.
    Это то, что обеспечивает компонент использования атрибута или объявление атрибута.

Значения последних двух параметров отображаются только после наведения курсора мыши на символ `attribute`.

.Символ `attribute` (необязательный атрибут в обычном режиме; и при наведении курсора мыши; обязательный атрибут в обычном режиме)
image::symbols/attribute_optional.svg[]


[[SYMBOL-ANY]]
==== `any`

[.class]`SymbolAny` представляет собой подстановочный символ (_wildcard_) для элементов.
На его месте могут быть информационные элементы элемента с любым локальным именем, но они должны соответствовать ограничениям, наложенным на их пространство имен.

* Параметр [.parameter]`namespace` представляет собой текстовую строку, представляющую ограничения, наложенные на элемент пространства имен информационных элементов.
    Строка формируется из свойства [.property]`namespace constraint` компонента wild card.

* Параметр [.parameter]`processContents` это целое число, которое используется для разрешения проблемы способов обработки информационных статей элемента.
    Значение основано на свойстве [.property]`process contents` подстановочного символа и от него зависит изображение символа. Параметр приобретает значения:

** [.constant]`3` – метод обработки "слабый". Если существует уникальная декларация элемента, то элемент должен соответствовать этой декларации.
** [.constant]`2` – соответствует методу обработки "пропустить". Ограничений нет, элемент должна быть только хорошо структурированным xml.
** [.constant]`1` (и другие допустимые значения) - метод обработки "строгий".
    Информационному элементу должен быть присвоен xsi:type или должна быть доступна его декларация, по которой выполняется валидация.

* Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
    Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не
    будет отображаться. Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),
    содержащей эту дикую карту. Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `any` (Метод обработки `strict`; Метод обработки `skip`; Метод обработки `lax`)
image::symbols/any_strict.svg[]


[[SYMBOL-ANY-ATTRIBUTE]]
==== `anyAttribute`

[.class]`SymbolAnyAttribute` представляет собой подставновочный символ (_wildcard_) для атрибутов.
Вместо него информационные элементы могут быть атрибутом с любым локальным именем, но они должны соответствовать ограничениям, наложенным на их пространство имен.

* Параметр [.parameter]`namespace` это текстовая строка, представляющая ограничения, наложенные на пространство имен элементов атрибутивной информации.
    Строка формируется из свойства [.property]`namespace constraint` компонента wild card.

* Параметр [.parameter]`processContents` это целое число, которое используется для разрешения проблемы способов обработки атрибутов информационных элементов.
    Значение основано на свойстве [.property]`process contents` wild card и зависит от него изображение символа. Параметр приобретает значения:

** [.constant]`3` – метод обработки "слабый". Если существует уникальная декларация элемента, то элемент должен соответствовать этой декларации.
** [.constant]`2` – соответствует методу обработки "пропустить". Ограничений нет, запись должна быть только хорошо структурированным xml.
** [.constant]`1` (и другие допустимые значения) - метод обработки "строгий".
    Информационному элементу должен быть присвоен xsi:type или должна быть доступна его декларация, по которой выполняется валидация.


.Symbol `anyAttribute` (Метод обработки `strict`; Метод обработки `skip`; Метод обработки `lax`)
image::symbols/any_attribute_strict.svg[]


[[SYMBOL-ALL]]
==== `all`

[.class]`SymbolAll` представляет композит `all` модельной группы (_Model group_).
Он говорит, что дочерние элементы информационного элемента, определенные в модельной группе как [.property]`particles`, могут встречаться в любом порядке.

Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не будет нарисована. 
Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),содержащей эту дикую карту. 
Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `all`
image::symbols/all.svg[]


[[SYMBOL-CHOICE]]
==== `choice`

[.class]`SymbolChoice` представляет композит `choice` модельной группы (_Model group_).
Только одна из частиц (_particle_) определенных в модельной группе как [.property]`particles`,
может появиться в XML-документе как дочерний элемент элемента информации.

* Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
    Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не
    будет нарисована. Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),
    содержащей эту дикую карту. Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `choice`
image::symbols/choice.svg[]


[[SYMBOL-SEQUENCE]]
==== `sequence`

[.class]`SymbolSequence` представляет композит `sequence` модельной группы (_Model group_).
Каждая из частиц (_particle_) определяется в модельной группе как  [.property]`particles`,
 может отображаться в XML-документе как дочерний элемент информационного элемента в указанном порядке.

* Параметр [.parameter]`cardinality` это строка, указывающая минимальное и максимальное количество вхождений информационного элемента.
    Если он не указан, это означает, что значения являются неявными (min = max = 1), и строка не
    будет нарисована. Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_),
    содержащей эту дикую карту. Им присвоены имена [.property]`min occurs` a [.property]`max occurs`.


.Symbol `sequence`
image::symbols/sequence.svg[]


[[SYMBOL-UNIQUE]]
==== `unique`

[.class]`SymbolUnique` представляет часть определения ограничения идентичности (_Identity-constraint definition_),
в частности, имя и пространство имен `unique` категории.
Это обеспечивает уникальность значений в содержимом, определяемом <<SYMBOL-SELECTOR>>,
которые являются результатом вычисления XPath выражений, указанных в полях <<SYMBOL-FIELD>>.

* Параметр [.parameter]`name` это текстовая строка, содержащая имя определения ограничения идентичности.
    Значение задается этим определением в свойстве [.property]`name`.
* Параметр [.parameter]`namespace` это строка с пространством имен.
    Последнее уточняет определение ограничения идентичности. Пространство имен определяет свое свойство [.property]`namespace`.
    Имя пары и пространство имен идентифицирует определение ограничения идентификации и поэтому должна быть уникальной в рамках XML-схемы.


.Symbol `unique`
image::symbols/unique.svg[]


[[SYMBOL-KEY]]
==== `key`

[.class]`SymbolKey` представляет часть определения ограничения идентичности (_Identity-constraint definition_),
в частности, имя и пространство имен `key` категории.
Это обеспечивает уникальность и наличие значений в содержимом, определяемом селектором <<SYMBOL-SELECTOR>>,
которые являются результатом вычисления выражений XPath, указанных в полях <<SYMBOL-FIELD>>.

* Параметр [.parameter]`name` это текстовая строка, содержащая имя определения ограничения идентичности.
    Значение задается этим определением в свойстве [.property]`name`.
* Параметр [.parameter]`namespace` это строка с пространством имен.
    Последнее уточняет определение ограничения идентичности. Пространство имен определяет свое свойство [.property]`namespace`.
    Имя пары и пространство имен идентифицирует определение ограничения идентификации и поэтому должна быть уникальной в рамках XML-схемы.


.Symbol `key`
image::symbols/key.svg[]


[[SYMBOL-KEYREF]]
==== `keyref`

[.class]`SymbolKeyref` представляет часть определения ограничения идентичности (_Identity-constraint definition_),
в частности имя и пространство имен категории `keyref`.
Это гарантирует, что значения, полученные в результате вычисления XPath выражений, указанных в полях <<SYMBOL-FIELD>>,
будут соответствовать значениям, указанным в определении свойства [.property]`referenced key` ограничения идентичности.
Это условие вычисляется в содержимом, заданном селектором <<SYMBOL-SELECTOR>>.

* Параметр [.parameter]`name` это текстовая строка, содержащая имя определения ограничения идентичности.
    Значение задается этим определением в свойстве [.property]`name`.
* Параметр [.parameter]`namespace` это строка с пространством имен.
    Последнее уточняет определение ограничения идентичности. Пространство имен определяет свое свойство [.property]`namespace`. Имя пары и пространство имен идентифицирует определение ограничения идентификации и поэтому должна быть уникальной в рамках XML-схемы.
* Параметр [.parameter]`refer` это строка, которая служит ссылкой на другое определение ограничения идентичности
    категории `key 'или' unique'. Значение задается этим определением в свойстве [.property]`referenced key`.


.Symbol `keyref`
image::symbols/keyref.svg[]


[[SYMBOL-SELECTOR]]
==== `selector`

[.class]`SymbolSelector` служит для отображения свойства [.property]`selector` определения ограничения идентичности (_Identity-constraint definition_).

* Параметр [.parameter]`xpath` это текстовая строка. Задает ограниченное выражение XPath относительно экземпляра объявленного элемента.
    Выражение должно идентифицировать набор узлов-подчиненных элементов, к которым применяется ограничение.
    Значение параметра получается из свойства [.property]`selector` ограничения идентичности.


.Symbol `selector`
image::symbols/selector.svg[]


[[SYMBOL-FIELD]]
==== `field`

[.class]`SymbolField` представляет один элемент из списка - свойства [.property]`fields`
определения ограничения идентичности (_Identity-constraint definition_).

* Параметр [.parameter]`xpath` это текстовая строка. Задает ограниченное выражение XPath относительно экземпляра объявленного элемента,
    выбранного селектором <<SYMBOL-SELECTOR>>. Выражение должно идентифицировать конкретный узел (элемент или атрибут),
    содержимое или значение которого должно иметь простой тип и использоваться в ограничении.  Значение параметра получается из
    определения [.property]`fields` ограничения идентичности.


.Symbol `field`
image::symbols/field.svg[]


[[SYMBOL-LOOP]]
==== петля

[.class]`SymbolLoop` это вспомогательный символ, который не принадлежит XML-схеме. Он будет нарисован, если произойдет зацикливание.
Фактически, объявление элемента может косвенно содержать само себя при условии выполнения следующих условий:

. Объявление элемента имеет комплексный тип.
. Комплексный тип (1) содержит частицу (_Particle_).
. Термин ([.property]`term`) частица (2) является модельной группой (_ModelGroup_) – всегда состоящей из других частиц.
. Термин по крайней мере одной из частиц (3) является объявлением элемента, идентичным объявлению, упомянутому в пункте (1);
    или член хотя бы одной из частиц (3) является модельной группой, и в этом случае рекурсивно исходят из точки (3),
    до тех пор, пока не будет найдено объявление элемента, идентичное тому, что указано в пункте (1).

У него нет параметров.

.Символ петля
image::symbols/_loop.svg[]


[[INTERACTIVITY]]
=== Интерактивная модель

Одним из требований, предъявляемых к графической модели, является ее интерактивность.
SVG можно перемещать с помощью ECMAScript (JavaScript). Вы можете просто изменить информацию, отображаемую при наведении курсора мыши на символы <<SYMBOL-ELEMENT>> и <<SYMBOL-ATTRIBUTE>>.
Сложнее реализовать распаковку и скрытие поддеревьев отдельных символов.
Для этого SVG-документ должен знать расположение символов в дереве.
Я буду использовать следующий пример, чтобы объяснить:

[source, xml]
----
<g id='_1_1_1_2' class='box' transform='translate(395,121)'>
    <rect class='shadow' x='3' y='3' width='117' height='46'/>
    <rect class='boxelement' x='0' y='0' width='117' height='46'
        onmouseover='makeVisible("_1_1_1_2")' onmouseout='makeHidden("_1_1_1_2")'/>
    <text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
    <text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
    <text class='strong' x='5' y='27'>address</text>
    <text class='visible' x='5' y='41'>type: AddressType</text>
    <line class='connection' id='p_1_1_1_2' x1='-35' y1='-48' x2='-35' y2='-40'/>
    <path class='connection' d='M-35,-40 Q-35,15 0,23'/>
    <use x='116' y='17' xlink:href='#plus' id='s_1_1_1_2' onclick='show("_1_1_1_2")'/>
</g>
----

Это XML-представление символа "адрес".
Он состоит из нескольких SVG-элементов и отображается как <<ADDRESS-SYMBOL>>.

* Символ состоит из двух прямоугольников. Первая слегка сдвинута, образуя легкую тень.
    Последний образует основную коробку и чувствителен к зависанию мыши.
* Кроме того, символ содержит четыре текстовых элемента. Первые два содержат "nillable: 0" ` и "abstract: 0"`
    теперь они спрятаны. Строки „address"` и „type: addressstype"` видны.
* За ним следует отрезок линии, за которым следует кривая, соединяющая символ с его родителем слева.
* Наконец, используется заранее определенный символ "плюс", представляющий собой небольшой квадрат со знаком "плюс".
    Он чувствителен к щелчкам мыши.

Кроме того, для того, чтобы работать с символом как единым целым,
все описанные элементы упаковываются в группу элементом `<g>`
Последнее также позволяет трансформировать положение символа и его однозначную идентификацию внутри дерева.

[[ADDRESS-SYMBOL]]
.Символ элемента адреса (в обычном режиме; при наведении мыши)
image::images/address.svg[]

Чтобы изменить отображаемые элементы при наведении курсора мыши, достаточно, чтобы каждый символ имел уникальный идентификатор.
Это передается в ECMAScript методами [.method]`makeVisible`([.parameter]`id`)
и [.method]`makeHidden`([.parameter]`id`) при наведении курсора мыши на поле основного символа или при его выходе из поля.
Изменение заключается в том, что элементы, которые имели заданную категорию ([.property]`class`) скрытыми, теперь будут видны.
Это текстовые строки "nillable: 0"` a "abstract: 0"`. Наоборот, предметы в классе будут временно скрыты.
Это включает в себя только строку „type: AddressType"`. См. изображение <<ADDRESS-SYMBOL>>.

Идентификатор символа, используемый здесь, довольно сложен, это строка `_1_1_1_2`.
Однако его использование оправдано.
Я уже писал, что для работы с поддеревьями символов в SVG-документе должно быть видно, к какой части дерева относится символ.
Это можно однозначно определить с помощью таких идентификаторов, указывающих путь от корня дерева к определенному символу.
Посмотрите на изображение <<INTERACTIVITY_MODEL>>.

[[INTERACTIVITY_MODEL]]
.Модель с кодами символов
image::images/model_interactivity.png[]

Корневой символ имеет идентификатор `_1`.
Разделитель необходим из-за допустимых значений атрибута `id`, поэтому он также выбирается в качестве разделителя.
Корневой символ также имеет двух детей.
Их идентификаторы состоят из идентификатора родительского и добавленной собвстенной части, указывающей их позицию.
Мы получаем строки `_1_1` a `_1_2`.
По аналогии, символ `_1_1` имеет дочернее значение `_1_1_1`.
Символ с идентификатором `_1_1_1` имеет два дочерних элемента, и второй из них (`_1_1_1_2`) является описываемым элементом, символом элемента `address`.

Когда вы нажимаете на символ минус после поля `address` используется ECMAScript метод [.method]`show`([.parameter]`"_1_1_1_2"`).
Последний выполняет следующие функции:

* Меняет символ минуса здесь на плюс, переписав атрибут `xlink:href` elementu `<use>`
    так, что это относится к предопределенному графическому объекту `plus`.
* Скрывает все поддерево символов, прикрепленное справа от поля. Он включает в себя все символы,
    чей идентификатор также начинается с `_1_1_1_2`. Для элементов `<<g-container>>`
    группирующих объекты, составляющие символ, атрибут "видимость" имеет значение [.property]`hidden`.
* Полученное пространство заполняется боковыми ветвями. Они перемещаются вверх, регулируя значение атрибута `transform`
    для группирующего элемента `<g>`.
    Расчет расстояния, на которое могут перемещаться символы, нужно делать только для одного символа, для остальных расстояние такое же.
    Здесь также будет работать система идентификации.
    Кроме того, необходимо укоротить отрезок линии, соединяющий родительские символы с прокрученной ветвью.

Результат можно увидеть на рисунке <<INTERACTIVITY-MODEL-2>>.
Если мы сейчас нажмем на символ плюса, то будет снова вызван метод [.method]`show`([.parameter]`"_1_1_1_2"`).
Но теперь он будет работать прямо противоположно тому, что было описано.

В дополнение к вышеописанному функционалу будут предусмотрены кнопки для отображения и скрытия всех символов, кроме корневого.
Со временем будут добавлены кнопки масштабирования _zoom in_ и _zoom out_, пока вы можете обойтись без них и использовать функции браузера.

[[INTERACTIVITY-MODEL-2]]
.Модель после скрытия поддерева элемента адреса
image::images/model_interactivity2.png[]


=== Итоговое SVG-представление схемы

Если все условия выполнены, я получаю вывод SVG из приложения,
графическое представление которого можно увидеть на рисунке <<MY-MODEL>>.
В приложении <<EXAMPLES>> для наглядности, снова показано, как вводится XML-схема,
таким образом, SVG выводится как в XML, так и в графическом представлении.

[float]
[[STYLE]]
==== Стиль

Однако полученную диаграмму можно дополнительно модифицировать, поскольку ее внешний вид задан в стиле CSS.
Приложение может сгенерировать стиль как часть SVG-документа или отдельно, или только прикрепить существующий внешний стиль.
Каскадные стили используют селекторы для выбора определенных элементов, которые затем задают внешний вид.
Выбор может быть определен именем тега, но если мы хотим единообразно редактировать определенные логические единицы, мы можем использовать их включение в классы ([.property]`class`). В выходных данных SVG были созданы следующие классы:

* [.property]`strong` для важных надписей, таких как названия элементов и атрибутов. Шрифт больше и жирнее.
* [.property]`small` для текста, который является частью графики, написанной более мелким шрифтом.
* [.property]`big` для текста, который является частью графики, написанной более крупным шрифтом.
* [.property]`button` для кнопок; суть в том, что он имеет в параметре [.property]`pointer-events`
    включается чувствительность к определенным событиям, в первую очередь речь идет о щелчках мыши.
* [.property]`shadow` это класс для тени, отображаемой за некоторыми блоками.
* [.property]`connection` включает в себя сегменты и кривые, соединяющие отдельные графические символы (боксы).
* [.property]`empty` для форм обтаженных, без заливки.
* [.property]`filled` для форм, заполненных, без границы.
* [.property]`boxelement` для поля символов <<SYMBOL-ELEMENT>>.
* [.property]`boxattribute1` для поля символов <<SYMBOL-ATTRIBUTE>>, если использование атрибута является обязательным.
* [.property]`boxattribute2` для поля символов <<SYMBOL-ATTRIBUTE>>, если использование атрибута является необязательны
* [.property]`boxany` для поля символов <<SYMBOL-ANY>>.
* [.property]`boxanyattribute` для поля символов <<SYMBOL-ANY-ATTRIBUTE>>.
* [.property]`boxschema` для поля символов <<SYMBOL-SCHEMA>>.
* [.property]`boxcompositor` для поля символов <<SYMBOL-ALL>>, <<SYMBOL-CHOICE>>, <<SYMBOL-SEQUENCE>>.
* [.property]`boxloop` для поля символов <<SYMBOL-LOOP>>.
* [.property]`boxidc` для поля символов <<SYMBOL-UNIQUE>>, <<SYMBOL-KEY>>, <<SYMBOL-KEYREF>>.
* [.property]`boxselector` для поля символов <<SYMBOL-SELECTOR>>.
* [.property]`boxfield` для поля символов <<SYMBOL-FIELD>>.
* [.property]`lax` служит для дальнейшей регулировки внешнего вида блоков <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    если их метод обработки установлен на _lax_.
* [.property]`skip` служит для дальнейшей регулировки внешнего вида блоков <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    если их метод обработки установлен на _skip_.
* [.property]`strict` служит для дальнейшей регулировки внешнего вида блоков <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    если их метод обработки установлен на _strict_.


[float]
==== Оригинальный стиль, сгенерированный приложением

[source, css]
----
svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}
----

[[MY-MODEL]]
.Вывод приложения для приведенного выше примера XML-схемы
image::images/model_my.svg[]


[[XSD-PROCESSING]]
== Zpracování XML schématu

V této kapitole ukážu způsob procházení mezi komponentami schématu a vytvořím tak koncept jádra aplikace.
Jednotlivé oddíly se věnují zpracování konkrétních komponent a vedle algoritmu zpracování obsahují také popis převzatý ze specifikace <<XSD1>>.
Odkaz na konkrétní část specifikace uvádím u každého oddílu v poznámce pod čarou.

Jako základní knihovnu, na které postavím aplikaci, jsem po předchozím uvážení zvolil open-source parser Xerces.
Ten poskytuje plnou podporu XML schémat podle <<XSD0>>, <<XSD1>> a <<XSD2>>, až na několik omezení,
které v naprosté většině případů nebudou tvořit překážku.
    footnote:[The Apache XML Project: Xerces2 Java Parser Readme. XML Schema. http://xerces.apache.org/xerces2-j/xml-schema.html]
Implementace Xerces tak bude pracovat v souladu se specifikací W3C a bude užívat její termíny.

Obrázek <<DIAGRAM_KOMPONENT>> nám umožní udělat si snadno představu o vazbách a základních vlastnostech jednotlivých
komponent XML schématu, jež jsou definovány v třetí části specifikace.
    footnote:[Schema Component Details. http://www.w3.org/TR/xmlschema-1/#components]

[[PROCESS-MODEL]]
=== Zpracování samotného schématu
footnote:[http://www.w3.org/TR/xmlschema-1/#Schemas]

Schéma (_Schema_, v Xercesu třída [.class]`XSModel`) slouží na abstraktní úrovni jako kontejner pro jednotlivé komponenty.
Jedná se o komponenty globální, tedy pojmenované a anotace.

Metoda [.method]`processModel`([.class]`XSModel`[.parameter]`model`) bude mít na starost zpracování schématu.

. Vytvoří se symbol <<SYMBOL-SCHEMA>> a bude vložen jako kořen do stromové struktury symbolů.
. Bude volána pomocná metoda [.method]`processElementDeclarations`([.parameter]`elementDeclarations`)
    [<<PROCESS-ELEMENT-DECLARATIONS>>], parametrem jsou všechny globálně deklarované elementy.

Ostatní vlastnosti schématu ([.property]`attribute declarations`, [.property]`model group definitions`,
    [.property]`attribute group definitions`, [.property]`type definitions`, [.property]`notation declarations`,
    [.property]`annotations`) pro tvorbu logického modelu grafické reprezentace takto přímo nevyužijeme;
    Xerces nám některé z nich poskytne později skrze reference jako globálně definované typy, atributy, elementy a jejich skupiny.
Při vykreslování tedy vůbec nebudeme muset pracovat s komponentami definice skupiny atributů
    (_Attribute group definition_), definice modelové skupiny (_Model group definition_) a deklarace notace
    (_Notation declaration_), které jsou dostupné pouze ze schématu, a nebudeme potřebovat ani anotace (_Annotation_).

[[PROCESS-ELEMENT-DECLARATIONS]]
=== Zpracování kolekce deklarací elementů

Kolekce deklarací elementů (v Xercesu obalené obecnou třídou [.class]`XSNamedMap`).

Metoda [.method]`processElementDeclarations`([.class]`XSNamedMap`[.parameter]`map`) provádí zpracování globálních
deklarací elementů.Metoda obsahuje cyklus.

. Prochází se kolekcí deklarací elementů:

.. Pro každý prvek kolekce se volá [.method]`processElementDeclaration`([.parameter]`elementDeclaration`, `null`)
    [<<PROCESS-ELEMENT-DECLARATION>>]. První parametr je konkrétní deklarace elementu (_Element declaration_), druhý je řetězec vyjadřující kardinalitu elementu. V případě globální deklarace má vždy hodnotu `null`.

[[PROCESS-ELEMENT-DECLARATION]]
=== Zpracování deklarace elementu
footnote:[http://www.w3.org/TR/xmlschema-1/#cElement_Declarations]

Deklarace elementu (_Element declaration_, v Xercesu třída [.class]`XSElementDeclaration`) umožňuje:

* lokální validaci hodnot informační položky element za použití definice typu;
* specifikování defaultních nebo fixních hodnot pro informační položku element;
* zajištění jedinečnosti hodnot a nastavení referenčních omezení v rámci hodnot příbuzných elementů a atributů;
* kontrolování vzájemné nahraditelnosti elementů pomocí mechanismu substitučních skupin (_element substitution groups_).

Metoda [.method]`processElementDeclaration`([.class]`XSElementDeclaration`[.parameter]`elementDeclaration`,
    [.class]`String`[.parameter]`cardinality`) zpracuje deklaraci elementu:

. Dojde k vytvoření symbolu <<SYMBOL-ELEMENT>> a jeho připojení na odpovídající místo stromové struktury.
    U symbolu je třeba nastavit základní informace, poskytované přímo objektem [.parameter]`elementDeclaration`,
    ale také některé dodatečné informace, například řetězec s typem elementu, získaný voláním pomocné metody
    [.method]`getTypeString`([.parameter]`typeDefinition`) [<<PROCESS-SIMPLE-TYPE>>], a řetězec uvádějící
    minimální a maximální počet výskytů, získaný z parametru [.parameter]`cardinality`.
    Popis jednotlivých položek naleznete u grafického návrhu symbolu `element`.

. Zjišťuje se, zda se stejná deklarace nevyskytuje mezi předky této deklarace.
    Došlo by k zacyklení a vykreslování modelu by se nikdy řádně neukončilo. Kontrolu provádí metoda
    [.method]`processLoop`([.class]`XSElementDeclaration`[.parameter]`elementDeclaration`),
    která má za úkol v případě objevení cyklu připojit symbol <<SYMBOL-LOOP>> a zastavit zpracování následníků.

. Pokud má element komplexní datový typ, proběhne na tomto místě zpracování jeho definice.
    To obstarává metoda [.method]`processComplexTypeDefinition`([.parameter]`complexTypeDefinition`) [<<PROCESS-COMPLEX-TYPE>>]

. Bude volána pomocná metoda [.method]`processIdentityConstraints`([.parameter]`IdentityConstraints`)
    [<<PROCESS-IDENTITY-CONSTRAINTS>>], parametrem jsou všechna identitní omezení definovaná v rámci této deklarace.


[[PROCESS-ATTRIBUTE-USES]]
=== Zpracování kolekce užití atributů

Kolekce užití atributů (v Xercesu obalené obecnou třídou [.class]`XSObjectList`).

Metoda [.method]`processAttributeUses`([.class]`XSObjectList`[.parameter]`attributeUses`) provádí zpracování kolekce užití atributů.
Metoda obsahuje cyklus.

. Prochází se kolekcí:

.. Pro každý prvek kolekce se volá metoda [.method]`processAttributeUse`([.parameter]`attributeUse`)
    [<<PROCESS-ATTRIBUTE-USE>>]. Parametr je konkrétní užití atributu (_Attribute use_).

[[PROCESS-ATTRIBUTE-USE]]
=== Zpracování užití atributu{blank}footnote:[http://www.w3.org/TR/xmlschema-1/#cAttributeUse]

Užití atributu (_Attribute use_, v Xercesu třída [.class]`XSAttributeUse`) je pomocná komponenta,
která kontroluje výskyt a defaultní chování deklarace atributu.
Pro deklaraci atributu plní v rámci komplexního typu podobnou úlohu jako částice (_Particle_) pro deklaraci elementu.

Metoda [.method]`processAttributeUse`([.class]`XSAttributeUse`[.parameter]`attributeUse`)
slouží ke zpracování užití atributu a zároveň i samotné deklarace atributu:

. Na tomto místě proběhne zpracování deklarace atributu [<<PROCESS-ATTRIBUTE-DECLARATION>>].


[[PROCESS-ATTRIBUTE-DECLARATION]]
=== Zpracování deklarace atributu
footnote:[http://www.w3.org/TR/xmlschema-1/#cAttribute_Declarations]

Deklarace atributu (_Attribute declaration_, v Xercesu třída [.class]`XSAttributeDeclaration`) umožňuje:

* lokální validaci hodnot informační položky atribut za použití definice jednoduchého typu;
* specifikování defaultních nebo fixních hodnot pro informační položku atribut.

Pro jednoduchost je deklarace atributu zpracována uvnitř metody
[.method]`processAttributeUse`([.class]`XSAttributeUse`[.parameter]`attributeUse`) [<<PROCESS-ATTRIBUTE-USE>>].

. Dojde k vytvoření symbolu <<SYMBOL-ATTRIBUTE>> a jeho připojení do stromové struktury.
    Předtím se musí zjistit základní informace, poskytované přímo deklarací atributu,
    a také dodatečná informace o typu atributu, získaná voláním pomocné metody
    [.method]`getTypeString`([.parameter]`typeDefinition`) [<<PROCESS-SIMPLE-TYPE>>].
    Popis jednotlivých položek naleznete u grafického návrhu symbolu `attribute`.


[[PROCESS-WILDCARD]]
=== Zpracování divoké karty
footnote:[http://www.w3.org/TR/xmlschema-1/#Wildcards]

Divoká karta (_Wildcard_, v Xercesu třída [.class]`XSWildcard`)
umožňuje validaci informačních položek element a atribut, závisející na jmenném prostoru, ale nezávislou na lokálním jméně.

Metoda [.method]`processElementWildcard`([.class]`XSWildcard`[.parameter]`wildcard`,
[.class]`String`[.parameter]`cardinality`) slouží ke zpracování divoké karty pro element:

. Vytvoří symbol <<SYMBOL-ANY>> a připojí ho na odpovídající pozici ve stromové struktuře.
    Pomocná metoda [.method]`getNamespaceString`([.class]`XSWildcard`[.parameter]`wildcard`)
    umožní sestavit řetězec, uvádějící omezení jmenných prostorů,
    parametr `cardinality` dodá informaci o minimálním a maximálním počtu výskytů.

Metoda [.method]`processAttributeWildcard`([.class]`XSWildcard`[.parameter]`wildcard`)
slouží ke zpracování divoké karty pro atribut:

. Vytvoří symbol <<SYMBOL-ANY-ATTRIBUTE>> a připojí ho na odpovídající pozici ve stromové struktuře.
    Pomocná metoda [.method]`getNamespaceString`([.class]`XSWildcard`[.parameter]`wildcard`)
    umožní sestavit řetězec, uvádějící omezení jmenných prostorů.


[[PROCESS-SIMPLE-TYPE]]
=== Zpracování definice jednoduchého typu
footnote:[http://www.w3.org/TR/xmlschema-1/#Simple_Type_Definitions]

Definice jednoduchého typu (_Simple type definition_, v Xercesu třída [.class]`XSSimpleTypeDefinition`)
umožňuje omezení znakových informačních položek – dětí informačních položek element a atribut.

Pomocná metoda [.method]`getTypeString`([.class]`XSTypeDefinition`[.parameter]`typeDefinition`)
je volána při zpracování deklarací elementů a atributů.
U jednoduchého typu je pouze třeba zjistit název, nebo název základního typu a ten zobrazit jako typ elementu / atributu.

. Pokud je typ pojmenovaný (může být i komplexní), vrátí jméno typu.
. Pokud je typ anonymní a zároveň je jednoduchý, vrátí jméno základního typu, ze kterého je tento typ odvozen.
. Jinak vrátí `null`.


[[PROCESS-COMPLEX-TYPE]]
=== Zpracování definice komplexního typu
footnote:[http://www.w3.org/TR/xmlschema-1/#Complex_Type_Definitions]

Definice komplexního typu (_Complex type definition_, v Xercesu třída [.class]`XSComplexTypeDefinition`) umožňuje:

* omezení informačních položek element, přidáním deklarací atributů, určujících výskyt a obsah atributů;
* omezení informačních položek element tak, že musí mít buď prázdný obsah, nebo musí vyhovět specifikovanému
    obsahu smíšenému, nebo tvořenému pouze elementy; nebo omezuje znakové informační položky tak,
    aby vyhověly specifikované definici jednoduchého typu;
* využití mechanismu hierarchie definic typů (_Type definition hierarchy_)
    k odvození komplexního typu z jiného jednoduchého či komplexního typu;
* specifikování příspěvků k post-schema-validation infosetu elementů;
* omezení možnosti odvozovat další typy z tohoto komplexního typu;
* kontrolovat nahrazování elementů odvozeného typu za elementy deklarované v modelu obsahu,
    který je tohoto komplexního typu.

Definice komplexního typu je zpracována metodou [.method]`processComplexTypeDefinition`
    ([.class]`XSComplexTypeDefinition`[.parameter]`complexTypeDefinition`).

. Zjistí se, zda definice obsahuje částici (_Particle_), pokud ano, volá se metoda
    [.method]`processParticle`([.parameter]`particle`) [<<PROCESS-PARTICLE>>].
    Parametrem je částice získaná z definice komplexního typu.
. Volá se pomocná metoda [.method]`processAttributeUses`([.parameter]`attributeUses`) [<<PROCESS-ATTRIBUTE-USES>>],
    parametrem je kolekce užití atributů.
. Pokud je definována divoká karta (_Wildcard_) pro atributy, zavolá se metoda [.method]`processAttributeWildcard`
    ([.parameter]`wildcard`) [<<PROCESS-WILDCARD>>]. Parametrem je divoká karta získaná z definice komplexního typu.


[[PROCESS-IDENTITY-CONSTRAINTS]]
=== Zpracování kolekce identitních omezení

Kolekce deklarací identitních omezení (v Xercesu obalené obecnou třídou [.class]`XSNamedMap`).

Metoda [.method]`processIdentityConstraints`([.class]`XSNamedMap`[.parameter]`identityConstraints`)
provádí zpracování deklarací identitních omezení. Metoda obsahuje cyklus.

. Prochází se kolekcí:

.. Pro každý prvek kolekce se volá metoda [.method]`processIdentityConstraintDefinition`
    ([.parameter]`identityConstraintDefinition`) [<<PROCESS-IDENTITY-CONSTRAINT>>].
    Parametrem je konkrétní definice identitního omezení (_Identity-constraint definition_).


[[PROCESS-IDENTITY-CONSTRAINT]]
=== Zpracování definice identitního omezení
footnote:[http://www.w3.org/TR/xmlschema-1/#cIdentity-constraint_Definitions]

Definice identitního omezení (_Identity-constraint definition_, v Xercesu třída [.class]`XSIDCDefinition`)
zajištuje jedinečnost a referenční omezení v rámci hodnot množiny elementů a atributů.

Metoda [.method]`processIdentityConstraintDefinition`
([.class]`XSIDCDefinition`[.parameter]`identityConstraintDefinition`)
má na starost zpracování definice identitního omezení.

. Zjistí se kategorie této definice:

.. Pokud jde o unikátní klíč (`unique`), vytvoří se symbol <<SYMBOL-UNIQUE>>.
.. Pokud jde o primární klíč (`key`), vytvoří se symbol <<SYMBOL-KEY>>.
.. Pokud jde o cizí klíč (`keyref`), vytvoří se symbol <<SYMBOL-KEYREF>>.
. Vytvoří se symbol <<SYMBOL-SELECTOR>>.
. Prochází se kolekcí polí (`field`):

.. Pro každý prvek kolekce se vytvoří symbol <<SYMBOL-FIELD>>.

Potřebné informace pro vykreslení všech symbolů poskytne přímo objekt [.parameter]`identityConstraintDefinition`.
Jejich přehled naleznete u návrhu jednotlivých symbolů.
Každý ze symbolů je připojen na odpovídající místo stromové struktury.

[[PROCESS-PARTICLES]]
=== Zpracování kolekce částic

Kolekce částic (v Xercesu obalené obecnou třídou [.class]`XSObjectList`).

Metoda [.method]`processParticles`([.class]`XSObjectList`[.parameter]`particles`) provádí zpracování kolekce částic.
Metoda obsahuje cyklus:

. Prochází se kolekcí částic:

.. Pro každý prvek kolekce se volá [.method]`processParticle`([.parameter]`particle`) [<<PROCESS-PARTICLE>>].
    Parametrem je konkrétní částice (_Particle_).


[[PROCESS-PARTICLE]]
=== Zpracování částice
footnote:[http://www.w3.org/TR/xmlschema-1/#cParticles]

Částice (_Particle_, v Xercesu třída [.class]`XSParticle`) přidává dodatečné informace o minimálním a 
maximálním počtu výskytů k definici modelu obsahu.

Metoda [.method]`processParticle`([.class]`XSParticle`[.parameter]`particle`) zpracuje částici následujícím způsobem:

. Pomocná metoda [.method]`getCardinalityString`([.class]`XSParticle`[.parameter]`particle`)
    sestaví řetězec `cardinality`, obsahující informaci o minimálním ([.property]`minOccurs`)
    a maximálním ([.property]`maxOccurs`) počtu výskytů částicí obaleného termínu ([.property]`term`).
. Zavolá pomocnou metodu [.method]`processTerm`([.parameter]`term`, [.parameter]`cardinality`) [<<PROCESS-TERM>>],
    která termín zpracuje, a pošle jí i řetězec `cardinality`.


[[PROCESS-TERM]]
=== Zpracování termínu

Termín (_Term_, v Xercesu třída [.class]`XSTerm`) je obecná vlastnost zastupující modelovou skupinu,
deklaraci elementu, nebo divokou kartu pro elementy.

Metoda [.method]`processTerm`([.class]`XSTerm`[.parameter]`term`, [.class]`String`[.parameter]`cardinality`)
provádí tento algoritmus:

. Zjistí se typ termínu:

.. Pokud se jedná o modelovou skupinu (_Model group_), volá se metoda
    [.method]`processModelGroup`([.parameter]`modelGroup`, [.parameter]`cardinality`) [<<_process_model_group>>].
    Prvním parametrem je termín – modelová skupina, druhým parametrem se předává dál informace o kardinalitě.

.. Pokud jde o deklaraci elementu (_Element declaration_), volá se [.method]`processElementDeclaration`
    ([.parameter]`elementDeclaration`, [.parameter]`cardinality`) [<<PROCESS-ELEMENT-DECLARATION>>].
    Prvním parametrem je termín – deklarace elementu, druhým parametrem se předává dál informace o kardinalitě.

.. Pokud jde o divokou kartu (_Wildcard_) pro elementy, volá se metoda [.method]`processElementWildcard`
    ([.parameter]`wildcard`, [.parameter]`cardinality`) [<<PROCESS-WILDCARD>>].
    Prvním parametrem je termín – divoká karta, druhým parametrem se předává dál informace o kardinalitě.


[[_process_model_group]]
=== Zpracování modelové skupiny
{blank}footnote:[http://www.w3.org/TR/xmlschema-1/#Model_Groups]

Modelová skupina (_Model group_, v Xercesu třída [.class]`XSModelGroup`).
Pokud není definováno, že mají být děti informační položky element prázdné,
nebo že mají vyhovovat určité definici jednoduchého typu, může být obsah posloupnosti dětí informační položky element
specifikován detailněji pomocí modelové skupiny.
Díky tomu, že součástí částice může být modelová skupina a modelová skupina obsahuje částice,
může modelová skupina nepřímo obsahovat jiné modelové skupiny.

Metoda [.method]`processModelGroup`([.class]`XSModelGroup`[.parameter]`modelGroup`,
[.class]`String`[.parameter]`cardinality`) provádí algoritmus:

. Zjistí se typ kompozitoru ([.property]`compositor`):

.. Pokud se jedná o kompozitor `all`, vytvoří se symbol <<SYMBOL-ALL>>.
.. Pokud jde o kompozitor `choice`, vytvoří se symbol <<SYMBOL-CHOICE>>.
.. Jinak jde o kompozitor `sequence`, vytvoří se symbol <<SYMBOL-SEQUENCE>>.

. Zavolá se pomocná metoda [.method]`processParticles`([.parameter]`particles`)
    [<<PROCESS-PARTICLES>>], parametrem je kolekce částic, obsažených uvnitř modelové skupiny.

U každého ze symbolů bude vypsán řetězec `cardinality` s informací o minimálním a maximálním počtu výskytů.
Vytvořený symbol je vždy připojen na odpovídající pozici stromové struktury.

[float]
==== Konečné uložení připravené struktury do SVG

Poté, co se dokončí procházení abstraktního datového modelu XML schématu a připravené symboly utvoří stromovou
strukturu, dojde k uložení stromu do SVG souboru.
Nejprve se vypíše jakási hlavička s XML deklarací, doctypem, titulkem, přidá se skript, předem definované symboly a
popřípadě styl; následují jednotlivé symboly komponent.
Přesný průběh vypadá tak, že se vezme kořenový symbol, nastaví se u něj správné rozměry a umístění na pomyslném plátně
a uloží se, totéž se pak opakuje se všemi dětmi a jejich potomky, až se dojde k listům stromu.
Tím jsou symboly vloženy do souboru a následuje už jen koncový tag `<svg>`

== Závěr

Cílem práce bylo navrhnout a implementovat aplikaci pro převod XML schématu do interaktivního diagramu ve formátu SVG.
Bylo proto třeba nastudovat principy, na kterých staví specifikace W3C XML schématu.
Ta silně odděluje abstraktní datový model od XML reprezentace.
Právě abstraktní datový model, jeho komponenty a vlastnosti komponent poskytují přímý a jednoduchý přístup k důležitým údajům.
Abych nemusel vše programovat od začátku, vybíral jsem mezi hotovými open source implementacemi modelu a zvolil
procesor tvořící součást parseru Xerces.
Ten vyhovuje specifikaci; zpřístupnil komponenty schématu a jejich struktury programovým prostředkům jazyka Java.

Dále bylo třeba rozhodnout se pro vhodný způsob zobrazení struktur definovaných schématem.
Zde jsem se inspiroval výstupy úspěšného XML editoru oXygen.
Z představy grafického modelu vzešel návrh tříd objektů – obecného abstraktního symbolu a konkrétních symbolů
komponent schématu –, návrh jejich vzhledu, parametrů a propojení i ve vazbě k zajištění interaktivity modelu.
Přitom bylo nutné alespoň v základu poznat možnosti formátu SVG.

Po načtení instance XML schématu do objektové reprezentace jazyka Java se spustí procházení těmito objekty a
začne se vytvářet stromová struktura definovaných symbolů.
Ta je nakonec uložena do SVG souboru.
Na něj jsou ale ještě vázány další technologie.
Především jde o ECMAScript, který je součástí souboru a provádí jeho zpracování při otevření v prohlížeči.
Zajišťuje interaktivitu reakcemi na události spuštěné pohybem a klikáním myši.
Aby skript mohl pracovat s elementy SVG dokumentu, potřebuje k nim získat přístup.
Přístup zajišťuje DOM úrovně 2.
Poslední technologií jsou kaskádové styly, které mohou tvořit součást SVG souboru nebo mohou být připojeny z
externího souboru a umožňují drobné úpravy výsledného vzhledu.

Na závěr mohu konstatovat, že se podařilo splnit cíl práce.
Praktickým produktem je funkční program, jehož výstupem je přehledný, interaktivní diagram zobrazující
strukturu XML souborů, vyhovujících schématu.
Konkrétně je to struktura použitelných elementů a atributů, jejich jména, jmenné prostory, datové typy,
kardinalita elementů, definované klíče atd.
Postromy symbolů lze zobrazovat a skrývat.
Dle mého názoru může diagram skutečně usnadnit orientaci a pochopení struktur, může tvořit kvalitní doplněk dokumentace.

I zde však existují určitá omezení.
První vyplývá z pomalé implementce SVG a ECMAScriptu v prohlížečích.
Projevuje se v pomalejší reakci na události a obecně v pomalejším vykreslování velkých diagramů.
V této oblasti lze jen doufat, že do budoucna vznikne lepší podpora.
Další problém se může vyskytnout při programovém zpracování schémat, popisujících velmi rozsáhlé struktury.
Může dojít k pádu aplikace v důsledku překročení paměťového prostoru.
Tento problém lze odstranit úpravou aplikace, vzhledem k prvnímu omezení však není nutné s úpravou moc spěchat.

Tím se dostávám k faktu, že aplikace včetně zdrojových kódů bude šířena jako svobodný software.
Momentálně je dostupná na přiloženém CD (viz <<_CD>>) a na webové stránce http://st.vse.cz/~XSLAV14/.
To přináší možnost budoucího rozvoje aplikace v podobě vylepšování nebo rozšiřování funkčnosti.
Například by šla přidělat tlačítka pro zoom in a zoom out; rozšířit program o podporu dalších schémových jazyků
(pokud vím, je jejich vizualizace předmětem jiných bakalářských prací);
nebo integrovat do systému pro generování kompletních dokumentací.

:sectnums!:

[bibliography]
== Literatura

[bibliography]
[float]
=== Главное
- [[[XSD0,1]]] Фоллсайд, Д. К., Уолмсли, П. a kol.:
    _XML Schema Part 0: Primer Second Edition_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xmlschema-0/

- [[[XSD1,2]]] Томпсон, Х. С., Бук, Д., Малони, M., Мендельсон, N. a kol.:
    _XML Schema Part 1: Structures Second Edition_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xmlschema-1/

- [[[XSD2,3]]] Бирон, П. В., Малхотра, А. a kol.:
    _XML Schema Part 2: Datatypes Second Edition_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xmlschema-2/

- [[[XSD-VLIST,4]]] ван дер Влист, Е.:
    _Using W3C XML Schema. XML.com, 2001._
    Доступно с сайта: http://www.xml.com/pub/a/2000/11/29/schemas/part1.html?page=1

- [[[SVG,5]]] Феррайоло, Дж., Фудзисава, Дж., Джексон, Д.: 
    _Scalable Vector Graphics (SVG) 1.1 Specification_
    [online]. W3C, 2003. Доступно с сайта: http://www.w3.org/TR/SVG/

[bibliography]

[float]
=== Вторичные и дополнительные
- [[[XML,6]]] Брей, Т., Паоли, Дж., Сперберг-Маккуин, С. М., Малер Э., Йерго, Ф. a kol.:
    _Extensible Markup Language (XML) 1.0 (Fourth Edition)_
    [online]. W3C, 2006. Доступно с сайта: http://www.w3.org/TR/REC-xml/

- [[[INFOSET,7]]] Коуэн, Дж., Тобин, Р.:
    _XML Information Set (Second Edition)_
    [online]. W3C, 2004. Доступно с сайта: http://www.w3.org/TR/xml-infoset/

- [[[NAMESPACE,8]]] Брэй, Т., Холландер, Д., Лейман, А., Тобин, Р.:
    _Namespaces in XML 1.0 (Second Edition)_
    [online]. W3C, 2006. Доступно с сайта: http://www.w3.org/TR/REC-xml-names/

- [[[DOM1,9]]] Вуд, Л. a kol.:
    _Document Object Model (DOM) Level 1 Specification_
    [online]. W3C, 1998. Доступно с сайта: http://www.w3.org/TR/REC-DOM-Level-1/

- [[[DOM2,10]]] Вуд, Л. a kol.:
    _Document Object Model (DOM) Level 2 Core Specification_
    [online]. W3C, 2000. Доступно с сайта: http://www.w3.org/TR/DOM-Level-2-Core/

- [[[CSS,11]]] Лие Х. В., Бос, Б.:
    _Cascading Style Sheets, level 1_
    [online]. W3C, 1996. Доступно с сайта: http://www.w3.org/TR/CSS1/

- [[[M254,12]]] Холл, У., Кейнс, М.:
итм    _M254 Java everywhere_
    [online]. The Open University, 2005. Доступно с сайта: http://computing.open.ac.uk/m254/

:sectnums:

:sectnums!:

[appendix]
== Термины
[glossary]
API:: Application Programming Interface,
    интерфейс прикладных программ. Набор процедур, функций или классов
    конкретная библиотека, программа или ядро операционной системы, которые могут
    быть использованным в приложениях.

CSS:: Cascading Style Sheets, каскадные стили.
    Простой механизм добавления графического редактирования в сеть
    докуранты. Стандарт W3C, в частности, в <<CSS>>.

Data binding:: Конвертируемые данные между различными форматами. Например, между XML-документами,
    объекты объектно-ориентированных систем и реляционные таблицы
    систем баз данных.

DOM:: Document Object Model, объектная модель
    документов. Независимый от платформы и языка интерфейс, который позволяет
    программам и скриптам динамического доступа к контенту, структуре и стилю
    документа, и его редактирование. Обеспечивает объектно-ориентированное
    представление документа XML или HTML. Спецификации W3C в <<DOM1>>, <<DOM2>> и др.

DTD:: Document Type Definition, определение типа
    документа. DTD предоставляет инструменты для определения разрешенных структур
    элементов и атрибутов, позволяющих устанавливать значения атрибутов по умолчанию. Повторно используемое содержимое также может быть определено в DTD
    (entity) и дополнительная информация (notace). Спецификация 
    является частью рекомендации W3C по XML – <<XML>> и
    другие.

ECMAScript:: Язык сценариев (программирования), стандартизированный организацией
    Ecma International в спецификации
    ECMA-262. Он широко используется в интернете и часто
    упоминается как JavaScript или JScript, в соответствии с основными
    диалектами этого языка.

Framework:: Базовая концептуальная структура, используемая для решения или фокусировки
    внимания на сложных проблемах. В области программного обеспечения это часто
    библиотеки, вспомогательные программы, шаблоны проектирования и лучшие практики.
    Фреймворк решает типичные задачи, которые идентичны в большинстве приложений,
    что облегчает разработку.

HTML:: HyperText Markup Language, язык
    разметки гиперссылок. Язык для создания сайтов, приложений SGML.
    Спецификация была выпущена организацией W3C.

Информационный элемент:: Information item. Представляет узел
    древовидной структуры XML infosetu. Спецификация <<INFOSET>> определяет одиннадцать различных типов элементов. Каждый
    из них имеет определенные свойства, такие как родительский элемент, локальное имя и т. д.
    В этой работе я упоминаю информационный элемент персонажа, 
    атрибут информационного элемента.

Infoset:: XML Information Set это абстрактная модель
    данных XML документа, состоящая из отдельных информационных элементов.
    Спецификация W3C <<infoset>>.

Java:: Объектно-ориентированный, строго наборный, платформенно-независимый
    язык программирования от Sun Microsystems.

Namespace:: Пространство имен. XML обеспечивает простой метод для
    квалификация наименований элементов и атрибутов путем их включения в в пространство имен
    с идентификатором URI. Спецификация W3C <<NAMESPACE>>.

Разбор:: Анализ представленных данных и поиск элементов,
    соответствующих определению того или иного языка. Обычно это синтаксический анализ
    исходных кодов, написанных на заданном языке программирования.

PSVI:: Post Schema Validation Infoset, информационный пакет (инфосеть?)
    после проверки документа по схеме. Это информационный набор XML - документов,
    дополненный информацией о типах элементов данных. Вклады PSVI
    определяются в спецификации XML-схемы <<XSD1>>
    и < < xsd2>>.

Визуализация:: Рендеринг-процесс, с помощью которого
    изображение визуализируется из введенных данных.

SAX:: Simple API for XML, простой интерфейс
    приложения для XML. Предоставляет механизм для чтения данных из XML
    документов. Чтение происходит последовательно и основано на событиях
    (чтение начального тега, чтение конечного тега и т. д.). Поэтому
    модификация структуры документа, в отличие от Dom, невозможна.

SVG:: Scalable Vector Graphics, масштабируемая
    векторная графика. SVG-это язык для описания двумерной графики и
    графических приложений с использованием XML. Разработка основана на спецификации SVG
    1.1, выпущенной в качестве рекомендации консорциума W3C 14. 1 января 2003 года <<SVG>>.

Tag:: Метка, определяющая начало и/или конец элемента.

Validace:: Верификация XML-документа в соответствии со схемой.

W3C:: World Wide Web Consortium. Она занимается
    разработкой совместимых технологий-спецификаций, руководств,
    программного обеспечения и инструментов с целью унификации используемых технологий
    и достижения полного развития и использования возможностей интернета.

XHTML:: Extensible HyperText Markup Language,
    расширяемый язык разметки гипертекста. Язык для создания 
    веб-страниц, xml-приложений. Спецификация была выпущена организацией
    W3C.

XML:: Extensible Markup Language, расширяемый
    язык разметки. Позволяет разработчикам создавать пользовательские форматы хранения и обмена данными.
    Спецификация была опубликована консорциумом W3C, <<XML>> и другими.

XML schéma:: XML-схемы предоставляют средства для определения структуры,
    содержания и семантики XML-документов. Xml-схема была одобрена в качестве
    рекомендации W3C 2 мая 2001 года, а вторая, измененная версия
    была выпущена 28 октября 2004 года <<XSD0>>, <<XSD1>>, <<XSD2>>.


:sectnums:

:sectnums!:

[appendix]
[[_CD]]
== Содержимое компакт-диска

Эта работа включает в себя прилагаемый компакт-диск с текстом работы, исходные коды и готовое приложение.
Последняя версия будет доступна по адресу: http://st.vse.cz/~XSLAV14/.
В частности, на компакт-диске вы найдете следующую структуру каталогов и файлов:

. [.path]_/thesis_ – справочник, связанный с написанием бакалаврской диссертации, содержит:
** [.path]_/images_ – папку используемых изображений за исключением символов компонентов схемы
** [.path]_/symbols_ – папку с изображениями символов компонентов схемы в формате SVG
** [.path]_thesis.xml_ – пользовательский текст работы в формате DocBook
** [.path]_thesis.xsl_, [.path]_tp-fo.xsl_ – стили, изменяющие стандартный вывод DocBook
** [.path]_kizi.pdf_ – логотип отдела для первой страницы footnote:[Upravené styly a logo katedry pochází ze stránek Jiřího Koska, věnovaných výuce na VŠE: http://www.kosek.cz/vyuka/.]
** [.path]_thesis.pdf_ – сгенерированный PDF файл с этой работой
. [.path]_/src_ – Каталог исходного кода Java, структура которого основана на включении классов в пакеты
. [.path]_/res_ – каталог других ресурсов, содержащих:
** [.path]_/examples_ – папку с примерами XSD-входов
** [.path]_/licenses_ – лицензионную папку Xerces 
** [.path]_readme.txt_ – текстовый документ, описывающий пользовательский интерфейс
. [.path]_/lib_ – каталог содержащий реализацию парсера Xerces – [.path]_xercesImpl.jar_
. [.path]_/dist_ – папка с готовым к использованию приложением содержит:
** [.path]_/examples_ – скопировано из каталога [.path]_/res_
** [.path]_/licenses_ – скопировано из каталога [.path]_/res_
** [.path]_/lib_ – библиотечный каталог:
... копия файла [.path]_xercesImpl.jar_ и любые другие файлы из каталога [.path]_/lib_
... архив с приложением [.path]_xsdvi.jar_
** [.path]EXAMPLES.bat_ – запуск преобразования примеров, схем из папки examples
** [.path]_readme.txt_ – скопировано из каталога [.path]_/res_
. [.path]_build.properties_ – настройку свойств, используемых в [.path]_build.xml_
. [.path]_build.xml_ – XML skript для программы сборки Ant


:sectnums:

:sectnums!:

[appendix]
[[EXAMPLES]]
== Příklad

=== XML schéma – ukázkový vstup

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="contact" type="ContactType"/>

    <xs:complexType name="ContactType">
        <xs:sequence>
            <xs:element name="phone" type="xs:string"/>
            <xs:element name="address" type="AddressType"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="AddressType">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="street" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
----

[[EXAMPLES-SVG-XML]]
=== SVG výstup (XML reprezentace)

[source, xml]
----
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN'
  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
<svg id='svg' onload='loadSVG();'
  xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<title>XsdVi</title>

<script type='text/ecmascript'><![CDATA[
  var efBoxes = [];
  var eSvg = null;
  function loadSVG() {
    efBoxes = getElementsByClassName('box', document.getElementsByTagName('g'));
    eSvg = document.getElementById('svg');
    expandAll();
  }

  function getElementsByClassName(sClass, nlNodes) {
    var elements = [];
    for (var i=0; i<nlNodes.length; i++) {
      if(nlNodes.item(i).nodeType==1
        && sClass==nlNodes.item(i).getAttribute('class')) {
        elements.push(nlNodes.item(i));
      }
    }
    return elements;
  }

  function show(sId) {
    var useElement = document.getElementById('s'+sId);
    var moveNext = false;
    var eBoxLast;
    var maxX = 500;

    if (notPlus(useElement)) {
      eBoxLast = document.getElementById(sId);
      setPlus(useElement);
      for (var i=0; i<efBoxes.length; i++) {
        var eBox = efBoxes[i];
        if (moveNext) {
          move(eBoxLast, eBox);
        }
        else if (isDescendant(sId, eBox.id)) {
          eBox.setAttribute('visibility', 'hidden');
        }
        else if (isHigherBranch(sId, eBox.id)) {
          move(eBoxLast, eBox);
          moveNext = true;
        }
        if (eBox.getAttribute('visibility') != 'hidden') {
          eBoxLast = eBox;
          x = xTrans(eBox);
          if (x > maxX) maxX = x;
        }
      }
    }
    else {
      setMinus(useElement);
      var skipDescendantsOf;
      for (var i=0; i<efBoxes.length; i++) {
        var eBox = efBoxes[i];
        if (moveNext) {
          move(eBoxLast, eBox);
        }
        else if (isDescendant(sId, eBox.id) && (!skipDescendantsOf
          || !isDescendant(skipDescendantsOf.id, eBox.id))) {
          eBox.setAttribute('visibility', 'visible');
          move(eBoxLast, eBox);
          if (nextClosed(eBox)) skipDescendantsOf = eBox;
        }
        else if (isHigherBranch(sId, eBox.id)) {
          move(eBoxLast, eBox);
          moveNext = true;
        }
        if (eBox.getAttribute('visibility') != 'hidden') {
          eBoxLast = eBox;
          x = xTrans(eBox);
          if (x > maxX) maxX = x;
        }
      }
    }
    setHeight(yTrans(eBoxLast)+71);
    setWidth(maxX+300);
  }

  function collapseAll() {
    for (var i=0; i<efBoxes.length; i++) {
      var eBox = efBoxes[i];
      var useElement = document.getElementById('s'+eBox.id);
      if (useElement) setPlus(useElement);
      if (eBox.id != '_1') eBox.setAttribute('visibility', 'hidden');
    }
    setHeight(400);
    setWidth(500);
  }

  function expandAll() {
    var eBoxLast;
    var maxX = 0;
    for (var i=0; i<efBoxes.length; i++) {
      var eBox = efBoxes[i];
      var useElement = document.getElementById('s'+eBox.id);
      if (useElement) setMinus(useElement);
      move(eBoxLast, eBox);
      eBox.setAttribute('visibility', 'visible');
      eBoxLast = eBox;
      var x = xTrans(eBox);
      if (x > maxX) maxX = x;
    }
    setHeight(yTrans(eBoxLast)+71);
    setWidth(maxX+300);
  }

  function makeVisible(sId) {
    var childNodes = document.getElementById(sId).childNodes;
    var hidden = getElementsByClassName('hidden', childNodes);
    var visible = getElementsByClassName('visible', childNodes);
    inheritVisibility(hidden);
    hiddenVisibility(visible);
  }

  function makeHidden(sId) {
    var childNodes = document.getElementById(sId).childNodes;
    var hidden = getElementsByClassName('hidden', childNodes);
    var visible = getElementsByClassName('visible', childNodes);
    inheritVisibility(visible);
    hiddenVisibility(hidden);
  }

  function inheritVisibility(efElements) {
    for (var i=0; i<efElements.length; i++) {
      efElements[i].setAttribute('visibility', 'inherit');
    }
  }

  function hiddenVisibility(efElements) {
    for (var i=0; i<efElements.length; i++) {
      efElements[i].setAttribute('visibility', 'hidden');
    }
  }

  function nextClosed(eBox) {
    var useElement = document.getElementById('s'+eBox.id);
    return (useElement && !notPlus(useElement));
  }

  function isHigherBranch(sSerialLower, sSerialHigher) {
    var sLower = sSerialLower.split('_');
    var sHigher = sSerialHigher.split('_');
    for (var i=0; i<sLower.length; i++) {
      if (Number(sHigher[i]) > Number(sLower[i])) return true;
      else if (Number(sHigher[i]) < Number(sLower[i])) return false;
    }
    return false;
  }

  function isOnHigherLevel(eBoxLower, eBoxHigher) {
    var sLower = eBoxLower.id.split('_');
    var sHigher = eBoxHigher.id.split('_');
    for (var i=0; i<sLower.length; i++) {
      if (Number(sHigher[i]) > Number(sLower[i])) return true;
    }
    return false;
  }

  function isDescendant(sSerialAsc, sSerialDesc) {
    return (sSerialDesc.length > sSerialAsc.length &&
      sSerialDesc.indexOf(sSerialAsc) === 0);
  }

  function getParent(eBox) {
    var serial = eBox.id.substring(0, eBox.id.lastIndexOf('_'));
    return document.getElementById(serial);
  }

  function move(eBoxLast, eBox) {
    if (!eBoxLast) return;
    if (isOnHigherLevel(eBoxLast, eBox)) {
      eBox.setAttribute('transform',
        'translate('+xTrans(eBox)+','+(yTrans(eBoxLast)+71)+')');
      var parent = getParent(eBox);
      var line = document.getElementById('p'+eBox.id);
      if (!parent || !line) return;
      line.setAttribute('y1', String(yTrans(parent)-yTrans(eBox)+23));
    }
    else {
      eBox.setAttribute('transform',
        'translate('+xTrans(eBox)+','+yTrans(eBoxLast)+')');
    }
  }

  function notPlus(eUseElement) {
    return (eUseElement.getAttributeNS('http://www.w3.org/1999/xlink',
      'href') != '#plus');
  }

    eUseElement.setAttributeNS('http://www.w3.org/1999/xlink',
      'href', '#plus');
  }

  function setMinus(eUseElement) {
    eUseElement.setAttributeNS('http://www.w3.org/1999/xlink',
      'href', '#minus');
  }

  function setHeight(nHeight) {
    eSvg.setAttribute('height', nHeight);
  }

  function setWidth(nWidth) {
    eSvg.setAttribute('width', nWidth);
  }

  function yTrans(eBox) {
    var transform = eBox.getAttribute('transform');
    var y = Number(transform.substring(10,
      Number(transform.length)-1).split(',')[1]);
    if(!y) y = 0;
    return y;
  }

  function xTrans(eBox) {
    var transform = eBox.getAttribute('transform');
    var x = Number(transform.substring(10,
      Number(transform.length)-1).split(',')[0]);
    if(!x) x = 0;
    return x;
  }
]]></script>

<defs>

<style type='text/css'><![CDATA[

svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}

]]></style>

  <symbol class='button' id='plus'>
    <rect x='1' y='1' width='10' height='10'/>
    <line x1='3' y1='6' x2='9' y2='6'/>
    <line x1='6' y1='3' x2='6' y2='9'/>
  </symbol>
  <symbol class='button' id='minus'>
    <rect x='1' y='1' width='10' height='10'/>
    <line x1='3' y1='6' x2='9' y2='6'/>
  </symbol>

</defs>

<rect class='button' x='300' y='10' width='20' height='20'
  onclick='collapseAll()'/>
<line x1='303' y1='20' x2='317' y2='20'/>
<text x='330' y='20'>collapse all</text>
<rect class='button' x='400' y='10' width='20' height='20'
  onclick='expandAll()'/>
<line x1='403' y1='20' x2='417' y2='20'/>
<line x1='410' y1='13' x2='410' y2='27'/>
<text x='430' y='20'>expand all</text>

<g id='_1' class='box' transform='translate(20,50)'>
<rect class='boxschema' x='0' y='12' width='63' height='21'/>
<text x='5' y='27'><tspan class='big'>/ </tspan>schema</text>
<use x='62' y='17' xlink:href='#minus' id='s_1' onclick='show("_1")'/>
</g>

<g id='_1_1' class='box' transform='translate(128,50)'>
<rect class='shadow' x='3' y='3' width='117' height='46'/>
<rect class='boxelement' x='0' y='0' width='117' height='46'
  onmouseover='makeVisible("_1_1")' onmouseout='makeHidden("_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>contact</text>
<text class='visible' x='5' y='41'>type: ContactType</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='116' y='17' xlink:href='#minus' id='s_1_1' onclick='show("_1_1")'/>
</g>

<g id='_1_1_1' class='box' transform='translate(290,50)'>
<rect class='boxcompositor' x='0' y='8' width='60' height='31' rx='9'/>
<circle cx='42' cy='14' r='2'/>
<circle cx='42' cy='23' r='2'/>
<circle cx='42' cy='32' r='2'/>
<text class='small' x='30' y='17'>1</text>
<text class='small' x='30' y='26'>2</text>
<text class='small' x='30' y='35'>3</text>
<line x1='42' y1='14' x2='42' y2='32'/>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='59' y='17' xlink:href='#minus' id='s_1_1_1'
  onclick='show("_1_1_1")'/>
</g>

<g id='_1_1_1_1' class='box' transform='translate(395,50)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_1")'
  onmouseout='makeHidden("_1_1_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>phone</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2' class='box' transform='translate(395,121)'>
<rect class='shadow' x='3' y='3' width='117' height='46'/>
<rect class='boxelement' x='0' y='0' width='117' height='46'
  onmouseover='makeVisible("_1_1_1_2")'
  onmouseout='makeHidden("_1_1_1_2")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>address</text>
<text class='visible' x='5' y='41'>type: AddressType</text>
<line class='connection' id='p_1_1_1_2' x1='-35' y1='-48' x2='-35' y2='-40'/>
<path class='connection' d='M-35,-40 Q-35,15 0,23'/>
<use x='116' y='17' xlink:href='#minus' id='s_1_1_1_2'
  onclick='show("_1_1_1_2")'/>
</g>

<g id='_1_1_1_2_1' class='box' transform='translate(557,121)'>
<rect class='boxcompositor' x='0' y='8' width='60' height='31' rx='9'/>
<circle cx='42' cy='14' r='2'/>
<circle cx='42' cy='23' r='2'/>
<circle cx='42' cy='32' r='2'/>
<text class='small' x='30' y='17'>1</text>
<text class='small' x='30' y='26'>2</text>
<text class='small' x='30' y='35'>3</text>
<line x1='42' y1='14' x2='42' y2='32'/>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='59' y='17' xlink:href='#minus' id='s_1_1_1_2_1'
  onclick='show("_1_1_1_2_1")'/>
</g>

<g id='_1_1_1_2_1_1' class='box' transform='translate(662,121)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_1")'
  onmouseout='makeHidden("_1_1_1_2_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>name</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2_1_2' class='box' transform='translate(662,192)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_2")'
  onmouseout='makeHidden("_1_1_1_2_1_2")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>street</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2_1_3' class='box' transform='translate(662,263)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_3")'
  onmouseout='makeHidden("_1_1_1_2_1_3")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>city</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' id='p_1_1_1_2_1_3'
  x1='-35' y1='-119' x2='-35' y2='-40'/>
<path class='connection' d='M-35,-40 Q-35,15 0,23'/>
</g>

</svg>
----

=== SVG výstup (grafická reprezentace)

[[MY-MODEL-APPENDIX]]
.Grafický výstup
image::images/model_my.svg[]


:sectnums:

